using System;
using System.Collections.Generic;
using System.Reflection;
using System.Text;
using System.IO;
using HelpData;
using ModernMUD;

namespace MUDEngine
{
    /// <summary>
    /// Contains player-entered and mob-usable commands.  These are used as CommandType.CommandFunction
    /// delegates in the CommandType.CommandTable.
    /// </summary>
    public class Command
    {
        /// <summary>
        /// Prints a player's command history.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void History(CharData ch, string[] str)
        {
            if (ch == null || ch._socket == null)
            {
                return;
            }

            int num = 0;
            foreach (HistoryData history in ch._socket._history)
            {
                ++num;
                string text = " " + MUDString.PadInt(Math.Abs(num), 4) + ": " + history.Command + "\r\n";
                ch.SendText(text);
            }

            return;
        }

        /// <summary>
        /// Gets the stats on a vehicle.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        static void StatVehicle(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int number = 0;
            string text;

            foreach (Vehicle vehicle in Database.VehicleList)
            {
                number++;
                text = String.Format("Vehicle type: {0}  Hull points: {1}  Owner: {2}  FlyLevel: {3}\r\n",
                          vehicle.Type, vehicle.HullPoints, vehicle.OwnerName, vehicle.FlyLevel);
                ch.SendText(text);
                text = String.Format("Occupants: {0}  Direction: {1}  Speed: {2} MT/MD/MP: {3} {4} {5}\r\n",
                          vehicle.Occupants, vehicle.Direction, vehicle.Speed,
                          vehicle.MovementTimer, vehicle.MovementDelay,
                          vehicle.MovementPointer);
                ch.SendText(text);
                if (vehicle.ParentObject == null)
                {
                    ch.SendText("vehicle has no associated object data!");
                    continue;
                }
                text = String.Format("Room: {0}\r\n",
                          vehicle.ParentObject.InRoom.IndexNumber);
                ch.SendText(text);
                text = String.Format("IndexNumber: {0}  Key: {1}  MaxBoard: {2}  MaxSpeed: {3}  MaxHull: {4}  Fire: {5}\r\n",
                          vehicle.ParentObject.ObjIndexData.IndexNumber, vehicle.ParentObject.Values[0],
                          vehicle.ParentObject.Values[3], vehicle.ParentObject.Values[4],
                          vehicle.ParentObject.Values[5], vehicle.ParentObject.Values[6]);
                ch.SendText(text);
            }
            text = String.Format("{0} total.\r\n", number);
            ch.SendText(text);
        }

        /// <summary>
        /// Disembark (exit) from a ship or vehicle.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Disembark(CharData ch, string[] str)
        {
            if (ch == null || !ch._inRoom)
            {
                return;
            }

            foreach (Vehicle vehicle in Database.VehicleList)
            {
                if (!vehicle.ParentObject)
                    continue;
                if (ch._inRoom.IndexNumber == vehicle.EntryRoomTemplateNumber)
                {
                    if (vehicle.ParentObject.InRoom)
                    {
                        ch.RemoveFromRoom();
                        ch.AddToRoom(vehicle.ParentObject.InRoom);
                        SocketConnection.Act("$n&n disembarks from $p&n.", ch, vehicle.ParentObject, null, SocketConnection.MessageTarget.room);
                        SocketConnection.Act("You disembark from $p&n.", ch, vehicle.ParentObject, null, SocketConnection.MessageTarget.character);
                        return;
                    }
                }
            }

            ch.SendText("You don't realize you're not on a boat right now?\r\n");
        }

        /// <summary>
        /// Looks at the panel of a ship or vehicle for status info.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Lookpanel(CharData ch, string[] str)
        {
            if (ch == null || !ch._inRoom)
            {
                return;
            }

            string text;

            foreach (Vehicle vehicle in Database.VehicleList)
            {
                if (!vehicle.ParentObject)
                    continue;
                if (ch._inRoom.IndexNumber == vehicle.ControlPanelRoomTemplateNumber)
                {
                    text = String.Format("Ship Control Panel Readout:\r\n" +
                              "Hull: {0}/{1}  Occupants: {2}/{3}  Speed: {4}/{5} Firepower: {6}\r\n",
                              vehicle.HullPoints, vehicle.ParentObject.Values[5],
                              vehicle.Occupants, vehicle.ParentObject.Values[3],
                              vehicle.Speed, vehicle.ParentObject.Values[4],
                              vehicle.ParentObject.Values[6]);
                    ch.SendText(text);
                    return;
                }
            }

            ch.SendText("You do not see that here.\r\n");
            return;
        }

        /// <summary>
        /// Command your ship to perform an action.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void OrderShip(CharData ch, string[] str)
        {
            if (ch == null || ch._inRoom == null)
            {
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("What do you want to order the ship to *do*?\r\n");
            }

            foreach (Vehicle vehicle in Database.VehicleList)
            {
                if (vehicle.ParentObject == null)
                    continue;
                if (ch._inRoom.IndexNumber == vehicle.ControlPanelRoomTemplateNumber)
                {
                    if (str.Length > 1 && !MUDString.StringsNotEqual(str[0], "speed"))
                    {
                        if (!MUDString.StringsNotEqual(str[1], "stop"))
                        {
                            vehicle.Speed = 0;
                        }
                        else if (!MUDString.StringsNotEqual(str[1], "full") || !MUDString.StringsNotEqual(str[1], "fast"))
                        {
                            vehicle.Speed = vehicle.ParentObject.Values[4];
                        }
                        else if (!MUDString.StringsNotEqual(str[1], "medium"))
                        {
                            vehicle.Speed = vehicle.ParentObject.Values[4] * 2 / 3;
                        }
                        else if (!MUDString.StringsNotEqual(str[1], "slow"))
                        {
                            vehicle.Speed = vehicle.ParentObject.Values[4] * 1 / 3;
                        }
                        else
                        {
                            ch.SendText("No such speed, try full, medium, slow, or stop.\r\n");
                            return;
                        }
                        SocketConnection.Act("$n&n orders a change of speed.", ch, null, null, SocketConnection.MessageTarget.room);
                        SocketConnection.Act("You order a change of speed.", ch, null, null, SocketConnection.MessageTarget.character);
                        return;
                    }
                    if (str.Length > 1 && !MUDString.StringsNotEqual(str[0], "sail"))
                    {
                        int door = -1;
                        Room room;

                        if (!MUDString.IsPrefixOf(str[1], "north"))
                            door = 0;
                        else if (!MUDString.IsPrefixOf(str[1], "east"))
                            door = 1;
                        else if (!MUDString.IsPrefixOf(str[1], "south"))
                            door = 2;
                        else if (!MUDString.IsPrefixOf(str[1], "west"))
                            door = 3;
                        else if (!MUDString.IsPrefixOf(str[1], "northwest"))
                            door = 6;
                        else if (!MUDString.IsPrefixOf(str[1], "southwest"))
                            door = 7;
                        else if (!MUDString.IsPrefixOf(str[1], "northeast"))
                            door = 8;
                        else if (!MUDString.IsPrefixOf(str[1], "southeast"))
                            door = 9;
                        else if (!MUDString.StringsNotEqual(str[1], "nw"))
                            door = 6;
                        else if (!MUDString.StringsNotEqual(str[1], "sw"))
                            door = 7;
                        else if (!MUDString.StringsNotEqual(str[1], "ne"))
                            door = 8;
                        else if (!MUDString.StringsNotEqual(str[1], "se"))
                            door = 9;

                        if (door == -1)
                        {
                            ch.SendText("That's not a valid direction.\r\n");
                            return;
                        }

                        if (!vehicle.ParentObject.InRoom.ExitData[door] || 
                            !(room = Room.GetRoom(vehicle.ParentObject.InRoom.ExitData[door].IndexNumber)))
                        {
                            ch.SendText("Your ship cannot go that way.\r\n");
                            return;
                        }

                        if (room.TerrainType != TerrainType.ocean && !room.HasFlag(RoomTemplate.ROOM_DOCKABLE))
                        {
                            ch.SendText("Your ship can only sail on deep water.\r\n");
                            return;
                        }

                        // Taken from the Commandrecho code - Xangis
                        string buf = vehicle.ParentObject.ShortDescription + "&n sails " + Exit.DirectionName[door] + ".";
                        foreach (SocketConnection socket in Database.SocketList)
                        {
                            if (socket._connectionState == SocketConnection.ConnectionState.playing
                                && socket.Character._inRoom == vehicle.ParentObject.InRoom)
                            {
                                socket.Character.SendText(buf);
                                socket.Character.SendText("\r\n");
                            }
                        }
                        SocketConnection.Act(buf, ch, vehicle.ParentObject, null, SocketConnection.MessageTarget.room);
                        SocketConnection.Act(buf, ch, vehicle.ParentObject, null, SocketConnection.MessageTarget.character);
                        buf += vehicle.ParentObject.ShortDescription + "&n sails in from " + Exit.ReverseDirectionName[door] + ".";
                        foreach (SocketConnection socket in Database.SocketList)
                        {
                            if (socket._connectionState == SocketConnection.ConnectionState.playing
                                && socket.Character._inRoom == room)
                            {
                                socket.Character.SendText(buf);
                                socket.Character.SendText("\r\n");
                            }
                        }
                        vehicle.ParentObject.RemoveFromRoom();
                        vehicle.ParentObject.AddToRoom(room);
                        return;
                    }
                    if (!MUDString.StringsNotEqual(str[0], "fire"))
                    {
                        ch.SendText("Not implemented yet.\r\n");
                        return;
                    }
                    if (!MUDString.StringsNotEqual(str[0], "ram"))
                    {
                        ch.SendText("Not implemented yet.\r\n");
                        return;
                    }
                    if (!MUDString.StringsNotEqual(str[0], "board"))
                    {
                        ch.SendText("Not implemented yet.\r\n");
                        return;
                    }
                    ch.SendText("What are you trying to order the ship do to?\r\n");
                    return;
                }
            }

            ch.SendText("You can't order a ship when you are not at the helm.\r\n");
            return;
        }

        /// <summary>
        /// Lets an immortal control which channels they will or won't see.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void ImmortalChannels(CharData ch, string[] str)
        {
            if (ch == null)
            {
                return;
            }

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("immtalk") || realChar.IsNPC() || !realChar.IsImmortal() )
            {
                return;
            }

            int value = ((PC)realChar).ImmortalData.ImmtalkFlags;

            if (str.Length == 0)
            {
                ch.SendText("&+L+-------------+------------------------------------------------------------+&n\r\n");
                ch.SendText("&+L|&n&+m  Option&+L     |&n&+r Description&n                                                &+L|&n\r\n");
                ch.SendText("&+L+-------------+------------------------------------------------------------+&n\r\n");

                ch.SendText(Macros.IsSet(value, ImmortalChat.IMMTALK_ON)
                              ? "&+L[&+WX&+L]&n Immtalk   &+L|&n &+cImmtalk is on.                                             &+L|&n\r\n"
                              : "&+L[ ]&n Immtalk   &+L|&n &+cImmtalk is off.                                            &+L|&n\r\n"
                               );

                ch.SendText(Macros.IsSet(value, ImmortalChat.IMMTALK_TICKS)
                              ? "&+L[&+WX&+L]&n Ticks     &+L|&n &+cYou see are notified of ticks.                             &+L|&n\r\n"
                              : "&+L[ ]&n Ticks     &+L|&n &+cYou aren't notified of ticks.                              &+L|&n\r\n"
                              );

                ch.SendText(Macros.IsSet(value, ImmortalChat.IMMTALK_LOGINS)
                              ? "&+L[&+WX&+L]&n Logins    &+L|&n &+cYou are notified of logins.                                &+L|&n\r\n"
                              : "&+L[ ]&n Logins    &+L|&n &+cYou aren't notified of logins.                             &+L|&n\r\n"
                              );

                ch.SendText(Macros.IsSet(value, ImmortalChat.IMMTALK_CRIME)
                              ? "&+L[&+WX&+L]&n Ctime     &+L|&n &+cYou are notified of various crime flags.                   &+L|&n\r\n"
                              : "&+L[ ]&n Crime     &+L|&n &+cYou aren't notified of various crime flags.                &+L|&n\r\n"
                               );

                ch.SendText(Macros.IsSet(value, ImmortalChat.IMMTALK_DEATHS)
                              ? "&+L[&+WX&+L]&n Deaths    &+L|&n &+cYou are notified of deaths.                                &+L|&n\r\n"
                              : "&+L[ ]&n Deaths    &+L|&n &+cYou aren't notified of deaths.                             &+L|&n\r\n"
                               );

                ch.SendText(Macros.IsSet(value, ImmortalChat.IMMTALK_RESETS)
                              ? "&+L[&+WX&+L]&n Resets    &+L|&n &+cYou are notified of area resets.                           &+L|&n\r\n"
                              : "&+L[ ]&n Resets    &+L|&n &+cYou aren't notified of area resets.                        &+L|&n\r\n"
                               );

                ch.SendText(Macros.IsSet(value, ImmortalChat.IMMTALK_LEVELS)
                              ? "&+L[&+WX&+L]&n Levels    &+L|&n &+cYou are notified when a player levels.                     &+L|&n\r\n"
                              : "&+L[ ]&n Levels    &+L|&n &+cYou aren't notified when a player levels.                  &+L|&n\r\n"
                               );

                ch.SendText(Macros.IsSet(value, ImmortalChat.IMMTALK_SECURE)
                              ? "&+L[&+WX&+L]&n Secure    &+L|&n &+cYou are notified of all logs.                              &+L|&n\r\n"
                              : "&+L[ ]&n Secure    &+L|&n &+cYou aren't notified of logs.                               &+L|&n\r\n"
                              );

                ch.SendText(Macros.IsSet(value, ImmortalChat.IMMTALK_SWITCHES)
                              ? "&+L[&+WX&+L]&n Switches  &+L|&n &+cYou are notified of switching immortals.                   &+L|&n\r\n"
                              : "&+L[ ]&n Switches  &+L|&n &+cYou aren't notified of switching immortals.                &+L|&n\r\n"
                               );

                ch.SendText(Macros.IsSet(value, ImmortalChat.IMMTALK_SNOOPS)
                              ? "&+L[&+WX&+L]&n Snoops    &+L|&n &+cYou are notified of other immortals snoops.                &+L|&n\r\n"
                              : "&+L[ ]&n Snoops    &+L|&n &+cYou aren't notified of other immortals snoops.             &+L|&n\r\n"
                               );

                ch.SendText(Macros.IsSet(value, ImmortalChat.IMMTALK_RESTORE)
                              ? "&+L[&+WX&+L]&n Restore   &+L|&n &+cYou are notified of all restores.                          &+L|&n\r\n"
                              : "&+L[ ]&n Restore   &+L|&n &+cYou aren't notified of restores.                           &+L|&n\r\n"
                               );

                ch.SendText(Macros.IsSet(value, ImmortalChat.IMMTALK_LOAD)
                              ? "&+L[&+WX&+L]&n Load      &+L|&n &+cYou are notified of all mloads and oloads.                 &+L|&n\r\n"
                              : "&+L[ ]&n Load      &+L|&n &+cYou aren't notified of mloads and oloads.                  &+L|&n\r\n"
                               );

                ch.SendText(Macros.IsSet(value, ImmortalChat.IMMTALK_NEWBIE)
                              ? "&+L[&+WX&+L]&n Newbie    &+L|&n &+cYou are notified of incoming newbies.                      &+L|&n\r\n"
                              : "&+L[ ]&n Newbie    &+L|&n &+cYou aren't notified of incoming newbies.                   &+L|&n\r\n"
                               );

                ch.SendText(Macros.IsSet(value, ImmortalChat.IMMTALK_DEBUG)
                              ? "&+L[&+WX&+L]&n Debug     &+L|&n &+cYou are notified of all bugs.                              &+L|&n\r\n"
                              : "&+L[ ]&n Debug     &+L|&n &+cYou aren't notified of bugs.                               &+L|&n\r\n"
                              );

                ch.SendText(Macros.IsSet(value, ImmortalChat.IMMTALK_PETITION)
                              ? "&+L[&+WX&+L]&n Petition  &+L|&n &+cYou can hear player petitions.                             &+L|&n\r\n"
                              : "&+L[ ]&n Petition  &+L|&n &+cYou can't hear player petitions.                           &+L|&n\r\n"
                              );

                ch.SendText(Macros.IsSet(value, ImmortalChat.IMMTALK_QUESTS)
                              ? "&+L[&+WX&+L]&n Quests    &+L|&n &+cYou see quest checking.                                    &+L|&n\r\n"
                              : "&+L[ ]&n Quests    &+L|&n &+cYou don't see quest checking.                              &+L|&n\r\n"
                              );

                ch.SendText(Macros.IsSet(value, ImmortalChat.IMMTALK_HUNTING)
                              ? "&+L[&+WX&+L]&n Hunting   &+L|&n &+cYou see hunter actions.                                    &+L|&n\r\n"
                              : "&+L[ ]&n Hunting   &+L|&n &+cYou don't see hunter actions.                              &+L|&n\r\n"
                               );

                ch.SendText(Macros.IsSet(value, ImmortalChat.IMMTALK_HATING)
                              ? "&+L[&+WX&+L]&n Hating    &+L|&n &+cYou see hater actions.                                     &+L|&n\r\n"
                              : "&+L[ ]&n Hating    &+L|&n &+cYou don't see hater actions.                               &+L|&n\r\n"
                              );

                ch.SendText(Macros.IsSet(value, ImmortalChat.IMMTALK_SPAM)
                              ? "&+L[&+WX&+L]&n Spam      &+L|&n &+cYou monitor the spam channel.                              &+L|&n\r\n"
                              : "&+L[ ]&n Spam      &+L|&n &+cYou don't monitor the spam channel.                        &+L|&n\r\n"
                              );

                ch.SendText("&+L+-------------+------------------------------------------------------------+&n\r\n");
            }
            else
            {
                int setting = 0;
                int bit;
                if (str.Length < 2  || (str[1] != "+" && str[0] != "-") )
                {
                    ch.SendText("Syntax: immtalk <+|-> <channel>\r\n");
                }

                if (str[0] == "+")
                    setting = 1;
                else if (str[0] == "-")
                    setting = 0;

                if (!MUDString.StringsNotEqual(str[1], "ticks"))
                    bit = ImmortalChat.IMMTALK_TICKS;
                else if (!MUDString.StringsNotEqual(str[1], "logins"))
                    bit = ImmortalChat.IMMTALK_LOGINS;
                else if (!MUDString.StringsNotEqual(str[1], "deaths"))
                    bit = ImmortalChat.IMMTALK_DEATHS;
                else if (!MUDString.StringsNotEqual(str[1], "resets"))
                    bit = ImmortalChat.IMMTALK_RESETS;
                else if (!MUDString.StringsNotEqual(str[1], "crime"))
                    bit = ImmortalChat.IMMTALK_CRIME;
                else if (!MUDString.StringsNotEqual(str[1], "levels"))
                    bit = ImmortalChat.IMMTALK_LEVELS;
                else if (!MUDString.StringsNotEqual(str[1], "secure"))
                    bit = ImmortalChat.IMMTALK_SECURE;
                else if (!MUDString.StringsNotEqual(str[1], "switches"))
                    bit = ImmortalChat.IMMTALK_SWITCHES;
                else if (!MUDString.StringsNotEqual(str[1], "snoops"))
                    bit = ImmortalChat.IMMTALK_SNOOPS;
                else if (!MUDString.StringsNotEqual(str[1], "restore"))
                    bit = ImmortalChat.IMMTALK_RESTORE;
                else if (!MUDString.StringsNotEqual(str[1], "load"))
                    bit = ImmortalChat.IMMTALK_LOAD;
                else if (!MUDString.StringsNotEqual(str[1], "newbie"))
                    bit = ImmortalChat.IMMTALK_NEWBIE;
                else if (!MUDString.StringsNotEqual(str[1], "debug"))
                    bit = ImmortalChat.IMMTALK_DEBUG;
                else if (!MUDString.StringsNotEqual(str[1], "petition"))
                    bit = ImmortalChat.IMMTALK_PETITION;
                else if (!MUDString.StringsNotEqual(str[1], "quests"))
                    bit = ImmortalChat.IMMTALK_QUESTS;
                else if (!MUDString.StringsNotEqual(str[1], "hunting"))
                    bit = ImmortalChat.IMMTALK_HUNTING;
                else if (!MUDString.StringsNotEqual(str[1], "hating"))
                    bit = ImmortalChat.IMMTALK_HATING;
                else if (!MUDString.StringsNotEqual(str[1], "lspam"))
                    bit = ImmortalChat.IMMTALK_SPAM;
                else if (!MUDString.StringsNotEqual(str[1], "immtalk"))
                    bit = ImmortalChat.IMMTALK_ON;
                else
                {
                    ch.SendText("Immtalk: config which option?\r\n");
                    return;
                }

                if (setting == 1 || (!Macros.IsSet(value, bit) && setting == 2))
                {
                    ((PC)realChar).ImmortalData.ImmtalkFlags |= bit;
                    ch.SendText( str[1] + " is now ON.\r\n");
                }
                else
                {
                    ((PC)realChar).ImmortalData.ImmtalkFlags &= (~bit);
                    ch.SendText( str[1] + " is now OFF.\r\n");
                }

            }
            return;
        }

        /// <summary>
        /// Shows the world map.  Can be called from the look command or called directly.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Worldmap(CharData ch, string[] str)
        {
            int x;
            Room room;

            if (ch._inRoom == null)
            {
                return;
            }

            if (!ch._inRoom.Area.HasFlag(Area.AREA_WORLDMAP))
            {
                return;
            }

            // TODO: Use Map.GetUnderdarkVisibilityModifier(racewarside) and Map.GetDaytimeVisibilityModifier(racewarside)
            int visibility = 5 + (int)ch._flyLevel;

            // Godmode will make you see farther on the map.
            if (!ch.IsNPC() && ch.HasActBit(PC.PLAYER_GODMODE))
            {
                visibility += 5;
            }

            int indexNumber = ch._inRoom.IndexNumber;
            int startIndexNumber = ch._inRoom.Area.LowRoomIndexNumber;

            int column = (indexNumber - startIndexNumber) % ch._inRoom.Area.Width;
            int row = (indexNumber - startIndexNumber) / ch._inRoom.Area.Width;
            if (visibility <= 0 && !ch.IsAffected(Affect.AFFECT_BLIND))
            {
                visibility = 1;
            }

            if (visibility > Limits.MAX_MAP_VISIBILITY)
            {
                visibility = Limits.MAX_MAP_VISIBILITY;
            }

            string mapSpaces = String.Empty;
            string lineEnding = ":";
            string mapClose = "</map>";
            string text = "<map>";
            string boundchar = " ";
            bool graphicalClient = !ch.IsNPC() && ch._socket._terminalType == SocketConnection.TerminalType.TERMINAL_ENHANCED;
            if (!graphicalClient)
            {
                boundchar = "&-L &n";
                mapSpaces = "     ";
                lineEnding = "\r\n";
                mapClose = "\r\n";
                text = "\r\n";
            }
            for (x = (0 - Limits.MAX_MAP_VISIBILITY); x <= Limits.MAX_MAP_VISIBILITY; x++)
            {
                if (graphicalClient)
                {
                    text += (x + Limits.MAX_MAP_VISIBILITY).ToString() + "|";
                }
                else if (x < (0 - visibility) || x > (visibility))
                {
                    continue;
                }
                text += mapSpaces;
                int y;
                for (y = (0 - Limits.MAX_MAP_VISIBILITY); y <= Limits.MAX_MAP_VISIBILITY; y++)
                {
                    if(x < (0 - visibility) || x > (visibility))
                    {
                        if (graphicalClient)
                        {
                            text += boundchar;
                        }
                        else
                        {
                            continue;
                        }
                    }

                    bool hasM = false;
                    bool hasP = false;
                    room = Room.GetRoom((indexNumber + ((x * ch._inRoom.Area.Width) + y)));
                    if (room && room.People.Count > 0)
                    {
                        foreach (CharData pch in room.People)
                        {
                            if ((pch._flyLevel == ch._flyLevel || ch._flyLevel == pch._flyLevel + 1) && CharData.CanSee(ch, pch))
                            {
                                if (pch.IsNPC())
                                {
                                    if (pch._flyLevel == ch._flyLevel)
                                    {
                                        hasM = true;
                                    }
                                    else
                                    {
                                        hasM = false;
                                    }
                                }
                                else
                                {
                                    if (pch._flyLevel == ch._flyLevel)
                                    {
                                        hasP = true;
                                    }
                                    else
                                    {
                                        hasP = false;
                                    }
                                }
                            }
                        }
                    }
                    if (x == 0 && y == 0)
                    {
                        if (graphicalClient)
                        {
                            String chars = Map.GetMapCharacters(room, graphicalClient);
                            // Pick a diff character based on player's size.
                            text += chars[0];
                            int offset = 64;
                            if (ch._size >= Race.Size.large && ch._size <= Race.Size.gargantuan)
                            {
                                text += (char)(24 + offset); // Large humanoid
                            }
                            else if( ch._size <= Race.Size.small && ch._size >= Race.Size.tiny )
                            {
                                text += (char)(28 + offset); // Small humanoid
                            }
                            else
                            {
                                text += (char)(26 + offset); // Medium humanoid
                            }
                        }
                        else
                        {
                            text += "&+W@&n";
                        }
                    }
                    else if ((column + y) < 0 || (column + y) >= ch._inRoom.Area.Width ||
                             (row + x) < 0 || (row + x) >= ch._inRoom.Area.Height)
                    {
                        text += boundchar;
                    }
                    else if (!(room = Room.GetRoom((indexNumber + ((x * ch._inRoom.Area.Width) + y)))))
                    {
                        if (graphicalClient)
                        {
                            text += boundchar;
                        }
                        else
                        {
                            text += "&+L-&n";
                        }
                    }
                    else if (hasM)
                    {
                        if (graphicalClient)
                        {
                            text += "*";
                        }
                        else
                        {
                            text += Color.MOD_BLINK + "&+BM&n" + Color.MOD_CLEAR;
                        }
                    }
                    else if (hasP)
                    {
                        if (graphicalClient)
                        {
                            text += "!";
                        }
                        else
                        {
                            text += Color.MOD_BLINK + "&+WP&n" + Color.MOD_CLEAR;
                        }
                    }
                    else
                    {
                        text += Map.GetMapCharacters(room, graphicalClient);
                    }
                }
                text += lineEnding;
                /* Added these two lines to make it smaller string size in send_to_chr,
                * so that the pager isnt needed when large maps fill the screen
                */
                ch.SendText(text);
                text = String.Empty;
            }
            text += mapClose;

            ch.SendText(text);

            return;
        }

        /// <summary>
        /// Displays the main frag list, or a race/class specific fraglist.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Fraglist(CharData ch, string[] str)
        {
            string text = String.Empty;
            int count;
            int race = 0;
            int cclass = 0;
            bool racelist = false;
            bool classlist = false;

            if (ch == null)
            {
                Log.Error("Command.Fraglist: called with null ch.", 0);
                return;
            }

            if (str.Length == 0)
            {
                text += "&+BTotal Good Side Frags: &+W" + FraglistData.Fraglist.TotalFragsBySide[(int)Race.RacewarSide.good] +
                       "     &+BTotal Evil Side Frags: &+W" + FraglistData.Fraglist.TotalFragsBySide[(int)Race.RacewarSide.evil] + "&n\r\n\r\n";
                text += "    Top Frags                     Bottom Frags\r\n";
                for (count = 0; count < FraglistData.MAX_FRAG; ++count)
                {
                    text += "    &+y" + MUDString.PadStr(FraglistData.Fraglist.TopFrags[count].Name, 18) + "&n:&+Y " + MUDString.PadInt(FraglistData.Fraglist.TopFrags[count].Frags, 5) +
                           "&n     &+y" + MUDString.PadStr(FraglistData.Fraglist.BottomFrags[count].Name, 18) + "&n:&+Y " + MUDString.PadInt(FraglistData.Fraglist.BottomFrags[count].Frags, 5) + "&n\r\n";
                }
                text += "\r\n";
            }
            else if ("raceclass".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase) ||
                     "classrace".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
            {
                // Funky header formatting.  If any class has a name fewer than 4 characters the mud will crash -- Xangis
                text += "             ";
                for (count = 0; count < CharClass.ClassList.Length; ++count)
                {
                    text += " " + CharClass.ClassList[count].Name[0];
                }
                text += "\r\n             ";
                for (count = 0; count < CharClass.ClassList.Length; ++count)
                {
                    text += " " + CharClass.ClassList[count].Name[1];
                }
                text += "\r\n             ";
                for (count = 0; count < CharClass.ClassList.Length; ++count)
                {
                    text += " " + CharClass.ClassList[count].Name[2];
                }
                text += "\r\n             ";
                for (count = 0; count < CharClass.ClassList.Length; ++count)
                {
                    text += " " + CharClass.ClassList[count].Name[3];
                }
                text += "\r\n\r\n";

                // Actually display the info
                for (count = 0; count < Limits.MAX_PC_RACE; ++count)
                {
                    text += MUDString.PadStr(Race.RaceList[count].Name, 13);
                    int count2;
                    for (count2 = 0; count2 < CharClass.ClassList.Length; count2++)
                    {
                        text += " " + FraglistData.Fraglist.TotalFragsByRaceAndClass[count][count2];
                    }
                    text += "\r\n";
                }
                text += "\r\n";
            }
            else
            {
                // See if we've matched a race name.
                foreach( Race r in Race.RaceList )
                {
                    if( r.Number < Limits.MAX_PC_RACE && r.Name.StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
                    {
                        race = r.Number;
                        racelist = true;
                        break;
                    }
                }
                if (!racelist)
                {
                    for (int i = 0; i < CharClass.ClassList.Length; i++)
                    {
                        if (CharClass.ClassList[i].Name.StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
                        {
                            classlist = true;
                            cclass = i;
                            break;
                        }
                    }
                    if (!classlist)
                    {
                        ch.SendText("That's not a valid extra fraglist.  Try again.\r\n");
                        return;
                    }
                }
            }

            if (classlist)
            {
                text += "&+BTop frags for class " + CharClass.ClassList[cclass].WholistName + "&n\r\n\r\n";
                text += "    Top Frags                     Bottom Frags\r\n";
                for (count = 0; count < FraglistData.MAX_FRAG; ++count)
                {
                    text += "    &+y" + ((FraglistData.Fraglist.TopClassFrags[cclass][count].Frags == 0) ? "(null)           " : FraglistData.Fraglist.TopClassFrags[cclass][count].Name) +
                           "&n:&+Y " + FraglistData.Fraglist.TopClassFrags[cclass][count].Frags + "&n          &+y" +
                           ((FraglistData.Fraglist.BottomClassFrags[cclass][count].Frags == 0) ? "(null)           " : FraglistData.Fraglist.BottomClassFrags[cclass][count].Name) +
                           "&n:&+Y " + FraglistData.Fraglist.BottomClassFrags[cclass][count].Frags + "&n\r\n";
                }
                text += "\r\n";
            }
            else if (racelist)
            {
                text += String.Format("&+BTop frags for race {0}&n\r\n\r\n", Race.RaceList[race].ColorName);
                text += "    Top Frags                     Bottom Frags\r\n";
                for (count = 0; count < FraglistData.MAX_FRAG; ++count)
                {
                    text += "    &+y" +
                        ((FraglistData.Fraglist.TopRaceFrags[race][count].Frags == 0) ? "(null)           "
                          : FraglistData.Fraglist.TopRaceFrags[race][count].Name) +
                          "&n:&+Y " +
                          FraglistData.Fraglist.TopRaceFrags[race][count].Frags +
                          "&n          &+y" +
                              ((FraglistData.Fraglist.BottomRaceFrags[race][count].Frags == 0) ? "(null)           "
                              : FraglistData.Fraglist.BottomRaceFrags[race][count].Name) +
                              "&n:&+Y " + FraglistData.Fraglist.BottomRaceFrags[race][count].Frags +
                              "&n\r\n";
                }
                text += "\r\n";
            }

            ch.SendText(text);
        }

        public static void Initiate(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object ring;
            bool found = false;
            int count;

            if (str.Length == 0)
            {
                ch.SendText("Initiate whom?\r\n");
                return;
            }

            CharData victim = ch.GetCharRoom(str[0]);
            if (victim == null)
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (victim.IsNPC())
            {
                ch.SendText("Very funny trying to enroll an NPC.\r\n");
                return;
            }

            if (!ch.IsGuild() || ((PC)ch).ClanRank < Guild.Rank.officer)
            {
                ch.SendText("You don't have the power to do this.\r\n");
                return;
            }

            Guild clan = ((PC)ch).Clan;

            if (victim == ch)
            {
                return;
            }

            if (clan.Applicant != victim)
            {
                ch.SendText("They have not applied for membership to your guild.\r\n");
                return;
            }

            if (victim.IsGuild())
            {
                ch.SendText("They are already in another guild.\r\n");
                return;
            }

            if (clan.NumMembers >= 30)
            {
                ch.SendText("Your guild is full.\r\n");
                return;
            }

            for (count = 0; count < Limits.MAX_CLAN_MEMBERS; ++count)
            {
                if (clan.Members[count].Filled == false)
                {
                    found = true;
                    break;
                }
            }

            if (!found)
            {
                ch.SendText("There are no more openings in your organization.\r\n");
                return;
            }

            /*
            if( ((PC)victim).rank == Rank.exiled )
            {
            ch.SendText( "They are an exile and may not be guilded.\r\n" );
            victim.SendText( "You are an exile and cannot be accepted into a guild.\r\n" );
            return;
            }
            */

            if (victim._level < 25)
            {
                if (clan.TypeOfGuild == Guild.GuildType.clan && ch._level >= 15)
                {
                }
                else if (clan.TypeOfGuild == Guild.GuildType.guild && ch._level >= 20)
                {
                }
                else
                {
                    SocketConnection.Act("$N&n is too low level to be initiated.", ch, null, victim, SocketConnection.MessageTarget.character);
                    SocketConnection.Act("You are too weak to  be initiated to $t!", ch, clan.WhoName, victim, SocketConnection.MessageTarget.victim);
                    return;
                }
            }

            if (clan.TypeOfGuild == Guild.GuildType.guild && clan.ClassRestriction != victim._charClass)
                ch.SendText("You may only initiate those of your class into a guild.\r\n");

            ((PC)victim).Clan = clan;
            ((PC)victim).ClanRank = Guild.Rank.normal;
            clan.NumMembers++;

            SetTitle(victim, clan.RankNames[(int)((PC)victim).ClanRank]);

            clan.Members[count].Name = victim._name;
            clan.Members[count].Rank = ((PC)victim).ClanRank;
            clan.Members[count].JoinTime = Database.SystemData.CurrentTime;
            clan.Members[count].Filled = true;

            // Reset so others can apply
            clan.Applicant = null;

            if (Database.GetObjTemplate(clan.GuildRingIndexNumber))
            {
                ring = Database.CreateObject(Database.GetObjTemplate(clan.GuildRingIndexNumber), victim._level);

                if (ring)
                {
                    ring.ObjToChar(victim);
                }
            }

            string buf = String.Format("Log {0}: initiated {1} to {2}", ch._name, victim._name, clan.Name);
            Database.LogGuild(buf);

            buf = String.Format("'I {0} {1}, hereby declare you {2} a member of {3}!'\r\n" +
                      "Forever remember our motto: \"{4}\"\r\n",
                      ((PC)ch).ClanRank,
                      ch._name,
                      victim._name,
                      clan.WhoName,
                      clan.Motto);

            victim.SendText(buf);

            SocketConnection.Act("$N&n has been initiated to $t!", ch, clan.WhoName, victim, SocketConnection.MessageTarget.room);
            SocketConnection.Act("You have initiated $N&n to $t!", ch, clan.WhoName, victim, SocketConnection.MessageTarget.character);
            CharData.SavePlayer(victim);
            clan.Save();

            return;
        }

        /// <summary>
        /// Exile a player from a clan.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Exile(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (str.Length == 0)
            {
                ch.SendText("Exile whom?\r\n");
                return;
            }

            if (!ch.IsGuild()
                    || ((PC)ch).ClanRank != Guild.Rank.leader)
            {
                ch.SendText("You don't have the power to do this.\r\n");
                return;
            }

            Guild clan = ((PC)ch).Clan;

            CharData victim = ch.GetCharWorld(str[0]);
            if (!victim)
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (victim.IsNPC() || victim == ch || victim._level > ch._level)
                return;

            if (!ch.IsSameGuild(victim))
            {
                SocketConnection.Act("$N isn't even from $t.", ch, clan.WhoName, victim, SocketConnection.MessageTarget.character);
                return;
            }

            string text = String.Format("Log {0}: exiling {1} from {2}", ch._name, victim._name, ((PC)ch).Clan.Name);
            Database.LogGuild(text);

            // This function handles resetting member data
            victim.RemoveFromClan();
            ((PC)victim).ClanRank = Guild.Rank.exiled;

            text = String.Format(
                      "The grand Overlord of {0} {1} says:\r\n\r\n" +
                      "'Then so be done, you {2} shall be exiled from {3}!'\r\n" +
                      "You hear a thundering sound...\r\n\r\n" +
                      "A booming voice says: 'You have been exiled. Only the gods can allow you\r\n" +
                      "to join another clan, order or guild!'\r\n",
                      clan.WhoName,
                      clan.Overlord,
                      victim._name,
                      clan.WhoName);

            victim.SendText(text);

            SocketConnection.Act("You have exiled $N&n from $t!", ch, clan.WhoName, victim, SocketConnection.MessageTarget.character);
            CharData.SavePlayer(victim);
            clan.Save();
            return;
        }

        /// <summary>
        /// Kick a character out of a clan.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void KickOut(CharData ch, string[] str)
        {
            if( ch == null ) return;

            SocketConnection victimSocket;
            CharData wch;
            bool loggedIn = false;

            if (str.Length == 0)
            {
                ch.SendText("Kick out whom?\r\n");
                return;
            }

            if (!ch.IsGuild() || ((PC)ch).ClanRank < Guild.Rank.officer)
            {
                ch.SendText("You don't have the power to do this.\r\n");
                return;
            }

            Guild clan = ((PC)ch).Clan;

            CharData victim = null;
            foreach (CharData it in Database.CharList)
            {
                wch = it;
                if (wch.IsNPC())
                {
                    continue;
                }
                if (MUDString.NameContainedIn(str[0], wch._name))
                {
                    victim = wch;
                    loggedIn = true;
                    break;
                }
            }

            if (victim == null)
            {
                if (!(CharData.LoadPlayer((victimSocket = new SocketConnection()), str[0])))
                {
                    ch.SendText("Who's that?!\r\n");
                    return;
                }
                victim = victimSocket.Original ? victimSocket.Original : victimSocket.Character;
                loggedIn = false;
            }

            if (victim.IsNPC())
            {
                return;
            }

            if (victim == ch)
            {
                ch.SendText("Try &+rsociety secede&n!\r\n");
                return;
            }

            if (!ch.IsSameGuild(victim))
            {
                SocketConnection.Act("$N&n isn't even from $t.", ch, clan.WhoName, victim, SocketConnection.MessageTarget.character);
                return;
            }

            if (((PC)ch).ClanRank <= ((PC)victim).ClanRank)
            {
                ch.SendText("You don't have the power to do this.\r\n");
                return;
            }

            string text = String.Format("Log {0}: kicking {1} from {2}", ch._name, victim._name, ((PC)ch).Clan.Name);
            Database.LogGuild(text);

            // this _function _resets member data
            victim.RemoveFromClan();
            ((PC)victim).ClanRank = Guild.Rank.normal;

            if (loggedIn)
            {
                victim.SendText("&+RYou have been booted from your guild!&n\r\n");
            }

            ch.SendText("You have kicked them out of the guild.\r\n");

            CharData.SavePlayer(victim);
            clan.Save();

            /* Close rented chars pfile. */
            if (!loggedIn)
            {
                victimSocket = null;
            }

            return;
        }

        /// <summary>
        /// Promote target to another rank in the guild.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Promote(CharData ch, string[] str)
        {
            if( ch == null ) return;

            SocketConnection victimSocket;
            CharData wch;
            int count;
            bool loggedIn = false;

            if (ch.IsNPC())
            {
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Promote whom?\r\n");
                return;
            }

            if (!ch.IsGuild() || ((PC)ch).ClanRank != Guild.Rank.leader)
            {
                ch.SendText("You don't have the power to do this.  Only a leader may promote someone.\r\n");
                return;
            }

            Guild clan = ((PC)ch).Clan;

            CharData victim = null;
            foreach (CharData it in Database.CharList)
            {
                wch = it;
                if (wch.IsNPC())
                {
                    continue;
                }
                if (MUDString.NameContainedIn(str[0], wch._name))
                {
                    victim = wch;
                    loggedIn = true;
                    break;
                }
            }

            if (victim == null)
            {
                if (!(CharData.LoadPlayer((victimSocket = new SocketConnection()), str[0])))
                {
                    ch.SendText("Who's that?!\r\n");
                    return;
                }
                victim = victimSocket.Original ? victimSocket.Original : victimSocket.Character;
                loggedIn = false;
            }

            if (victim.IsNPC() || victim == ch)
            {
                return;
            }

            if (!ch.IsSameGuild(victim))
            {
                SocketConnection.Act("$N&n isn't even from $t.", ch, clan.WhoName, victim, SocketConnection.MessageTarget.character);
                return;
            }

            // This is technically where we would give them their guild badges.
            switch (((PC)victim).ClanRank)
            {
                default:
                    return;
                case Guild.Rank.normal:
                case Guild.Rank.officer:
                case Guild.Rank.senior:
                case Guild.Rank.deputy:
                    break;
                case Guild.Rank.leader:
                    ch.SendText("You may not promote that person any further.\r\n");
                    return;
            }

            ((PC)victim).ClanRank++;
            Guild.Rank newrank = ((PC)victim).ClanRank;

            SetTitle(victim, clan.RankNames[(int)((PC)victim).ClanRank]);

            string text = String.Format("Log {0}: promoting {1} to {2} in clan {3}",
                                       ch._name, victim._name, newrank, ((PC)ch).Clan.Name);
            Database.LogGuild(text);

            text = String.Format(
                      "The grand Overlord {0} says:\r\n\r\nI hereby promote you {1} to {2}!'\r\n",
                      ch._name, victim._name, newrank);

            if (loggedIn)
            {
                victim.SendText(text);
            }

            SocketConnection.Act("You have promoted $N&n to $t.",
                 ch, newrank.ToString(), victim, SocketConnection.MessageTarget.character);

            for (count = 0; count < Limits.MAX_CLAN_MEMBERS; ++count)
            {
                if (!MUDString.StringsNotEqual(clan.Members[count].Name, victim._name))
                {
                    clan.Members[count].Rank = ((PC)victim).ClanRank;
                }
            }

            CharData.SavePlayer(victim);
            clan.Save();

            /* Close rented chars pfile. */
            if (!loggedIn)
            {
                victimSocket = null;
            }

            return;
        }

        /// <summary>
        /// Demote: Decrease the rank of a clan member.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Demote(CharData ch, string[] str)
        {
            if( ch == null ) return;

            SocketConnection victimSocket;
            CharData wch;
            int count;
            bool loggedIn = false;

            if (str.Length == 0)
            {
                ch.SendText("Demote whom?\r\n");
                return;
            }

            if (!ch.IsGuild() || ((PC)ch).ClanRank != Guild.Rank.leader)
            {
                ch.SendText("You don't have the power to do this.\r\n");
                return;
            }

            Guild clan = ((PC)ch).Clan;

            CharData victim = null;
            foreach (CharData it in Database.CharList)
            {
                wch = it;
                if (wch.IsNPC())
                {
                    continue;
                }
                if (MUDString.NameContainedIn(str[0], wch._name))
                {
                    victim = wch;
                    loggedIn = true;
                    break;
                }
            }

            if (victim == null)
            {
                if (!(CharData.LoadPlayer((victimSocket = new SocketConnection()), str[0])))
                {
                    ch.SendText("Who's that?!\r\n");
                    return;
                }
                victim = victimSocket.Original ? victimSocket.Original : victimSocket.Character;
                loggedIn = false;
            }

            if (victim.IsNPC())
            {
                ch.SendText("NPCs are not guildable!\r\n");
                return;
            }

            if (!ch.IsSameGuild(victim))
            {
                SocketConnection.Act("$N&n isn't even from $t.", ch, clan.WhoName, victim, SocketConnection.MessageTarget.character);
                return;
            }

            switch (((PC)victim).ClanRank)
            {
                default:
                    ch.SendText("You can't demote this person.\r\n");
                    return;
                case Guild.Rank.normal:
                    ch.SendText("You can't demote them any further.\r\n");
                    return;
                case Guild.Rank.senior:
                case Guild.Rank.officer:
                case Guild.Rank.deputy:
                    break;
                case Guild.Rank.leader:
                    if (str.Length > 1 && MUDString.StringsNotEqual(str[1], "confirm"))
                    {
                        ch.SendText("Try 'demote leadername confirm' to demote a leader.\r\n");
                        return;
                    }
                    break;
            }

            ((PC)victim).ClanRank--;
            Guild.Rank newrank = ((PC)victim).ClanRank;

            SetTitle(victim, clan.RankNames[(int)((PC)victim).ClanRank]);

            string text = String.Format("Log {0}: demoting {1} to {2}",
                                       ch._name,
                                       victim._name,
                                       ((PC)ch).Clan.Name);
            Database.LogGuild(text);

            text = String.Format(
                      "The grand Overlord {0} says:\r\n\r\n" +
                      "'I hereby demote you {1} to {2}!!!'\r\n" +
                      "You should make more efforts to improve!",
                      ch._name, victim._name, newrank);

            if (loggedIn)
            {
                victim.SendText(text);
            }

            SocketConnection.Act("You have demoted $N to $t.",
                 ch, newrank.ToString(), victim, SocketConnection.MessageTarget.character);

            for (count = 0; count < Limits.MAX_CLAN_MEMBERS; ++count)
            {
                if (!MUDString.StringsNotEqual(clan.Members[count].Name, victim._name))
                {
                    clan.Members[count].Rank = ((PC)victim).ClanRank;
                }
            }

            CharData.SavePlayer(victim);
            clan.Save();

            /* Close rented chars pfile. */
            if (!loggedIn)
            {
                victimSocket = null;
            }
            return;
        }

        public static void GuildDonate(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Coins coin = new Coins();
            int coinage;
            bool success = false;

            if (ch.IsNPC())
            {
                return;
            }

            Guild guild = ((PC)ch).Clan;
            if (guild == null)
            {
                ch.SendText("You're not in a guild!\r\n");
                return;
            }
            if (str.Length == 0)
            {
                ch.SendText("Deposit what?\r\n");
                return;
            }
            if (!coin.FillFromString(str, ch))
            {
                ch.SendText("&+LSyntax: &+RSoc deposit &n&+r<&+L# of coins&n&+r> <&+Lcoin type&n&+r>&n\r\n");
                return;
            }
            if (coin.Copper == 0 && coin.Silver == 0 && coin.Gold == 0 && coin.Platinum == 0)
            {
                ch.SendText("You have none of that type of &+Lcoin&n yet.\r\n");
                return;
            }
            for (coinage = 0; coinage < 4; coinage++)
            {
                switch (coinage)
                {
                    case 0: //copper
                        if (coin.Copper < 0)
                        {
                            ch.SendText("You can't deposit a debt!\r\n");
                            continue;
                        }
                        if (coin.Copper > ch.GetCopper())
                        {
                            ch.SendText("You don't have that much &+ycopper&n coin!\r\n");
                            continue;
                        }
                        if (coin.Copper == 0)
                            continue;
                        ch.SpendCopper(coin.Copper);
                        success = true;
                        break;
                    case 1: //silver
                        if (coin.Silver < 0)
                        {
                            ch.SendText("You can't deposit a debt!\r\n");
                            continue;
                        }
                        if (coin.Silver > ch.GetSilver())
                        {
                            ch.SendText("You don't have that much &+wsilver&n coin!\r\n");
                            continue;
                        }
                        if (coin.Silver == 0)
                            continue;
                        ch.SpendSilver(coin.Silver);
                        success = true;
                        break;

                    case 2: //gold
                        if (coin.Gold < 0)
                        {
                            ch.SendText("You can't deposit a debt!\r\n");
                            continue;
                        }
                        if (coin.Gold > ch.GetGold())
                        {
                            ch.SendText("You don't have that much &+Ygold&n coin!\r\n");
                            continue;
                        }
                        if (coin.Gold == 0)
                            continue;
                        ch.SpendGold(coin.Gold);
                        success = true;
                        break;
                    case 3: //platinum
                        if (coin.Platinum < 0)
                        {
                            ch.SendText("You can't deposit a debt!\r\n");
                            continue;
                        }
                        if (coin.Platinum > ch.GetPlatinum())
                        {
                            ch.SendText("You don't have that much &+Wplatinum&n coin!\r\n");
                            continue;
                        }
                        if (coin.Platinum == 0)
                            continue;
                        ch.SpendPlatinum(coin.Platinum);
                        success = true;
                        break;
                } //end switch
            } //end for
            if (success)
            {
                int value = coin.Copper + 10 * coin.Silver + 100 * coin.Gold + 1000 * coin.Platinum;
                int count;
                for (count = 0; count < Limits.MAX_CLAN_MEMBERS; ++count)
                {
                    if (!MUDString.StringsNotEqual(guild.Members[count].Name, ch._name))
                    {
                        guild.Members[count].Fine -= value;
                        if (guild.Members[count].Fine < 0)
                        {
                            guild.Members[count].Fine = 0;
                            ch.SendText("&+WThank you for the donation!&n\r\n");
                        }
                        else
                        {
                            ch.SendText("You reduce your fine.\r\n");
                        }
                    }
                }
                guild.GuildBankAccount.Copper += coin.Copper;
                guild.GuildBankAccount.Silver += coin.Silver;
                guild.GuildBankAccount.Gold += coin.Gold;
                guild.GuildBankAccount.Platinum += coin.Platinum;
                guild.Save();
                CharData.SavePlayer(ch);
            }
            else
            {
                ch.SendText("&+LSyntax:  &+RSoc deposit &n&+r<&+L# of coins&n&+r> <&+Lcoin type&n&+r>&n\r\n");
            }
            return;
        }

        /*
        * "Leav" command is a trap to the "leave" command.
        */
        public static void Leav(CharData ch, string[] str)
        {
            if( ch == null ) return;

            ch.SendText("If you want to LEAVE, you have to spell it out.\r\n");

            return;
        }

        public static void Leave(CharData ch, string[] str)
        {
            if( ch == null ) return;
            if (!ch.IsGuild())
            {
                ch.SendText("You aren't a clansman.\r\n");
                return;
            }

            Guild clan = ((PC)ch).Clan;

            if (((PC)ch).ClanRank == Guild.Rank.leader)
            {
                ch.SendText("Huh? An Overlord shouldn't leave his clan!  Get demoted first!\r\n");
                return;
            }

            ch.RemoveFromClan();
            ((PC)ch).ClanRank = Guild.Rank.normal;

            SocketConnection.Act("You have left clan $t.", ch, clan.WhoName, ch, SocketConnection.MessageTarget.character);
            CharData.SavePlayer(ch);
            clan.Save();

            return;
        }

        public static void Clans(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int found = 0;

            string text = String.Format("&+BClan            Members Pkills   Pdeaths  Mkills   Mdeaths  Frags&n\r\n");
            string buf1 = text;

            foreach (Guild clan in Database.GuildList)
            {
                text = String.Format("{0} {1}    {2}    {3}    {4}    {5}    &+W{6}&n\r\n",
                          clan.Name,
                          clan.NumMembers,
                          clan.PlayerKills,
                          clan.PlayerDeaths,
                          clan.MonsterKills,
                          clan.MonsterDeaths,
                          clan.Frags);
                buf1 += text;
                found++;
            }

            if (found == 0)
                text = String.Format("There are no Guilds currently formed.\r\n");
            else
                text = String.Format("You see {0} clan{1} in the game.\r\n",
                          found,
                          found == 1 ? String.Empty : "s");

            buf1 += text;
            ch.SendText(buf1);
            return;
        }

        public static void ClanInfo(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int count;
            int members = 0;

            if (!ch.IsGuild())
            {
                ch.SendText("You aren't a clansman.\r\n");
                return;
            }

            Guild clan = ((PC)ch).Clan;

            string buf1 = String.Empty;

            string text = String.Format("{0}\r\n", clan.Name);
            buf1 += text;

            text = String.Format("Motto: \"{0}\"\r\n", clan.Motto);
            buf1 += text;

            buf1 += "-----------------------------------------------------------------------------\r\n";

            text = String.Format("{0}\r\n", clan.Description);
            buf1 += text;

            text = String.Format("Leader:  {0}\r\n", clan.Overlord);
            buf1 += text;

            text = String.Format("Members:   {0}\r\nFrags: &+W{1}&n\r\n", clan.NumMembers, clan.Frags);
            buf1 += text;

            text = String.Format("Vault:     {0} &+Wplatinum&n, {1} &+Ygold&n, {2} silver, {3} &+ycopper&n\r\n",
                      clan.GuildBankAccount.Platinum, clan.GuildBankAccount.Gold, clan.GuildBankAccount.Silver,
                      clan.GuildBankAccount.Copper);
            buf1 += text;

            text = String.Format("Current Applicant: {0}\r\n", clan.Applicant ? clan.Applicant._name : "(none)");
            buf1 += text;

            if (((PC)ch).ClanRank == Guild.Rank.leader)
            {
                text = String.Format("\r\n&+cRank Titles:&n\r\n  Exile: {0}\r\n  Parole: {1}\r\n  Normal: {2}\r\n  Senior: {3}\r\n" +
                          "  Officer: {4}\r\n  Deputy: {5}\r\n  Leader: {6}\r\n",
                          clan.RankNames[(int)Guild.Rank.exiled],
                          clan.RankNames[(int)Guild.Rank.parole],
                          clan.RankNames[(int)Guild.Rank.normal],
                          clan.RankNames[(int)Guild.Rank.senior],
                          clan.RankNames[(int)Guild.Rank.officer],
                          clan.RankNames[(int)Guild.Rank.deputy],
                          clan.RankNames[(int)Guild.Rank.leader]);
                buf1 += text;
            }

            text = String.Format("\r\nMember            Rank  Fine:\r\n");
            buf1 += text;

            for (count = 0; count < Limits.MAX_CLAN_MEMBERS; ++count)
            {
                if (clan.Members[count].Filled)
                {
                    members++;
                    text = String.Format("{0}) &+r{1}&n{2} {3} {4}&+yc&n\r\n",
                              members,
                              (ch.GetCharWorld(clan.Members[count].Name) ? 'o' : ' '),
                              MUDString.PadStr(clan.Members[count].Name, 15),
                              clan.RankNames[(int)clan.Members[count].Rank],
                              MUDString.PadInt(clan.Members[count].Fine, 8));
                    buf1 += text;
                }
            }

            if (clan.Ostracized.Length > 0)
            {
                text = String.Format("Ostracized: {0}\r\n", clan.Ostracized);
                buf1 += text;
            }

            ch.SendText(buf1);
            return;
        }

        public static void SetGuildVariable(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (str.Length == 0)
            {
                ch.SendText("Syntax: setclan <clan> <sedit>                     \r\n");
                ch.SendText("or:     setclan <clan> <field>            <value>  \r\n");
                ch.SendText("or:     setclan <clan> <string>           <value>  \r\n");
                ch.SendText("or:     setclan <clan> overlord <player>           \r\n");
                ch.SendText("\r\nField being one of:                            \r\n");
                ch.SendText(" mkills mdeaths pkills pdeaths illegalpk type      \r\n");
                ch.SendText(" members                                           \r\n");
                ch.SendText(" recall donation cclass score                      \r\n");
                ch.SendText(" obj1 obj2 obj3                                    \r\n");
                ch.SendText("String being one of:                               \r\n");
                ch.SendText(" name whoname filename motto ostra                 \r\n");
                ch.SendText("Sedit being one of:                                \r\n");
                ch.SendText(" desc                                              \r\n");
                return;
            }

            Guild guild = Guild.GetClan(str[0]);
            if (guild == null)
            {
                ch.SendText("No such clan.\r\n");
                return;
            }

            if (str.Length < 2)
            {
                ch.SendText("What do you actually want to set?\r\n");
                return;
            }

            if (str.Length < 3)
            {
                ch.SendText("What do you want to set that value to?\r\n");
            }

            if (!MUDString.StringsNotEqual(str[1], "overlord") || !MUDString.StringsNotEqual(str[1], "leader"))
            {
                guild.Overlord = str[2];
                ch.SendText("Done.\r\n");
                guild.Save();
                return;
            }
            if (!MUDString.StringsNotEqual(str[1], "members"))
            {
                Int32.TryParse(str[2], out guild.NumMembers);
                ch.SendText("Done.\r\n");
                guild.Save();
                return;
            }
            if (!MUDString.StringsNotEqual(str[1], "mkills"))
            {
                Int32.TryParse(str[2], out guild.MonsterKills);
                ch.SendText("Done.\r\n");
                guild.Save();
                return;
            }
            if (!MUDString.StringsNotEqual(str[1], "mdeaths"))
            {
                Int32.TryParse(str[2], out guild.MonsterDeaths);
                ch.SendText("Done.\r\n");
                guild.Save();
                return;
            }
            if (!MUDString.StringsNotEqual(str[1], "pkills"))
            {
                Int32.TryParse(str[2], out guild.PlayerKills);
                ch.SendText("Done.\r\n");
                guild.Save();
                return;
            }
            if (!MUDString.StringsNotEqual(str[1], "pdeaths"))
            {
                Int32.TryParse(str[2], out guild.PlayerDeaths);
                ch.SendText("Done.\r\n");
                guild.Save();
                return;
            }
            if (!MUDString.StringsNotEqual(str[1], "illegalpk"))
            {
                Int32.TryParse(str[2], out guild.IllegalJusticeKills);
                ch.SendText("Done.\r\n");
                guild.Save();
                return;
            }
            if (!MUDString.StringsNotEqual(str[1], "recall"))
            {
                Int32.TryParse(str[2], out guild.RecallRoom);
                ch.SendText("Done.\r\n");
                guild.Save();
                return;
            }
            if (!MUDString.StringsNotEqual(str[1], "donation"))
            {
                Int32.TryParse(str[2], out guild.GuildChest);
                ch.SendText("Done.\r\n");
                guild.Save();
                return;
            }
            if (!MUDString.StringsNotEqual(str[1], "obj1"))
            {
                Int32.TryParse(str[2], out guild.GuildRingIndexNumber);
                ch.SendText("Done.\r\n");
                guild.Save();
                return;
            }
            if (!MUDString.StringsNotEqual(str[1], "obj2"))
            {
                Int32.TryParse(str[2], out guild.GuildShieldIndexNumber);
                ch.SendText("Done.\r\n");
                guild.Save();
                return;
            }
            if (!MUDString.StringsNotEqual(str[1], "obj3"))
            {
                Int32.TryParse(str[2], out guild.GuildWeaponIndexNumber);
                ch.SendText("Done.\r\n");
                guild.Save();
                return;
            }
            if (!MUDString.StringsNotEqual(str[1], "type"))
            {
                try
                {
                    guild.TypeOfGuild = (Guild.GuildType)Enum.Parse(typeof(Guild.GuildType), str[1], false);
                    ch.SendText("Done.\r\n");
                    guild.Save();
                }
                catch (Exception)
                {
                    ch.SendText("Unknown clan type.\r\nValid types are clan, order, and guild.\r\n");
                    return;
                }
            }
            if (!MUDString.StringsNotEqual(str[1], "cclass"))
            {
                int num;
                Int32.TryParse(str[2], out num);
                if (num < CharClass.ClassList.Length)
                {
                    guild.ClassRestriction = CharClass.ClassList[num];
                    ch.SendText("Done.\r\n");
                    guild.Save();
                }
                else
                {
                    ch.SendText("Failed, bad class.\r\n");
                }
                return;
            }
            if (!MUDString.StringsNotEqual(str[1], "score"))
            {
                Double.TryParse(str[2], out guild.Score);
                ch.SendText("Done.\r\n");
                guild.Save();
                return;
            }
            if (!MUDString.StringsNotEqual(str[1], "name"))
            {
                guild.Name = str[2];
                ch.SendText("Done.\r\n");
                guild.Save();
                return;
            }
            if (!MUDString.StringsNotEqual(str[1], "ostra"))
            {
                guild.Ostracized = str[2];
                ch.SendText("Done.\r\n");
                guild.Save();
                return;
            }
            if (!MUDString.StringsNotEqual(str[1], "whoname"))
            {
                guild.WhoName = str[2];
                ch.SendText("Done.\r\n");
                guild.Save();
                return;
            }
            if (!MUDString.StringsNotEqual(str[1], "filename"))
            {
                guild.Filename = str[2];
                ch.SendText("Done.\r\n");
                guild.Save();
                Guild.SaveGuildList();
                return;
            }
            if (!MUDString.StringsNotEqual(str[1], "motto"))
            {
                guild.Motto = str[2];
                ch.SendText("Done.\r\n");
                guild.Save();
                return;
            }
            if (!MUDString.StringsNotEqual(str[1], "desc"))
            {
                ((PC)ch).Editing = SocketConnection.EditState.clan_description;
                MUDString.StringAppend(ch, ref guild.Description);
                guild.Save();
                return;
            }

            return;
        }

        public static void StatGuild(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Guild clan;

            if (str.Length == 0)
            {
                int found = 0;
                string text;

                ch.SendText("Syntax: stat clan <clan>\r\n\r\n");
                string buf1 = String.Format("Clan           Overlord          Keyword\r\n");

                foreach (Guild it in Database.GuildList)
                {
                    clan = it;
                    text = String.Format("{0}  {1}  {2}\r\n",
                              clan.WhoName,
                              clan.Overlord,
                              clan.Name);
                    buf1 += text;
                    found++;
                }

                if (found == 0)
                {
                    text = String.Format("There are no Clans/Guilds/Orders currently formed.\r\n");
                }
                else
                {
                    text = String.Format("You see {0} clan{1} in the game.\r\n",
                              found,
                              found == 1 ? String.Empty : "s");
                }
                buf1 += text;
                ch.SendText(buf1);
                return;
            }

            clan = Guild.GetClan(str[0]);
            if (clan == null)
            {
                ch.SendText("No such guild.\r\n");
                return;
            }

            ch.SendText(String.Format("&+cWhoName :&n {0}.\r\n",
                            clan.WhoName));
            ch.SendText(String.Format("&+cName    :&n {0}.\r\n",
                            clan.Name));
            ch.SendText(String.Format("&+cType    :&n {0}.\r\n",
                            clan.TypeOfGuild));
            ch.SendText(String.Format("&+cFilename:&n {0}\r\n&+cMotto   :&n \"{1}\".\r\n",
                            clan.Filename,
                            clan.Motto));
            ch.SendText(String.Format("&+cId      :&n {0}.\r\n", clan.ID));
            ch.SendText(String.Format("&+cDescription:&n \r\n{0}\r\n&+cOverlord :&n {1}.\r\n",
                            clan.Description,
                            clan.Overlord));
            ch.SendText(String.Format("&+cMembers:  &n {0}  &+cClass:   &n {1}\r\n",
                            MUDString.PadInt(clan.NumMembers, 5),
                            MUDString.PadInt((int)clan.ClassRestriction.ClassNumber, 5)));
            ch.SendText(String.Format("&+cMKills:   &n {0}  &+cMDeaths: &n {1}\r\n",
                            MUDString.PadInt(clan.MonsterKills, 5),
                            MUDString.PadInt(clan.MonsterDeaths, 5)));
            ch.SendText(String.Format("&+cPKills:   &n {0}  &+cPDeaths: &n {1}\r\n",
                            MUDString.PadInt(clan.PlayerKills, 5),
                            MUDString.PadInt(clan.PlayerDeaths, 5)));
            ch.SendText(String.Format("&+cFrags:    &n {0}  &+cScore:   &n {1}\r\n",
                            MUDString.PadInt(clan.Frags, 5),
                            clan.Score));
            ch.SendText(String.Format("&+cObj1:     &n {0}  &+cObj2:    &n {1}  &+cObj3:&n {2}\r\n",
                            MUDString.PadInt(clan.GuildRingIndexNumber, 5),
                            MUDString.PadInt(clan.GuildShieldIndexNumber, 5),
                            MUDString.PadInt(clan.GuildWeaponIndexNumber, 5)));
            ch.SendText(String.Format("&+cRecall:   &n {0}  &+cDonation:&n% {1}n\r",
                            MUDString.PadInt(clan.RecallRoom, 5), MUDString.PadInt(clan.GuildChest, 5)));
            ch.SendText(String.Format("&+cBank Account: &n{0} &+Wplatinum&n, {1} &+Ygold&n, {2} silver, {3} &+ycopper&n\r\n",
                            clan.GuildBankAccount.Platinum, clan.GuildBankAccount.Gold,
                            clan.GuildBankAccount.Silver, clan.GuildBankAccount.Copper));
            return;
        }

        public static void MakeGuild(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();
            string whoName = String.Empty;
            int count;

            if (!realChar.Authorized("makeclan"))
            {
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Syntax: makeclan <clan _name>\r\n");
                return;
            }

            if (whoName.Length > 13)
            {
                whoName = whoName.Substring(0, 13);
            }

            string filename = String.Format("{0}.clan", whoName);

            Guild clan = new Guild();
            Database.GuildList.Add(clan);

            clan.Filename = filename;
            clan.WhoName = whoName;
            clan.Name = str[0];
            clan.Motto = String.Empty;
            clan.Description = String.Empty;
            clan.Overlord = String.Empty;
            clan.NumMembers = 0;
            clan.RecallRoom = 3001;
            clan.GuildChest = 0;
            clan.ClassRestriction = CharClass.ClassList[0];
            clan.MonsterKills = 0;
            clan.MonsterDeaths = 0;
            clan.PlayerKills = 0;
            clan.PlayerDeaths = 0;
            clan.IllegalJusticeKills = 0;
            clan.Score = 0.0;
            clan.TypeOfGuild = Guild.GuildType.clan; // Defaults at clan
            clan.GuildRingIndexNumber = 0;
            clan.GuildShieldIndexNumber = 0;
            clan.GuildWeaponIndexNumber = 0;
            clan.RankNames[(int)Guild.Rank.exiled] = "Exile of";
            clan.RankNames[(int)Guild.Rank.parole] = "Parole of ";
            clan.RankNames[(int)Guild.Rank.normal] = "Member of ";
            clan.RankNames[(int)Guild.Rank.senior] = "Senior of";
            clan.RankNames[(int)Guild.Rank.officer] = "Officer of";
            clan.RankNames[(int)Guild.Rank.deputy] = "Deputy of";
            clan.RankNames[(int)Guild.Rank.leader] = "Leader of";
            clan.ID = Guild.NextGuildID;
            Guild.NextGuildID++;

            for (count = 0; count < Limits.MAX_CLAN_MEMBERS; ++count)
                clan.Members[count] = new GuildMemberData();
            for (count = 0; count < Limits.MAX_CLAN_MEMBERS; ++count)
            {
                clan.Members[count].Name = String.Empty;
                clan.Members[count].Rank = 0;
                clan.Members[count].Fine = 0;
                clan.Members[count].JoinTime = new DateTime();
                clan.Members[count].Filled = false;
            }

            ch.SendText("Creation successful.  Now use the command\r\nset clan <clan_name> <variable> <value>\r\n" +
                          "to set values for the organization.\r\n\r\nParticularly, you will " +
                          "need to set:\r\nwhoname\r\nmotto\r\ndesc\r\noverlord\r\n" +
                          "\r\nAfter that, to set the leader, you must use:\r\nset_namename> clan <c_namename>\r\n" +
                          "and\r\nset m_nameme> rank <6>\r\n");

            clan.Save();
            Guild.SaveGuildList();

            return;
        }

        public static void Society(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (str.Length == 0)
            {
                CommandType.Interpret(ch, "claninfo");
                return;
            }

            if (str.Length < 2)
            {
                ch.SendText("Syntax: society <command> <value/name>\r\n");
                return;
            }

            if ("kickout".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
                KickOut(ch, new[] { str[1] } );
            else if ("enroll".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
                Initiate(ch, new [] { str[1] });
            else if ("exile".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
                Exile(ch, new [] { str[1] } );
            else if ("apply".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
                Apply(ch, new [] { str[1] } );
            else if ("secede".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
                Leave(ch, new [] { str[1] } );
            else if ("deposit".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
                GuildDonate(ch, new [] { str[1] } );
            else if ("demote".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
                Demote(ch, new [] { str[1] } );
            else if ("decline".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
                Decline(ch, new [] { str[1] } );
            else if ("promote".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
                Promote(ch, new [] { str[1] } );
            else if ("withdraw".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
                GuildWithdraw(ch, new [] { str[1] } );
            else if ("fine".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
                Fine(ch, new [] { str[1] } );
            else if ("title".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
                Title(ch, new [] { str[1] } );
            else if ("name".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
                Socname(ch, new [] { str[1] } );
            else if ("ostracize".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
                Ostracize(ch, new [] { str[1] } );
            else if ("hometown".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
                Hometown(ch, new [] { str[1] } );
            else if ("rank".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
            {
                ch.SendText("Use the promote and demote commands instead of the rank command.\r\n");
                return;
            }
            else
            {
                ch.SendText("That's not a valid Society command.\r\n");
                ch.SendText("Commands include: apply, deposit, demote, decline, promote, rank, title, name, and withdraw.\r\n");
                return;
            }

            return;
        }

        /// <summary>
        /// Shows commands currently available to an immortal.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void ImmortalHelp(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string buf1 = String.Empty;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("immhelp") || ch.IsNPC() || !ch.IsImmortal())
            {
                return;
            }

            int col = 0;

            foreach (CommandType cmd in CommandType.CommandTable)
            {
                if (cmd.MinLevel < Limits.LEVEL_HERO || !((PC)ch).ImmortalData.Authorized(cmd.Name))
                {
                    continue;
                }
                string text = String.Format("{0}", MUDString.PadStr(cmd.Name, 11));
                buf1 += text;
                if (++col % 7 == 0)
                    buf1 += "\r\n";
            }

            if (col % 7 != 0)
            {
                buf1 += "\r\n";
            }
            ch.SendText(buf1);
            return;
        }

        public static void AppearanceMessage(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("appearmsg") || ch.IsImmortal() )
                return;

            if (str.Length == 0)
            {
                ch.SendText("What do you want your appear message to say?\r\n");
            }

            if (!ch.IsNPC())
            {
                if (ch.StringTooLong(str[0]))
                {
                    return;
                }
                ((PC)ch).ImmortalData.AppearMessage = str[0];
                ch.SendText("Done.\r\n");
            }
            return;
        }

        public static void DisappearMessage(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("disappearmsg") || !ch.IsImmortal())
            {
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("You need to provide a message.\r\n");
                return;
            }

            if (!ch.IsNPC())
            {
                if (ch.StringTooLong(str[0]))
                {
                    return;
                }
                ((PC)ch).ImmortalData.DisappearMessage = str[0];
                ch.SendText("Done.\r\n");
            }
            return;
        }

        /// <summary>
        /// Deny a player access to the game.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Deny(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("deny"))
            {
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Deny whom?\r\n");
                return;
            }

            CharData victim = ch.GetCharWorld(str[0]);
            if (victim == null)
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (victim.IsNPC())
            {
                ch.SendText("Not on NPC's.\r\n");
                return;
            }

            if (victim.GetTrust() >= ch.GetTrust())
            {
                ch.SendText("You failed.\r\n");
                return;
            }

            victim.SetActBit(PC.PLAYER_DENY);
            victim.SendText("You are denied access!\r\n");
            ch.SendText("Done.\r\n");
            if (victim._level <= 1)
            {
                CommandType.Interpret(victim, "quit");
            }
            return;
        }

        /// <summary>
        /// Disconnect a character from the game.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Disconnect(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();
            SocketConnection socket;

            if (!realChar.Authorized("disconnect"))
            {
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Disconnect whom?\r\n");
                return;
            }

            CharData victim = ch.GetCharWorld(str[0]);
            if (!victim)
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (!victim._socket)
            {
                SocketConnection.Act("$N doesn't have a descriptor.", ch, null, victim, SocketConnection.MessageTarget.character);
                return;
            }

            foreach (SocketConnection it in Database.SocketList)
            {
                socket = it;

                if (socket == victim._socket)
                {
                    socket.CloseSocket();
                    ch.SendText("Done.\r\n");
                    return;
                }
            }

            Log.Error("Disconnect: desc not found.", 0);
            ch.SendText("Descriptor not found!\r\n");
            return;
        }

        public static void Pardon(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();
            string arg1 = String.Empty;
            string arg2 = String.Empty;

            if (!realChar.Authorized("pardon"))
            {
                return;
            }

            if (String.IsNullOrEmpty(arg1) || String.IsNullOrEmpty(arg2))
            {
                ch.SendText("Syntax: pardon <character> <killer|thief>.\r\n");
                return;
            }

            CharData victim = ch.GetCharWorld(arg1);
            if (!victim)
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (victim.IsNPC())
            {
                ch.SendText("Not on NPC's.\r\n");
                return;
            }

            ch.SendText("Justice system not complete, pardon command inoperable.\r\n");

            return;
        }

        /// <summary>
        /// Immortal command to echo content to the whole MUD.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Echo(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("echo"))
            {
                return;
            }

            if (str.Length == 0 || String.IsNullOrEmpty(str[0]))
            {
                ch.SendText("Echo what?\r\n");
                return;
            }

            string colorCode = String.Empty;
            if (!ch.IsNPC() && ((PC)ch).ImmortalData != null)
                colorCode = ((PC)ch).ImmortalData.ImmortalColor;

            string content = colorCode + String.Join(" ", str) + "&n\r\n";

            SocketConnection.SendToAllChar(content);

            return;
        }

        public static void RoomEcho(CharData ch, string[] str)
        {
            if( ch == null ) return;

            SocketConnection socket;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("Recho"))
            {
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("RoomEcho what?\r\n");
                return;
            }

            foreach (SocketConnection it in Database.SocketList)
            {
                socket = it;

                if (socket._connectionState == SocketConnection.ConnectionState.playing
                        && socket.Character._inRoom == ch._inRoom)
                {
                    string text = String.Join(" ", str, 1, (str.Length - 1));
                    socket.Character.SendText(text);
                    socket.Character.SendText("\r\n");
                }
            }

            return;
        }

        /// <summary>
        /// Teleports a character from one place to another.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Transfer(CharData ch, string[] str)
        {
            if( ch == null ) return;

            SocketConnection socket;
            Room location;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("transfer"))
            {
                return;
            }

            if (str.Length < 1 || String.IsNullOrEmpty(str[0]))
            {
                ch.SendText("Transfer whom (and where)?\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[0], "all"))
            {
                // Transfer them one by one.
                foreach (SocketConnection it in Database.SocketList)
                {
                    socket = it;

                    if (socket._connectionState == SocketConnection.ConnectionState.playing
                            && socket.Character != ch && socket.Character._inRoom
                            && CharData.CanSee(ch, socket.Character))
                    {
                        str[0] = socket.Character._name;
                        Transfer(ch, str);
                    }
                }
                return;
            }

            if (str.Length < 2 || String.IsNullOrEmpty(str[1]))
            {
                location = ch._inRoom;
            }
            else
            {
                location = Room.FindLocation(ch, str[1]);
                if (!location)
                {
                    ch.SendText("No such location.\r\n");
                    return;
                }

                if (location.IsPrivate())
                {
                    ch.SendText("That room is private right now.\r\n");
                    return;
                }
            }

            CharData victim = ch.GetCharWorld(str[0]);
            if (!victim)
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (!victim._inRoom)
            {
                ch.SendText("They are in limbo.\r\n");
                return;
            }

            if (victim._fighting)
            {
                Combat.StopFighting(victim, true);
            }
            SocketConnection.Act("$n disappears in a mushroom cloud.", victim, null, null, SocketConnection.MessageTarget.room);
            victim.RemoveFromRoom();
            victim.AddToRoom(location);

            SocketConnection.Act("$n arrives from a puff of smoke.", victim, null, null, SocketConnection.MessageTarget.room);
            if (ch != victim)
            {
                SocketConnection.Act("$n has transferred you.", ch, null, victim, SocketConnection.MessageTarget.victim);
            }
            CommandType.Interpret(victim, "look auto");

            ch.SendText("Done.\r\n");
        }

        public static void At(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("at"))
            {
                return;
            }

            if (str.Length < 2)
            {
                ch.SendText("At where what?\r\n");
                return;
            }

            Room location = Room.FindLocation(ch, str[0]);
            if (!location)
            {
                ch.SendText("No such location.\r\n");
                return;
            }

            if (location.IsPrivate())
            {
                ch.SendText("That room is private right now.\r\n");
                return;
            }

            Room original = ch._inRoom;
            ch.RemoveFromRoom();
            ch.AddToRoom(location);

            string text = String.Join(" ", str, 1, (str.Length - 1));
            CommandType.Interpret(ch, text);

            /*
            * See if 'ch' still exists before continuing!
            * Handles 'at XXXX quit' case.
            */
            foreach (CharData it in Database.CharList)
            {
                CharData wch = it;
                if (wch == ch)
                {
                    ch.RemoveFromRoom();
                    ch.AddToRoom(original);
                    break;
                }
            }

            return;
        }

        /// <summary>
        /// Teleport to another location.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Goto(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("goto") || !ch.IsImmortal())
            {
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Goto where?\r\n");
                return;
            }

            Room location = Room.FindLocation(ch, str[0]);
            if (!location)
            {
                ch.SendText("No such location.\r\n");
                return;
            }

            if (location.IsPrivate())
            {
                ch.SendText("That room is private right now.\r\n");
                return;
            }

            if (ch._fighting)
            {
                Combat.StopFighting(ch, true);
            }
            if (!ch.HasActBit(PC.PLAYER_WIZINVIS))
            {
                if (!ch.IsNPC() && ((PC)ch).ImmortalData.DisappearMessage.Length > 0)
                {
                    SocketConnection.Act("$T", ch, null, ((PC)ch).ImmortalData.DisappearMessage, SocketConnection.MessageTarget.room);
                }
                else
                {
                    SocketConnection.Act("$n disappears in a puff of smoke.", ch, null, null, SocketConnection.MessageTarget.room);
                }
            }

            ch.RemoveFromRoom();
            ch.AddToRoom(location);

            if (!ch.HasActBit(PC.PLAYER_WIZINVIS))
            {
                if (!ch.IsNPC() && ((PC)ch).ImmortalData.AppearMessage.Length > 0)
                {
                    SocketConnection.Act("$T", ch, null, ((PC)ch).ImmortalData.AppearMessage, SocketConnection.MessageTarget.room);
                }
                else
                {
                    SocketConnection.Act("$n appears in a swirling mist", ch, null, null, SocketConnection.MessageTarget.room);
                }
            }

            CommandType.Interpret(ch, "look auto");
            return;
        }

        /// <summary>
        /// Show detailed statistics about a game entity.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Stat(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("stat"))
            {
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Try statting a MOBILE, OBJECT, ROOM, SKILL, SPELL, AREA, CLAN,\r\n");
                ch.SendText("CLASS, MEMDATA, SHOP, QUEST, CASTLIST, TRAPS, HUNT, HATE,\r\n");
                ch.SendText("CRIME, VEHICLE, MONK, RACE, SCREENS, or FEAR\r\n");
                return;
            }

            if (str.Length < 1)
            {
                ch.SendText("You need to provide more information than that.\r\n");
                return;
            }

            string tmp = String.Join(" ", str, 1, (str.Length - 1));
            String[] arguments = tmp.Split(' ');

            if (!MUDString.IsPrefixOf(str[0], "mobile"))
                StatMobile(ch, arguments );
            else if (!MUDString.IsPrefixOf(str[0], "object"))
                StatObject(ch,  arguments );
            else if (!MUDString.IsPrefixOf(str[0], "room"))
                StatRoom(ch,  arguments );
            else if (!MUDString.IsPrefixOf(str[0], "skill"))
                StatSkill(ch,  arguments );
            else if (!MUDString.IsPrefixOf(str[0], "spell"))
                StatSpell(ch,  arguments );
            else if (!MUDString.IsPrefixOf(str[0], "area"))
                StatArea(ch,  arguments );
            else if (!MUDString.IsPrefixOf(str[0], "zone"))
                StatArea(ch,  arguments );
            else if (!MUDString.IsPrefixOf(str[0], "clan"))
                StatGuild(ch,  arguments );
            else if (!MUDString.IsPrefixOf(str[0], "class"))
                StatClass(ch,  arguments );
            else if (!MUDString.IsPrefixOf(str[0], "quest"))
                StatQuest(ch,  arguments );
            else if (!MUDString.IsPrefixOf(str[0], "memdata"))
                StatMemdata(ch,  arguments );
            else if (!MUDString.IsPrefixOf(str[0], "shop"))
                StatShop(ch,  arguments );
            else if (!MUDString.IsPrefixOf(str[0], "desc"))
                ShowSockets(ch,  arguments );
            else if (!MUDString.IsPrefixOf(str[0], "castlist"))
                StatCastList(ch,  arguments );
            else if (!MUDString.IsPrefixOf(str[0], "traps"))
                StatTraps(ch,  arguments );
            else if (!MUDString.IsPrefixOf(str[0], "hunt"))
                StatHunt(ch,  arguments );
            else if (!MUDString.IsPrefixOf(str[0], "hate"))
                StatHate(ch,  arguments );
            else if (!MUDString.IsPrefixOf(str[0], "screens"))
                ch.SendText(Screen.GetStatus());
            // Not supported yet.
            //else if( !MUDString.str_prefix( arg1, "crime" ) )
            //    Commandstatcrime( ch, argument );
            else if (!MUDString.IsPrefixOf(str[0], "vehicle"))
                StatVehicle(ch,  arguments );
            else if (!MUDString.IsPrefixOf(str[0], "fear"))
                StatFear(ch,  arguments );
            else if (!MUDString.IsPrefixOf(str[0], "monk"))
                Monkstat(ch,  arguments );
            else if (!MUDString.IsPrefixOf(str[0], "group"))
                Gstat(ch,  arguments );
            else if (!MUDString.IsPrefixOf(str[0], "race"))
                StatRace(ch,  arguments );
            else
            {
                ch.SendText("Try statting a MOBILE, OBJECT, ROOM, SKILL, SPELL, AREA, CLAN,\r\n");
                ch.SendText("CLASS, MEMDATA, SHOP, QUEST, CASTLIST, TRAPS, HUNT, HATE,\r\n");
                ch.SendText("CRIME, VEHICLE, MONK, RACE, SCREENS, or FEAR\r\n");
            }

            return;
        }

        public static void StatCastList(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string text = String.Format("{0} total in the casting list.\r\n", Database.CastList.Count);
            ch.SendText(text);
        }

        // This function written purely for future debugging purposes
        // It shows the CharList in exactly the order that the game runs through
        // it.
        public static void Charlist(CharData ch, string[] str)
        {
            if (ch == null)
            {
                return;
            }
            int count = 0;
            foreach (CharData wch in Database.CharList)
            {
                ++count;
                string text = String.Format("{0}: {1}\r\n", count, wch._name);
                ch.SendText(text);
            }

            return;
        }

        public static void StatHunt(CharData ch, string[] str)
        {
            if (ch == null)
            {
                return;
            }

            string text;
            string buf1 = String.Empty;
            int count = 0;

            foreach (CharData wch in Database.CharList)
            {
                if (!wch.IsNPC() || !wch._hunting)
                {
                    continue;
                }
                ++count;
                if (count < 100)
                {
                    text = String.Format("{0}: {1}&n is hunting {2}&n.\r\n", count,
                              wch.ShowNameTo(ch, true), ch.ShowNameTo(wch, false));
                    buf1 += text;
                }
            }
            text = String.Format("Found {0} total hunting mobs.\r\n", count);
            buf1 += text;
            ch.SendText(buf1);
            return;
        }

        public static void StatHate(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string text;
            string buf1 = String.Empty;
            int count = 0;

            foreach (CharData wch in Database.CharList)
            {
                if (!wch.IsNPC() || wch._hating.Count == 0)
                {
                    continue;
                }
                foreach (EnemyData hhf in wch._hating)
                {
                    if (count >= 100)
                    {
                        break;
                    }
                    ++count;
                    text = String.Format("{0}: {1}&n is hating {2}&n.\r\n", count,
                              wch.ShowNameTo(ch, true), hhf.Who.ShowNameTo(wch, false));
                    buf1 += text;
                }
            }
            text = String.Format("Found {0} total hating mobs.\r\n", count);
            buf1 += text;
            ch.SendText(buf1);
            return;
        }

        public static void StatFear(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string text;
            string buf1 = String.Empty;
            int count = 0;

            foreach (CharData wch in Database.CharList)
            {
                if (!wch.IsNPC() || !wch._fearing)
                {
                    continue;
                }
                ++count;
                if (count < 100)
                {
                    text = String.Format("{0}: {1}&n is fearing {2}&n.\r\n", count,
                              wch.ShowNameTo(ch, true), ch.ShowNameTo(wch, false));
                    buf1 += text;
                }
            }
            text = String.Format("Found {0} total fearing mobs.\r\n", count);
            buf1 += text;
            ch.SendText(buf1);
            return;
        }

        public static void StatTraps(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string text;
            int count = 0;

            foreach (Object obj in Database.ObjectList)
            {
                if (obj.Trap == null)
                {
                    continue;
                }
                ++count;
                if (count < 100)
                {
                    text = String.Format("{0}: {1} trig,{2} dmg,{3} charges,{4} lvl,{5} percent\r\n", obj.ObjIndexData.IndexNumber,
                              obj.Trap.Trigger, obj.Trap.Damage, obj.Trap.Charges,
                              obj.Trap.Level, obj.Trap.Percent);
                    ch.SendText(text);
                }
            }
            text = String.Format("There are {0} total traps in the game.\r\n", count);
            ch.SendText(text);
            return;
        }

        public static void Find(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("lookup"))
            {
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Try finding up a MOBILE, OBJECT, or ROOM.\r\n");
                return;
            }

            if (str.Length < 2)
            {
                ch.SendText("Yes, but which one do you want to find?\r\n");
                return;
            }

            String tmpStr = String.Join(" ", str, 1, str.Length - 1);
            String[] newArg = tmpStr.Split(' ');

            if (!MUDString.IsPrefixOf(str[0], "mobile"))
                FindMobile(ch, newArg );
            else if (!MUDString.IsPrefixOf(str[0], "object"))
                FindObject(ch,newArg );
            else if (!MUDString.IsPrefixOf(str[0], "room"))
                FindRoom(ch, newArg );
            else
                ch.SendText("Try looking up a MOBILE, OBJECT, or ROOM.\r\n");

            return;
        }

        /// <summary>
        /// Immortal command to find a player or object.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Where(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("where"))
                return;

            if (str.Length == 0)
            {
                ch.SendText("Try where-ing a MOBILE, CHAR, or OBJECT, or WHERE ALL for all players.\r\n");
                return;
            }

            if (str.Length < 2)
            {
                ch.SendText("Yes, but which one are you looking for?\r\n");
                return;
            }

            if (!MUDString.IsPrefixOf(str[0], "mobile"))
                MobWhere(ch, new[] { str[1] } );
            else if (!MUDString.StringsNotEqual(str[0], "char"))
                WherePlayer(ch, new[] { str[1] });
            else if (!MUDString.IsPrefixOf(str[0], "object"))
                ObjectWhere(ch, new[] { str[1] });
            else if (!MUDString.IsPrefixOf(str[0], "all"))
                CommandType.Interpret(ch, "pwhere all");
            else
                ch.SendText("Try where-ing a MOBILE, CHAR, or OBJECT, or WHERE ALL for all players.\r\n");

            return;
        }

        public static void Set(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("setbit"))
            {
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("&+cTry setting an OBJECT, MOBILE, ROOM, SKILL, SPELL, MONKSKILL, RACE, CLASS, or CLAN.\r\n");
                return;
            }

            if (str.Length < 2)
            {
                ch.SendText("That's not really enough to go on.\r\n");
                return;
            }

            // This sucks.  We need a better way to take element 1 and higher from a string array.
            string tmp = String.Join(" ", str, 1, (str.Length - 1));
            String[] cmd = tmp.Split(' ');

            if (!MUDString.IsPrefixOf(str[0], "object"))
                SetObject(ch, cmd);
            else if (!MUDString.IsPrefixOf(str[0], "mobile"))
                SetMob(ch, cmd);
            else if (!MUDString.IsPrefixOf(str[0], "room"))
                SetRoom(ch, cmd);
            else if (!MUDString.IsPrefixOf(str[0], "skill"))
                SetSkill(ch, cmd);
            else if (!MUDString.IsPrefixOf(str[0], "language"))
                SetLanguage(ch, cmd);
            else if (!MUDString.IsPrefixOf(str[0], "spell"))
                SetSpell(ch, cmd);
            else if (!MUDString.IsPrefixOf(str[0], "monkskill"))
                SetMonkSkill(ch, cmd);
            else if ("race".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
                SetRace(ch, cmd);
            else if ("class".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
                SetClass(ch, cmd);
            else if (!MUDString.IsPrefixOf(str[0], "clan") || !MUDString.IsPrefixOf(str[0], "guild"))
                SetGuildVariable(ch, cmd);
            else
                ch.SendText("Try setting an OBJECT, MOBILE, ROOM, SKILL, LANGUAGE, SPELL, MONKSKILL, RACE, CLASS, or CLAN.\r\n");

            return;
        }

        public static void Load(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("load"))
            {
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Try loading a MOBILE or OBJECT.\r\n");
                return;
            }

            if (str.Length < 2)
            {
                ch.SendText("You need to be a bit more specific.\r\n");
                return;
            }

            if (!MUDString.IsPrefixOf(str[0], "mobile"))
                LoadMobile(ch, new [] { str[1] } );
            else if (!MUDString.IsPrefixOf(str[0], "object"))
                LoadObject(ch, new [] { str[1] } );
            else
                ch.SendText("Try loading a MOBILE or OBJECT.\r\n");

            return;
        }

        public static void StatArea(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Room room;
            Object obj;
            Exit exit;
            int count;

            ch.GetChar();

            Area area = ch._inRoom.Area;

            if (area == null)
            {
                Log.Error("Stat: char not in a valid area.", 0);
                ch.SendText("You are not in a valid area!");
                return;
            }

            string text = String.Format("Name:     '{0}'.\r\n", area.Name);
            ch.SendText(text);

            text = String.Format("Range:    {0}-{1}  Author:   {2}.\r\n",
                      MUDString.PadInt(area.MinRecommendedLevel, 2),
                      MUDString.PadInt(area.MaxRecommendedLevel, 2),
                      area.Author);
            ch.SendText(text);

            text = String.Format("File:     {0}.\r\n", area.Filename);
            ch.SendText(text);

            if (area.ClanId > 0)
            {
                text = String.Format("Clan Id:  {0}.\r\n", area.ClanId);
                ch.SendText(text);
            }

            text = String.Format("Age (sec):[{0}]  Players: [{1}]  Security: [{2}]\r\n",
                      MUDString.PadInt(area.AgeInSeconds, 5), MUDString.PadInt(area.NumPlayers, 5),
                      MUDString.PadInt(area.Security, 5));
            ch.SendText(text);

            text = String.Format("Indexes:  {0} - {1}\r\n",
                      area.LowIndexNumber, area.HighIndexNumber);
            ch.SendText(text);

            text = String.Format("Rooms:    {0} - {1} Objs: {2} - {3} Mobs: {4} - {5}\r\n",
                      area.LowRoomIndexNumber, area.HighRoomIndexNumber, area.LowObjIndexNumber,
                      area.HighObjIndexNumber, area.LowMobIndexNumber, area.HighMobIndexNumber);
            ch.SendText(text);

            text = String.Format("Recall:   [{0}] '{1}'.&n\r\n", MUDString.PadInt(area.Recall, 5),
                      Room.GetRoom(area.Recall) ? Room.GetRoom(area.Recall).Title : "none");
            ch.SendText(text);

            text = String.Format("Flags:    {0} ({1})    Reset Mode: {1}\r\n",
                      BitvectorFlagType.AreaString(area), area.AreaFlags[0], area.AreaResetMode);
            ch.SendText(text);

            text = String.Format("Reset:    {0}\r\n", area.ResetMessage);
            ch.SendText(text);

            text = String.Format("Reset lifespan: {0} minutes      Time since Reset: {1} seconds.\r\n",
                      area.MinutesBetweenResets, area.AgeInSeconds);
            ch.SendText(text);

            text = String.Format("Builders: {0}\r\n", area.Builders);
            ch.SendText(text);

            if (area.JusticeType != 0)
                ch.SendText("This area is controlled by justice.\r\n");

            if (area.DefenderTemplateNumber != 0)
                text = String.Format("Defender IndexNumber: {0}  Number Spawned During Invasion: {1}\r\n", area.DefenderTemplateNumber, area.DefendersPerSquad);
            ch.SendText(text);

            text = String.Format("Judge Room: {0}  Jail Room: {1}  Barracks: {2}  Defenders Dispatched: {3}/{4} ({5} squads)\r\n",
                      area.JudgeRoom, area.JailRoom, area.BarracksRoom, area.NumDefendersDispatched,
                      (area.DefendersPerSquad * 5), area.DefenderSquads);
            ch.SendText(text);

            /* This code checks for exits from zone and bad exits. */
            int lower = area.LowRoomIndexNumber;
            int upper = area.HighRoomIndexNumber;
            for (count = lower; count <= upper; ++count)
            {
                if ((room = Room.GetRoom(count)))
                {
                    int door = 0;
                    for (door = 0; door < Limits.MAX_DIRECTION; door++)
                    {
                        if ((exit = room.ExitData[door]))
                        {
                            int vn = exit.TargetRoom ? exit.TargetRoom.IndexNumber : -1;
                            if (vn == -1)
                            {
                                // Bad exit
                                text = String.Format("Exit {0} in room {1} leads to nothing.\r\n",
                                          Exit.DirectionName[door].ToUpper(),
                                          room.IndexNumber != 0 ? room.IndexNumber : -1);
                                ch.SendText(text);
                            }
                            else
                            {
                                // Check to see outta zone
                                if (vn < lower || vn > upper)
                                {
                                    text = String.Format("Exit {0} in room {1} leads to zone {2}&n.\r\n",
                                              Exit.DirectionName[door].ToUpper(), room.IndexNumber,
                                              exit.TargetRoom.Area.Name);
                                    ch.SendText(text);
                                }
                            }
                        }
                    }
                }
            }

            /* Adding check through objects to check for portals. */
            lower = area.LowObjIndexNumber;
            upper = area.HighObjIndexNumber;
            for (count = lower; count <= upper; ++count)
            {
                if ((obj = Object.GetFirstObjectOfTemplateType(Database.GetObjTemplate(count))))
                {
                    if (obj.ItemType == ObjTemplate.ObjectType.portal &&
                            (room = Room.GetRoom(obj.Values[0])))
                    {
                        if (obj.Values[0] < area.LowRoomIndexNumber ||
                                obj.Values[0] > area.HighRoomIndexNumber)
                        {   /* Display portal destn. room etc. */
                            if (obj.InRoom == null)
                            {
                                if (obj.ObjIndexData)
                                {
                                    Log.Error("Commandastat: Object {0} is portal w/out a room",
                                        obj.ObjIndexData.IndexNumber);
                                    continue;
                                }
                                Log.Error("Commandastat: Object is portal w/out a room", 0);
                                continue;
                            }
                            if (room.Area == null)
                            {
                                Log.Error("Commandastat: Room {0} is not in any area!", room.IndexNumber);
                                continue;
                            }
                            text = String.Format("Portal {0}&n in room {1}&n({2}) leads to zone {3}&n.\r\n",
                                      obj.Name, obj.InRoom.Title, obj.InRoom.IndexNumber, room.Area.Name);
                            ch.SendText(text);
                        }
                    }
                }
            }
            return;
        }

        public static void StatQuest(CharData ch, string[] str)
        {
            if( ch == null ) return;

            QuestTemplate quest;
            string text;

            if (ch._level < Limits.LEVEL_GREATER_GOD)
            {
                ch.SendText("You are too low level to stat quests.\r\n");
                return;
            }

            if (QuestTemplate.QuestList.Count < 1)
            {
                ch.SendText("No quests to stat.\r\n");
                return;
            }

            if (str.Length == 0)
            {
                foreach (QuestTemplate it in QuestTemplate.QuestList)
                {
                    quest = it;
                    text = String.Format("Quest for mob {0} has {1} and {2}", quest.IndexNumber,
                              (quest.Quests.Count > 0) ? "quest data" : "no quest data",
                              (quest.Messages.Count > 0) ? "message data\r\n" : "no message data\r\n");
                    ch.SendText(text);
                }
            }
            else if (!MUDString.IsNumber(str[0]))
            {
                ch.SendText("That's not a number.\r\n");
                return;
            }
            else
            {
                int number = 0;
                Int32.TryParse(str[0], out number);
                if (number < 1)
                {
                    ch.SendText("That's not a valid number.\r\n");
                    return;
                }
                foreach (QuestTemplate it in QuestTemplate.QuestList)
                {
                    quest = it;
                    if (quest.IndexNumber != number)
                    {
                        continue;
                    }
                    text = String.Format("Quest for mob {0}:\r\n", quest.IndexNumber);
                    ch.SendText(text);
                    foreach (TalkData talk in quest.Messages)
                    {
                        text = String.Format("Keywords: {0}\r\nMessage:\r\n{1}\r\n",
                                  talk.Keywords, talk.Message);
                        ch.SendText(text);
                    }
                    foreach (QuestData quests in quest.Quests)
                    {
                        ch.SendText("Subquest data:\r\n  Give items to mob:\r\n");
                        foreach (QuestItem item in quests.Receive)
                        {
                            text = String.Format("  Type: {0}  Number:  {1}  Complete: {2}\r\n",
                                      item.Type, item.Value, item.Completed);
                            ch.SendText(text);
                        }
                        ch.SendText("  Give items to player:\r\n");
                        foreach (QuestItem item in quests.Give)
                        {
                            text = String.Format("  Type: {0}  Number:  {1}  Complete: {2}\r\n",
                                      item.Type, item.Value, item.Completed);
                            ch.SendText(text);
                        }
                        text = String.Format("  Completion message: \r\n{0}&n\r\n  Disappearance message: {1}&n\r\n",
                                  quests.Complete, quests.Disappear);
                        ch.SendText(text);
                    }
                }
            }
            return;
        }

        public static void StatMemdata(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch.IsNPC())
                return;

            if (((PC)ch).Memorized.Count > 0)
            {
                foreach (MemorizeData mem in ((PC)ch).Memorized)
                {
                    string text = String.Format("Name: {1}. Memtime: {2} pulses.\r\n  Full Memtime: {3} pulses.  Circle: {4}.  Memmed: {5}.\r\n",
                                                mem.Name,
                                                mem.Memtime,
                                                mem.FullMemtime,
                                                mem.Circle,
                                                mem.Memmed);
                    ch.SendText(text);
                }
            }
            else
            {
                ch.SendText("You have no associated memorization data.\r\n");
            }

            return;
        }

        /// <summary>
        /// Immortal command to get statistics about a room.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void StatRoom(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string text = String.Empty;
            int door;

            // Get the room supplied in the argument, or the current room if no argument supplied.
            Room location = ch._inRoom;
            if (str.Length > 0 && !String.IsNullOrEmpty(str[0]))
            {
                location = Room.FindLocation(ch, str[0]);
            }
            if (!location)
            {
                ch.SendText("No such location.\r\n");
                return;
            }

            if (ch._inRoom != location && location.IsPrivate())
            {
                ch.SendText("That room is private right now.\r\n");
                return;
            }

            text += "Name: '" + location.Title + "&N'.\r\n" +
                   "Zone: '" + location.Area.Name + "&n'.\r\n";

            text += "IndexNumber: " + location.IndexNumber + ".  Light: " + location.Light + ".  Sector: " +
                  location.TerrainType.ToString() + " (" + (int)location.TerrainType + ").\r\n";

            text += "Temp Room flags: " + location.CurrentRoomFlags[0] + " " + location.CurrentRoomFlags[1] +
                  ": " + Room.RoomString(location) + ".\r\n";

            text += "Orig Room flags: " + location.BaseRoomFlags[0] + " " + location.BaseRoomFlags[1] +
                  ".\r\nDescription:\r\n" + location.Description + "\r\n&n";

            if (location.ExtraDescriptions != null)
            {
                text += "Extra description keywords: '";
                bool first = true;
                foreach (ExtendedDescription ed in location.ExtraDescriptions)
                {
                    if (!first)
                    {
                        text += " ";
                    }
                    text += ed.Keyword;
                    first = false;
                }
                text += "'.\r\n";
            }

            text += "Characters:";
            /* Yes, we are reusing the variable rch.  */
            foreach (CharData irch in location.People)
            {
                if (CharData.CanSee(ch, irch))
                {
                    text += " ";
                    if (!ch.IsNPC())
                    {
                        text += irch._name;
                    }
                    else
                    {
                        text += irch._shortDescription;
                    }
                }
            }

            text += ".\r\nObjects:   ";
            foreach (Object obj in location.Contents)
            {
                text += " ";
                text += obj.ShortDescription;
            }
            text += ".\r\n";

            for (door = 0; door < Limits.MAX_DIRECTION; door++)
            {
                Exit exit;

                if ((exit = location.ExitData[door]))
                {
                    string buf4;
                    buf4 = String.Format(
                              "{0}:  To: {1}.  Key: {2}.  Exit flags: {3}.\r\n",
                              MUDString.PadStr(Exit.DirectionName[door].ToUpper(), 5),
                              exit.TargetRoom ? exit.TargetRoom.IndexNumber : 0,
                              exit.Key,
                              exit.ExitFlags.ToString());
                    text += buf4;
                    text += "Keyword: '" + exit.Keyword + "'.  Description: " +
                              (exit.Description.Length > 0 ? exit.Description : "(none).\r\n");
                }
            }

            /* Added display of percent chance of falling. */
            if (location.ExitData[Exit.DIRECTION_DOWN])
            {
                text += "Percent chance of falling: " + location.FallChance + ".\r\n";
            }
            text += "Extra Sector Info:    " + location.WorldmapTerrainType + ".\r\n";

            ch.SendText(text);
            return;
        }

        /// <summary>
        /// Immortal command to get the stats of an object.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void StatObject(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object obj = null;
            int value;
            string buf1 = String.Empty;

            ch.GetChar();

            if (str.Length == 0)
            {
                ch.SendText("Ostat what?\r\n");
                return;
            }

            Int32.TryParse(str[0], out value);
            // Non numeric, search for object as a string.
            if (value == 0 && !(obj = Object.GetObjectInWorld(ch, str[0])))
            {
                ch.SendText("Nothing like '" + str[0] +  "' in this universe.\r\n");
                return;
            }
            // Nothing found or numeric supplied, look for index number.
            if (!obj)
            {
                ObjTemplate pObjIndex;
                if (!(pObjIndex = Database.GetObjTemplate(value)))
                {
                    ch.SendText("Invalid object index number.\r\n");
                    return;
                }
                if (!(obj = Object.GetFirstObjectOfTemplateType(pObjIndex)))
                {
                    ch.SendText("None of those in game.\r\n");
                    return;
                }
            }

            string text = String.Format("Name: {0}.\r\n", obj.Name);
            buf1 += text;

            text = String.Format("IndexNumber: {0}.  Type: {1} - {2}.\r\n",
                      obj.ObjIndexData.IndexNumber, obj.ItemType, StringConversion.ItemTypeString(obj));
            buf1 += text;

            text = String.Format("Short description: {0}&n.\r\nLong description: {1}&n\r\n",
                      obj.ShortDescription, obj.FullDescription);
            buf1 += text;

            text = String.Format("Wear bits: {0}.  Extra bits: {1} ({2} {3}).\r\n",
                      obj.WearFlags[0], Object.ItemString(obj), obj.ExtraFlags[0],
                      obj.ExtraFlags[1]);
            buf1 += text;

            buf1 += String.Format("Number: {0}/{1}.  Weight: {2}/{3}.  Size: {4}.  Volume: {5}.\r\n",
                      1, Object.GetObjectQuantity(obj),
                      obj.Weight, obj.GetWeight(),
                      obj.Size, obj.Volume);

            text = String.Format("Material Type: {0}. ({1}).  Craftsmanship: {2}.  Scarcity: {3}.\n",
                      obj.Material,
                      Material.Table[(int)obj.Material].ShortDescription,
                      obj.Craftsmanship, obj.ObjIndexData.Scarcity);
            buf1 += text;

            text = String.Format("Cost: {0}.  Timer: {1}.  Level: {2}.  Number Loaded: {3}.\r\n",
                      obj.Cost, obj.Timer, obj.Level, obj.ObjIndexData.QuantityLoaded);
            buf1 += text;

            /* Added wear_location in text, not int format. */
            text = String.Format(
                      "In room: {0}.  In object: {1}.  Carried by: {2}.  WearLoc: {3}.\r\n",
                      obj.InRoom ? obj.InRoom.IndexNumber : 0,
                      obj.InObject ? obj.InObject.ShortDescription : "(none)",
                      obj.CarriedBy ? obj.CarriedBy._name : "(none)",
                      obj.WearLocation); // Had to change this - V
            buf1 += text;

            /* Added all eight values. */
            text = String.Format("Values: {0} {1} {2} {3} {4} {5} {6} {7}.\r\n",
                      obj.Values[0], obj.Values[1], obj.Values[2],
                      obj.Values[3], obj.Values[4], obj.Values[5],
                      obj.Values[6], obj.Values[7]);
            buf1 += text;

            if (obj.ExtraDescription.Count > 0 || obj.ObjIndexData.ExtraDescriptions.Count > 0)
            {
                buf1 += "Extra description keywords: ";

                bool first = true;
                foreach (ExtendedDescription ed in obj.ExtraDescription)
                {
                    if (!first)
                    {
                        buf1 += " ";
                    }
                    buf1 += ed.Keyword;
                    first = false;
                }

                first = true;
                foreach (ExtendedDescription ed in obj.ObjIndexData.ExtraDescriptions)
                {
                    if (!first)
                    {
                        buf1 += " ";
                    }
                    buf1 += ed.Keyword;
                    first = false;
                }

                buf1 += ".\r\n";
            }

            foreach (Affect aff in obj.Affected)
            {
                foreach (AffectApplyType apply in aff.Modifiers)
                {
                    text = String.Format("Affects {0} by {1}.\r\n",
                              StringConversion.AffectApplyString(apply.Location), apply.Amount,
                              aff.AffectString(false));
                    buf1 += text;
                }
            }

            foreach (Affect aff in obj.ObjIndexData.Affected)
            {
                foreach (AffectApplyType apply in aff.Modifiers)
                {
                    text = String.Format("Template Affects {0} by {1}.\r\n",
                              StringConversion.AffectApplyString(apply.Location), apply.Amount,
                              aff.AffectString(false));
                    buf1 += text;
                }
            }

            /* Added display of object's condition. */
            /*  This will need to be modified from int to a char string, once
            a table exists for it.  */
            text = String.Format("Object is in {0} condition.\r\n", obj.Condition);
            buf1 += text;

            if (obj.UseFlags != null)
            {
                text = String.Format("Object UseFlags: {0} {1} ({2})\r\n", obj.UseFlags[0], obj.UseFlags[1], Object.UseFlagString(obj));
            }
            else
            {
                text = String.Format("Object has no UseFlags.\r\n");
            }
            buf1 += text;

            if (obj.SpecFun != null)
            {
                text = String.Format("Special function: {0}.\r\n",
                          StringConversion.ObjectSpecialString(obj.SpecFun));
                buf1 += text;
            }

            //if( obj.pIndexData.objprogs )
            //{
            //    buf = String.Format(  "Object has an objprog.\r\n" );
            //    buf1 += buf;
            //}

            /* Added display of affected_by array. */
            text = String.Format("Affected by: {0}.\r\n",
                      BitvectorFlagType.AffectString(obj.AffectedBy, false));
            buf1 += text;

            ch.SendText(buf1);
            return;
        }

        public static void StatShop(CharData ch, string[] str)
        {
            if( ch == null ) return;
            CharData keeper = null;

            foreach (CharData ikeeper in ch._inRoom.People)
            {
                if (ikeeper.IsNPC() && (ikeeper._mobIndexData.ShopData))
                {
                    keeper = ikeeper;
                    break;
                }
            }

            if (!keeper)
            {
                ch.SendText("There is no shop in this room.\r\n");
                return;
            }

            string text = String.Format("Keeper: {0}.  Name: {1}&n\r\n",
                                       keeper._mobIndexData.IndexNumber,
                                       keeper._shortDescription);

            string buf1 = String.Format("Profit Buy: {0}.  Profit Sell: {1}.\r\n",
                                        keeper._mobIndexData.ShopData.PercentBuy,
                                        keeper._mobIndexData.ShopData.PercentSell);
            text += buf1;

            buf1 = String.Format("Open Hour: {0}.   Close Hour: {1}.\r\n",
                      keeper._mobIndexData.ShopData.OpenHour,
                      keeper._mobIndexData.ShopData.CloseHour);
            text += buf1;

            text += "Types of item shop buys: ";
            foreach (int buytype in keeper._mobIndexData.ShopData.BuyTypes)
            {
                text += String.Format(" {0}", buytype);
            }
            text += ".\r\n";

            text += "Permanent items shop sells: \r\n";
            foreach (int itemforsale in keeper._mobIndexData.ShopData.ItemsForSale)
            {
                text += String.Format(" {0}.\r\n", itemforsale);
            }
            text += ".\r\n";

            text += "Temporary items shop is selling:\r\n";
            foreach (Object obj in keeper._carrying)
            {
                if (obj.WearLocation != ObjTemplate.WearLocation.none)
                    continue;
                buf1 = String.Format("{0} ({1}).\r\n",
                          obj.ShortDescription, obj.ObjIndexData.IndexNumber);
                text += buf1;
            }

            ch.SendText(text);
        }

        public static void Gstat(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;
            CharData gch;
            CharData leader;
            string text;
            string arg = String.Empty;
            string buf1;

            CharData realChar = ch.GetChar();

            if (arg.Length > 0)
            {
                victim = realChar.GetCharRoom(arg);
                if (!victim)
                {
                    victim = realChar.GetCharWorld(arg);
                }
                if (!victim)
                {
                    realChar.SendText("You can't find that person anywhere.\r\n");
                    return;
                }
                if (!victim._groupLeader)
                {
                    realChar.SendText("They aren't in a group.\r\n");
                    return;
                }
                leader = victim._groupLeader;
                buf1 = String.Format("&+G{0}'s group:&n\r\n", leader._name);
                for (gch = leader; gch; gch = gch._nextInGroup)
                {
                    text = String.Format("     &+G{0}&n\r\n", gch._name);
                    buf1 += text;
                }
                realChar.SendText(buf1);
                return;
            }
            buf1 = String.Empty;
            foreach (CharData it in Database.CharList)
            {
                victim = it;
                if (victim != victim._groupLeader)
                {
                    continue;
                }
                leader = victim._groupLeader;
                text = String.Format("&+G{0}'s group:&n\r\n", leader._name);
                buf1 += text;
                for (gch = leader; gch; gch = gch._nextInGroup)
                {
                    text = String.Format("     &+G{0}&n\r\n", gch._name);
                    buf1 += text;
                }
            }
            realChar.SendText(buf1);
            return;
        }

        /// <summary>
        /// Immortal command to display that stats of a mobile.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void StatMobile(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim = null;
            Object obj;
            int value;
            string buf1 = String.Empty;

            if (str.Length == 0)
            {
                ch.SendText("Stat which mobile?\r\n");
                return;
            }

            Int32.TryParse(str[0], out value);
            // If non-numeric, check based on name.
            if (value == 0 && !(victim = ch.GetCharWorld(str[0])))
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }
            // If numeric or name not found, check as a index number.
            if (!victim)
            {
                MobTemplate pMobIndex;
                if (!(pMobIndex = Database.GetMobTemplate(value)))
                {
                    ch.SendText("No mobile has that index number.\r\n");
                    return;
                }
                foreach (CharData it in Database.CharList)
                {
                    victim = it;
                    if (victim._mobIndexData == pMobIndex)
                    {
                        break;
                    }
                }
                if (!victim)
                {
                    ch.SendText("No mobile has that index number.\r\n");
                    return;
                }
            }

            string text = String.Format("Name: {0}.\r\n", victim._name);
            buf1 += text;

            text = String.Format("Race: {0} ({1})  Original Race: {2} ({3}).\r\n", Race.RaceList[victim.GetRace()].ColorName,
                      victim.GetRace(), Race.RaceList[victim.GetOrigRace()].ColorName, victim.GetOrigRace());
            buf1 += text;

            text = String.Format("Parts: {0}.\r\n",
                      StringConversion.PartsBitString(Race.RaceList[victim.GetRace()].BodyParts));
            buf1 += text;

            text = String.Format("IndexNumber: {0}.  Sex: {1}.  Room: {2}.  Load room: {3}.\r\n",
                      victim.IsNPC() ? victim._mobIndexData.IndexNumber : 0,
                      victim._sex,
                      !victim._inRoom ? 0 : victim._inRoom.IndexNumber,
                      victim._loadRoomIndexNumber);
            buf1 += text;

            text = String.Format("&+WBase Stats&n  Str: {0}.  Int: {1}.  Wis: {2}.  Dex: {3}.  Con: {4}.\r\n",
                      victim._permStrength,
                      victim._permIntelligence,
                      victim._permWisdom,
                      victim._permDexterity,
                      victim._permConstitution);
            buf1 += text;

            text = String.Format("            Agi: {0}.  Cha: {1}.  Pow: {2}.  Luk: {3}.\r\n",
                      victim._permAgility,
                      victim._permCharisma,
                      victim._permPower,
                      victim._permLuck);
            buf1 += text;

            text = String.Format("&+WActual Stats&n Str: {0}.  Int: {1}.  Wis: {2}.  Dex: {3}.  Con: {4}.\r\n",
                      victim.GetCurrStr(),
                      victim.GetCurrInt(),
                      victim.GetCurrWis(),
                      victim.GetCurrDex(),
                      victim.GetCurrCon());
            buf1 += text;

            text = String.Format("            Agi: {0}.  Cha: {1}.  Pow: {2}.  Luk: {3}.\r\n",
                      victim.GetCurrAgi(),
                      victim.GetCurrCha(),
                      victim.GetCurrPow(),
                      victim.GetCurrLuck());
            buf1 += text;


            text = String.Format("Hp: {0}/{1} ({2} base).  Mana: {3}/{4}.  Move: {5}/{6}.\r\n",
                      victim._hitpoints, victim.GetMaxHit(), victim._maxHitpoints,
                      victim._currentMana, victim._maxMana,
                      victim._currentMoves, victim._maxMoves);
            buf1 += text;

            text = String.Format(
                      "Lv: {0}.  Class: {1} ({2})&n.  Align: {3}.  AC: {4}.\r\n",
                      victim._level, victim._charClass.Name,
                      victim._charClass.WholistName,
                      victim._alignment, victim.GetAC());
            buf1 += text;

            /* show current and default size */
            text = String.Format("Current Size:  {0} ({1})  Default Size: {2} ({3})\r\n",
                      Race.SizeString(victim._size), victim._size,
                      Race.SizeString(Race.RaceList[victim.GetRace()].DefaultSize), Race.RaceList[victim.GetRace()].DefaultSize);
            buf1 += text;

            /* Added position in text. */
            text = String.Format("Pos: {0} ({1}).  Wimpy: {2}.  Exp: {3}/{4}.  Coins: {5}.\r\n",
                      Position.PositionString(victim._position),
                      victim._position,
                      victim._wimpy,
                      victim._experiencePoints, ExperienceTable.Table[victim._level].LevelExperience, victim.GetCash());
            buf1 += text;

            /* Always displays the Hit/Dam bonus for the char's primary weapon. */
            buf1 += "Primary Weapon: ";
            text = String.Format("Hitroll: {0}  Damroll: {1}.\r\n",
                      victim.GetHitroll(ObjTemplate.WearLocation.hand_one),
                      victim.GetDamroll(ObjTemplate.WearLocation.hand_one));
            buf1 += text;

            /* Changed location of the if statement. */
            /* If char has a weapon in second hand and has dual wield.. */
            if ((victim.IsNPC() || victim.HasSkill("dual wield"))
                    && ((obj = Object.GetEquipmentOnCharacter(victim, ObjTemplate.WearLocation.hand_two)) && (obj.ItemType ==
                            ObjTemplate.ObjectType.weapon)))
            {
                text = String.Format(" Second Weapon Hitroll: {0}  Damroll: {1}.\r\n",
                          victim.GetHitroll(ObjTemplate.WearLocation.hand_two),
                          victim.GetDamroll(ObjTemplate.WearLocation.hand_two));
                buf1 += text;
            }

            if (!victim.IsNPC())
            {
                text = String.Format("Currhome: {0}, Orighome: {1}, Lastrent: {2}\r\n",
                          ((PC)victim).CurrentHome, ((PC)victim).OriginalHome, ((PC)victim).LastRentLocation);
                buf1 += text;
                text = String.Format("Page Lines: {0}.\r\nLanguages learned:", ((PC)victim).PageLength);
                buf1 += text;
                int count;
                for (count = 0; count < Race.MAX_LANG; count++)
                {
                    if (((PC)ch).LanguageAptitude[count] > 0)
                    {
                        text = String.Format(" {0}={1}", Race.LanguageTable[count], ((PC)victim).LanguageAptitude[count]);
                        buf1 += text;
                    }
                }
                buf1 += "\r\n";
            }

            text = String.Format("Fighting: {0}.\r\n",
                      victim._fighting ? victim._fighting._name : "(none)");
            buf1 += text;

            if (!victim.IsNPC())
            {
                text = String.Format(
                          "Thirst: {0}.  Full: {1}.  Drunk: {2}.  Saving throws: {3} {4} {5} {6} {7}.\r\n",
                          ((PC)victim).Thirst,
                          ((PC)victim).Hunger,
                          ((PC)victim).Drunk,
                          victim._savingThrows[0],
                          victim._savingThrows[1],
                          victim._savingThrows[2],
                          victim._savingThrows[3],
                          victim._savingThrows[4]);
                buf1 += text;
                if (victim.IsGuild())
                {
                    text = String.Format(
                              "Clan: {0}.  Rank: {1}.\r\n",
                              ((PC)victim).Clan.Name,
                              ((PC)victim).ClanRank.ToString());
                    buf1 += text;
                }
            }
            else
            {
                text = String.Format(
                          "Saving throws: {0} {1} {2} {3} {4}.  Timer: {5}.\r\n",
                          victim._savingThrows[0],
                          victim._savingThrows[1],
                          victim._savingThrows[2],
                          victim._savingThrows[3],
                          victim._savingThrows[4],
                          victim._timer);
                buf1 += text;
            }

            text = String.Format("Carry number: {0}.  Carry weight: {1}.  Wait state: {2} ({3} seconds)\r\n",
                      victim._carryNumber, victim._carryWeight,
                      victim._wait, (victim._wait / Event.TICK_PER_SECOND));
            buf1 += text;

            if (!victim.IsNPC())
            {
                text = String.Format("Age: {0}.  Played: {1}.  Timer: {2}.\r\n",
                          victim.GetAge(),
                          victim._played,
                          victim._timer);
                buf1 += text;
            }

            text = String.Format("ActFlags: {0} ({1} {2}).\r\n",
                      PC.ActString(victim._affectedBy, false, victim.IsNPC()),
                      victim._actionFlags[0],
                      victim._actionFlags[1]);

            buf1 += text;

            text = String.Format("Riding:  {0}.  Rider:  {1}.\r\n",
                      victim._riding ? victim._riding._name : "(none)",
                      victim._rider ? victim._rider._name : "(none)");
            buf1 += text;

            text = String.Format("Master:  {0}.  Leader: {1}.\r\n",
                      victim._master ? victim._master._name : "(none)",
                      victim._groupLeader ? victim._groupLeader._name : "(none)");
            buf1 += text;

            text = String.Format("Hunting: {0}.  Hating: {1} targets.  Fearing: {2}.\r\n",
                      victim._hunting ? victim._hunting.Name : "(none)",
                      victim._hating.Count,
                      victim._fearing ? victim._fearing.Name : "(none)");
            buf1 += text;

            text = String.Format("Resistant: {0}.  Immune: {1}.\r\n",
                      StringConversion.DamageTypeString(victim._resistant),
                      StringConversion.DamageTypeString(victim._immune));
            buf1 += text;

            text = String.Format("Susceptible: {0}.  Vulnerable: {1}.\r\n",
                      StringConversion.DamageTypeString(victim._susceptible),
                      StringConversion.DamageTypeString(victim._vulnerable));
            buf1 += text;

            text = String.Format("Affected by: {0}.\r\n", BitvectorFlagType.AffectString(victim._affectedBy, false));
            buf1 += text;

            if (!victim.IsNPC())
            {
                text = String.Format("Security: {0}.\r\n", ((PC)victim).Security);
            }
            else
            {
                text = String.Format("Start Position: {0} ({1}).\r\n",
                          Position.PositionString(victim._mobIndexData.DefaultPosition),
                          victim._mobIndexData.DefaultPosition);
            }
            buf1 += text;

            text = String.Format("Short description: {0}&n.\r\nLong description: {1}&n\r\n",
                      victim._shortDescription, victim._fullDescription );
            buf1 += text;

            /* Displays mob specials */
            if (victim.IsNPC() && victim._specFun != null && victim._specFun.Count > 0)
            {
                text = String.Format("Mobile has special function {0}.\r\n", StringConversion.MobSpecialString(victim._specFun));
                buf1 += text;
            }
            if (victim.IsNPC() && victim._mobIndexData.DeathFun != null && victim._mobIndexData.DeathFun.Count > 0)
            {
                text = String.Format("Mobile has death function {0}.\r\n", StringConversion.MobSpecialString(victim._mobIndexData.DeathFun));
                buf1 += text;
            }

            //if( victim.IsNPC() && victim.pIndexData.mobprogs )
            //{
            //    buf = String.Format(  "Mobile has a mobprog.\r\n" );
            //    buf1 += buf;
            //}

            /* Displays skills/spells currently on victim. */
            foreach (Affect aff in victim._affected)
            {
                // note that with this code if an affect has both a skill
                // and spell affect, they will both show up as individual affects.
                if (aff.Type == Affect.AffectType.skill && !String.IsNullOrEmpty(aff.Value))
                {
                    foreach (AffectApplyType apply in aff.Modifiers)
                    {
                        text = String.Format(
                                  "Skill: '{0}' modifies {1} by {2} for {3} hours with bits {4}.\r\n",
                                  Skill.SkillList[aff.Value].Name,
                                  StringConversion.AffectApplyString(apply.Location),
                                  apply.Amount,
                                  aff.Duration,
                                  aff.AffectString(false));
                        buf1 += text;
                    }
                }
                if (aff.Type == Affect.AffectType.spell && !String.IsNullOrEmpty(aff.Value))
                {
                    foreach (AffectApplyType apply in aff.Modifiers)
                    {
                        text = String.Format(
                                  "Spell: '{0}' modifies {1} by {2} for {3} hours with bits {4}.\r\n",
                                  aff.Value,
                                  StringConversion.AffectApplyString(apply.Location),
                                  apply.Amount,
                                  aff.Duration,
                                  aff.AffectString(false));
                        buf1 += text;
                    }
                }
                if (aff.Type == Affect.AffectType.song && !String.IsNullOrEmpty(aff.Value))
                {
                    foreach (AffectApplyType apply in aff.Modifiers)
                    {
                        text = String.Format(
                                  "Song: '{0}' modifies {1} by {2} for {3} hours with bits {4}.\r\n",
                                  aff.Value,
                                  StringConversion.AffectApplyString(apply.Location),
                                  apply.Amount,
                                  aff.Duration,
                                  aff.AffectString(false));
                        buf1 += text;
                    }
                }
                if (aff.Value == null)
                {
                    foreach (AffectApplyType apply in aff.Modifiers)
                    {
                        text = String.Format(
                                  "Unknown: modifies {0} by {1} for {2} hours with bits {3}.\r\n",
                                  StringConversion.AffectApplyString(apply.Location),
                                  apply.Amount,
                                  aff.Duration,
                                  aff.AffectString(false));
                        buf1 += text;
                    }
                }
            }

            if (!victim.IsNPC())
            {
                /* ADD deaf in text, once table is written for it. */
                text = String.Format("Deaf to: {0}. ", victim._deaf);
                buf1 += text;
                /* Added trust level. */
                text = String.Format("Trust level: {0}.\r\n", victim._trustLevel);
                buf1 += text;
            }

            /* Added # mobs killed, and # times killed by a mob. */
            if (!victim.IsNPC())
            {
                text = String.Format("Mobs killed: {0}. Times killed by a mob: {1}.\r\n",
                          MUDString.PadInt(((PC)victim).MobKills, 4),
                          MUDString.PadInt(((PC)victim).MobDeaths, 4));
                buf1 += text;
            }

            /* Added # players killed, and # times killed by a player. */
            if (!victim.IsNPC())
            {
                text = String.Format("Players killed: {0}. Times killed by a player: {1}.\r\n",
                          MUDString.PadInt(((PC)victim).PlayerKills, 4),
                          MUDString.PadInt(((PC)victim).PlayerDeaths, 4));
                buf1 += text;
            }

            /* Added # frags and illegal pkills. */
            if (!victim.IsNPC())
            {
                text = String.Format("Frags: {0}.\r\n", ((PC)victim).Frags);
                buf1 += text;
            }

            /* Added list of follower */
            /* Made it check _targetType instead of imm */
            if (victim._followers != null && victim._followers.Count > 0)
            {
                buf1 += "Followers: ";
                foreach (CharData follower in victim._followers)
                {
                    text = String.Format("{0}&n", follower.ShowNameTo(victim, true));
                    buf1 += text;
                }
                buf1 += "\r\n";
            }

            ch.SendText(buf1);
            return;
        }

        /// <summary>
        /// Finds a room based on a query.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void FindRoom(CharData ch, string[] str)
        {
            if( ch == null ) return;

            ch.SendText("Not yet implemented. And this is a hard one.\r\n");
        }

        /// <summary>
        /// Immortal command to look up an object template.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void FindObject(CharData ch, string[] str)
        {
            if( ch == null ) return;

            ObjTemplate pObjIndex;
            string text;
            int indexNumber, bottom, top;
            ObjTemplate.ObjectType type = 0;
            Bitvector bvect = new Bitvector();
            int total = 0;
            Affect.Apply stat = Affect.Apply.none;

            ch.GetChar();

            if (str.Length < 2)
            {
                ch.SendText("Syntax: find o world <object>\r\n");
                ch.SendText("or:     find o area  <object>\r\n");
                ch.SendText("or:     find o bitvector   <bitvector name>\r\n");
                ch.SendText("or:     find o type  <type number>\r\n");
                ch.SendText("or:     find o stat  <stat name> (optional: area)\r\n");
                return;
            }
            if (MUDString.StringsNotEqual(str[0], "world") && MUDString.StringsNotEqual(str[0], "area") &&
                MUDString.StringsNotEqual(str[0], "bitvector") && MUDString.StringsNotEqual(str[0], "type") &&
                    MUDString.StringsNotEqual(str[0], "stat"))
            {
            }

            if (String.IsNullOrEmpty(str[1]))
            {
                ch.SendText("Find what object?\r\n");
                return;
            }

            bool fAll = !MUDString.StringsNotEqual(str[1], "all");
            bool found = false;
            Area area = ch._inRoom.Area;
            bool fBit = !MUDString.StringsNotEqual(str[0], "bit");
            bool fType = !MUDString.StringsNotEqual(str[0], "type");
            bool fArea = !MUDString.StringsNotEqual(str[0], "area");
            bool fArea2 = (str.Length > 2 && !MUDString.StringsNotEqual(str[2], "area"));
            if (fArea2)
            {
                fArea = true;
            }
            bool fStat = !MUDString.StringsNotEqual(str[0], "stat");

            if (fStat)
            {
                if (!MUDString.StringsNotEqual(str[1], "maxstr"))
                    stat = Affect.Apply.max_strength;
                else if (!MUDString.StringsNotEqual(str[1], "maxint"))
                    stat = Affect.Apply.max_intelligence;
                else if (!MUDString.StringsNotEqual(str[1], "maxwis"))
                    stat = Affect.Apply.max_wisdom;
                else if (!MUDString.StringsNotEqual(str[1], "maxdex"))
                    stat = Affect.Apply.max_dexterity;
                else if (!MUDString.StringsNotEqual(str[1], "maxagi"))
                    stat = Affect.Apply.max_agility;
                else if (!MUDString.StringsNotEqual(str[1], "maxcon"))
                    stat = Affect.Apply.max_constitution;
                else if (!MUDString.StringsNotEqual(str[1], "maxcha"))
                    stat = Affect.Apply.max_charisma;
                else if (!MUDString.StringsNotEqual(str[1], "maxpow"))
                    stat = Affect.Apply.max_power;
                else if (!MUDString.StringsNotEqual(str[1], "maxluck"))
                    stat = Affect.Apply.max_luck;
                else if (!MUDString.StringsNotEqual(str[1], "racestr"))
                    stat = Affect.Apply.race_strength;
                else if (!MUDString.StringsNotEqual(str[1], "raceint"))
                    stat = Affect.Apply.race_intelligence;
                else if (!MUDString.StringsNotEqual(str[1], "racewis"))
                    stat = Affect.Apply.race_wisdom;
                else if (!MUDString.StringsNotEqual(str[1], "racedex"))
                    stat = Affect.Apply.race_dexterity;
                else if (!MUDString.StringsNotEqual(str[1], "raceagi"))
                    stat = Affect.Apply.race_agility;
                else if (!MUDString.StringsNotEqual(str[1], "racecon"))
                    stat = Affect.Apply.race_constitution;
                else if (!MUDString.StringsNotEqual(str[1], "racecha"))
                    stat = Affect.Apply.race_charisma;
                else if (!MUDString.StringsNotEqual(str[1], "racepow"))
                    stat = Affect.Apply.race_power;
                else if (!MUDString.StringsNotEqual(str[1], "raceluck"))
                    stat = Affect.Apply.race_luck;
                else if (!MUDString.StringsNotEqual(str[1], "str"))
                    stat = Affect.Apply.strength;
                else if (!MUDString.StringsNotEqual(str[1], "int"))
                    stat = Affect.Apply.intelligence;
                else if (!MUDString.StringsNotEqual(str[1], "wis"))
                    stat = Affect.Apply.wisdom;
                else if (!MUDString.StringsNotEqual(str[1], "dex"))
                    stat = Affect.Apply.dexterity;
                else if (!MUDString.StringsNotEqual(str[1], "agi"))
                    stat = Affect.Apply.agility;
                else if (!MUDString.StringsNotEqual(str[1], "con"))
                    stat = Affect.Apply.constitution;
                else if (!MUDString.StringsNotEqual(str[1], "cha"))
                    stat = Affect.Apply.charisma;
                else if (!MUDString.StringsNotEqual(str[1], "pow"))
                    stat = Affect.Apply.power;
                else if (!MUDString.StringsNotEqual(str[1], "luck"))
                    stat = Affect.Apply.luck;
                else if (!MUDString.StringsNotEqual(str[1], "svpara"))
                    stat = Affect.Apply.save_paralysis;
                else if (!MUDString.StringsNotEqual(str[1], "svpoi"))
                    stat = Affect.Apply.save_poison;
                else if (!MUDString.StringsNotEqual(str[1], "svdis"))
                    stat = Affect.Apply.save_petrification;
                else if (!MUDString.StringsNotEqual(str[1], "svbreath"))
                    stat = Affect.Apply.save_breath;
                else if (!MUDString.StringsNotEqual(str[1], "svspell"))
                    stat = Affect.Apply.save_spell;
                else if (!MUDString.StringsNotEqual(str[1], "mana"))
                    stat = Affect.Apply.mana;
                else if (!MUDString.StringsNotEqual(str[1], "hitpoints"))
                    stat = Affect.Apply.hitpoints;
                else if (!MUDString.StringsNotEqual(str[1], "move"))
                    stat = Affect.Apply.move;
                else if (!MUDString.StringsNotEqual(str[1], "hitroll"))
                    stat = Affect.Apply.hitroll;
                else if (!MUDString.StringsNotEqual(str[1], "damroll"))
                    stat = Affect.Apply.damroll;
                else
                {
                    ch.SendText("Valid stats for a stat lookup are: str, int, wis, dex, agi, con, cha, pow, luck,\r\n" +
                                  "  maxstr, maxint, maxwis, maxdex, maxagi, maxcon, maxcha, maxpow, maxluck, svpara,\r\n" +
                                  "  svpoi, svdis, svbreath, svspell, mana, hitpoints, move, hitroll, damroll, bit.\r\n");
                    return;
                }
            }

            if (fBit)
            {
                int count;
                for (count = 0; BitvectorFlagType.ItemFlags[count].BitvectorData; ++count)
                {
                    if (!MUDString.StringsNotEqual(str[1], BitvectorFlagType.ItemFlags[count].Name))
                    {
                        bvect = BitvectorFlagType.ItemFlags[count].BitvectorData;
                        break;
                    }
                }
                if (bvect == null)
                {
                    ch.SendText("No such item flag.\r\n");
                    return;
                }
            }

            if (fType)
            {
                try
                {
                    type = (ObjTemplate.ObjectType)Enum.Parse(typeof(ObjTemplate.ObjectType), str[2], false);
                    text = String.Format("Looking for object type {0}:\r\n", type);
                    ch.SendText(text);
                }
                catch (Exception)
                {
                    ch.SendText("Invalid object type.");
                    return;
                }
            }

            if (fArea)
            {
                bottom = area.LowObjIndexNumber;
                top = area.HighObjIndexNumber + 1;
            }
            else
            {
                bottom = 0;
                top = Database.HighestObjIndexNumber;
            }

            for (indexNumber = bottom; indexNumber < top; indexNumber++)
            {
                if (total > 5000)
                {
                    ch.SendText("Greater than 5000 items found.  List truncated.\r\n");
                    break;
                }

                if (!(pObjIndex = Database.GetObjTemplate(indexNumber)))
                {
                    continue;
                }

                if (fArea && area != pObjIndex.Area)
                {
                    continue;
                }


                if (fBit)
                {
                    if (Macros.IsSet(pObjIndex.ExtraFlags[bvect.Group], bvect.Vector))
                    {
                        found = true;
                        text = String.Format("[{0}]:{1} of {2}: {3} &n({4}&+yc&n)\r\n",
                                 MUDString.PadInt(pObjIndex.IndexNumber, 5),
                                 MUDString.PadInt(pObjIndex.QuantityLoaded, 5),
                                 MUDString.PadInt(pObjIndex.MaxNumber, 5),
                                 pObjIndex.ShortDescription.ToUpper(),
                                 pObjIndex.Cost);
                        ch.SendText(text);
                        total++;
                    }
                }
                else if (fType)
                {
                    if (pObjIndex.ItemType == type)
                    {
                        found = true;
                        text = String.Format("[{0}]:{1} of {2}: {3} &n({4}&+yc&n)\r\n",
                                 MUDString.PadInt(pObjIndex.IndexNumber, 5),
                                 MUDString.PadInt(pObjIndex.QuantityLoaded, 5),
                                 MUDString.PadInt(pObjIndex.MaxNumber, 5),
                                 pObjIndex.ShortDescription.ToUpper(),
                                 pObjIndex.Cost);
                        ch.SendText(text);
                        total++;
                    }
                }
                else if (fStat)
                {
                    foreach (Affect paf in pObjIndex.Affected)
                    {
                        foreach (AffectApplyType apply in paf.Modifiers)
                        {
                            if (apply.Location == stat)
                            {
                                found = true;
                                text = String.Format("[{0}] {1}&n (modifier {2})\r\n",
                                    MUDString.PadInt(pObjIndex.IndexNumber, 5),
                                    pObjIndex.ShortDescription.ToUpper(),
                                    apply.Amount);
                                ch.SendText(text);
                                total++;
                                break;
                            }
                        }
                    }
                }
                else
                {
                    if (fAll || MUDString.NameContainedIn(str[1], pObjIndex.Name))
                    {
                        found = true;
                        text = String.Format("[{0}]:{1} of {2}: {3} &n({4}&+yc&n)\r\n",
                                 MUDString.PadInt(pObjIndex.IndexNumber, 5),
                                 MUDString.PadInt(pObjIndex.QuantityLoaded, 5),
                                 MUDString.PadInt(pObjIndex.MaxNumber, 5),
                                 pObjIndex.ShortDescription.ToUpper(),
                                 pObjIndex.Cost);
                        ch.SendText(text);
                        total++;
                    }
                }
            }

            if (!found)
            {
                ch.SendText("Nothing like that in this universe.\r\n");
                return;
            }

            return;

        }

        public static void MobWhere(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;
            string text;
            string buf1 = String.Empty;
            int indexNumber;

            ch.GetChar();

            Int32.TryParse(str[0], out indexNumber);

            if (str.Length == 0)
            {
                ch.SendText("Mwhere whom?\r\n");
                return;
            }

            int count = 0;
            foreach (CharData it in Database.CharList)
            {
                victim = it;
                if (victim.IsNPC()
                        && victim._inRoom
                        && (MUDString.NameContainedIn(str[0], victim._name)
                             || indexNumber == victim._mobIndexData.IndexNumber))
                {
                    ++count;
                    if (count < 150)
                    {
                        text = String.Format("[{0}] {1} [{2}] {3}\r\n",
                                  MUDString.PadInt(victim._mobIndexData.IndexNumber, 5),
                                  MUDString.PadStr(victim._shortDescription, 28),
                                  MUDString.PadInt(victim._inRoom.IndexNumber, 5),
                                  victim._inRoom.Title);
                        buf1 += text;
                    }
                }
            }

            if (count == 0)
            {
                SocketConnection.Act("You didn't find any $T.", ch, null, str[0], SocketConnection.MessageTarget.character);
                return;
            }
            text = String.Format("You found {0} results.  Displayed no more than the first 150.\r\n", count);
            buf1 += text;

            ch.SendText(buf1);
            return;
        }

        public static void Reboo(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("reboot"))
            {
                return;
            }

            ch.SendText("If you want to REBOOT, spell it out.\r\n");
            return;
        }

        public static void Reboot(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("reboot"))
            {
                return;
            }

            string text = String.Format("Reboot by {0}.", ch._name);
            CommandType.Interpret(ch, "echo " + text);
            SocketConnection.EndOfGame();
            Database.SystemData.GameIsDown = true;
            return;
        }

        public static void Shutdow(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("shutdown"))
            {
                return;
            }
            ch.SendText("If you want to SHUTDOWN, spell it out.\r\n");
            return;
        }

        public static void Shutdown(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("shutdown"))
            {
                return;
            }

            string text = "Shutdown by ";
            text += ch._name;
            Database.AppendFile(ch, FileLocation.ShutdownFile, text);
            text += ".\r\n";
            CommandType.Interpret(ch, "echo " + text);

            SocketConnection.EndOfGame();

            Database.SystemData.GameIsDown = true;
            return;
        }

        /// <summary>
        /// Spy on the input and output of a character.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Snoop(CharData ch, string[] str)
        {
            if( ch == null ) return;

            SocketConnection socket;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("snoop"))
            {
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Snoop whom?\r\n");
                return;
            }

            CharData victim = ch.GetCharWorld(str[0]);
            if (!victim)
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (!victim._socket)
            {
                ch.SendText("No descriptor to snoop.\r\n");
                return;
            }

            if (victim == ch)
            {
                ch.SendText("Cancelling all snoops.\r\n");
                foreach (SocketConnection it in Database.SocketList)
                {
                    socket = it;

                    if (socket.SnoopBy == ch._socket)
                    {
                        socket.SnoopBy = null;
                    }
                }
                return;
            }

            if (victim._socket.SnoopBy != null)
            {
                ch.SendText("Busy already.\r\n");
                return;
            }

            if (victim.GetTrust() >= ch.GetTrust() && MUDString.StringsNotEqual(ch._name, "Xangis"))
            {
                ch.SendText("You failed.\r\n");
                return;
            }

            if (ch._socket)
            {
                for (socket = ch._socket.SnoopBy; socket; socket = socket.SnoopBy)
                {
                    if (socket.Character == victim || socket.Original == victim)
                    {
                        ch.SendText("No snoop loops.\r\n");
                        return;
                    }
                }
            }

            victim._socket.SnoopBy = ch._socket;
            ch.SendText("Done.\r\n");
            string text = String.Format("{0} is snooping {1}", ch._name, victim._name);
            ImmortalChat.SendImmortalChat(ch, ImmortalChat.IMMTALK_SNOOPS, realChar.GetTrust(), text);
            return;
        }

        /// <summary>
        /// Lets an immortal take control of (possess) a mob.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Switch(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("switch"))
            {
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Switch into whom?\r\n");
                return;
            }

            if (ch._socket == null)
            {
                return;
            }

            if (ch._socket.Original)
            {
                ch.SendText("You are already switched.\r\n");
                return;
            }

            if (!(victim = ch.GetCharWorld(str[0])))
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (victim == ch)
            {
                ch.SendText("Done.\r\n");
                return;
            }

            /*
            * Pointed out by Da Pub (What Mud)
            */
            if (!victim.IsNPC())
            {
                ch.SendText("You cannot switch into a player!\r\n");
                return;
            }

            if (victim._socket)
            {
                ch.SendText("Character in use.\r\n");
                return;
            }

            ((PC)ch).IsSwitched = true;
            ch._socket.Character = victim;
            ch._socket.Original = ch;
            victim._socket = ch._socket;
            ch._socket = null;
            victim.SendText("Done.\r\n");
            string buf = String.Format("{0} switched into {1}", realChar._name, victim._shortDescription);
            ImmortalChat.SendImmortalChat(ch, ImmortalChat.IMMTALK_SWITCHES, realChar.GetTrust(), buf);
            return;
        }

        public static void Return(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();

            if (ch._socket == null)
            {
                return;
            }

            if (!ch._socket.Original)
            {
                ch.SendText("You aren't switched.\r\n");
                return;
            }

            /* Note that we dont check for immortal ability to have return here.
            * We assume we will automatically allow immortals with switch to return.
            * Dont want to have our immortals stuck in a mobile's body do we?  :)
             */

            ch.SendText("You return to your original body.\r\n");
            ((PC)ch._socket.Original).IsSwitched = false;
            ch._socket.Character = ch._socket.Original;
            ch._socket.Original = null;
            ch._socket.Character._socket = ch._socket;
            ch._socket = null;

            string buf = String.Format("{0} returns to his original body.", realChar._name);
            ImmortalChat.SendImmortalChat(realChar, ImmortalChat.IMMTALK_SWITCHES, realChar.GetTrust(), buf);
            return;
        }

        /// <summary>
        /// Make a clone of something.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Clone(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string text;
            Object obj;
            CharData mob;

            if (str.Length == 0)
            {
                ch.SendText("Clone what?\r\n");
                return;
            }

            if (str.Length > 1 && !MUDString.IsPrefixOf(str[0], "object"))
            {
                mob = null;
                obj = ch.GetObjHere(str[1]);
                if (obj == null)
                {
                    ch.SendText("You don't see that here.\r\n");
                    return;
                }
            }
            else if (str.Length > 1 && !MUDString.IsPrefixOf(str[0], "mobile") || (!MUDString.IsPrefixOf(str[0], "character")))
            {
                obj = null;
                mob = ch.GetCharRoom(str[1]);
                if (mob == null)
                {
                    ch.SendText("You don't see that here.\r\n");
                    return;
                }
            }
            else
            {
                mob = ch.GetCharRoom(str[0]);
                obj = ch.GetObjHere(str[0]);
                if (mob == null && obj == null)
                {
                    ch.SendText("You don't see that here.\r\n");
                    return;
                }
            }

            /* clone object */
            if (obj != null)
            {
                Object clone = Database.CreateObject(obj.ObjIndexData, 0);
                Database.CloneObject(obj, ref clone);
                if (obj.CarriedBy != null)
                {
                    clone.ObjToChar(ch);
                }
                else
                {
                    clone.AddToRoom(ch._inRoom);
                }
                Object.RecursiveClone(ch, obj, clone);

                SocketConnection.Act("$n has created $p.", ch, clone, null, SocketConnection.MessageTarget.room);
                SocketConnection.Act("You clone $p.", ch, clone, null, SocketConnection.MessageTarget.character);
                text = String.Format("{0} clones {1}.", ch._name, clone.ShortDescription);
                ImmortalChat.SendImmortalChat(ch, ImmortalChat.IMMTALK_LOAD, ch.GetTrust(), text);
                return;
            }
            if (mob != null)
            {
                if (!mob.IsNPC())
                {
                    ch.SendText("You can only clone mobiles.\r\n");
                    return;
                }

                CharData clone = Database.CreateMobile(mob._mobIndexData);
                Database.CloneMobile(mob, clone);

                foreach (Object obj2 in mob._carrying)
                {
                    Object newObj = Database.CreateObject(obj2.ObjIndexData, 0);
                    Database.CloneObject(obj2, ref newObj);
                    Object.RecursiveClone(ch, obj2, newObj);
                    newObj.ObjToChar(clone);
                    newObj.WearLocation = obj2.WearLocation;
                }

                clone.AddToRoom(ch._inRoom);
                SocketConnection.Act("$n has created $N.", ch, null, clone, SocketConnection.MessageTarget.room);
                SocketConnection.Act("You clone $N.", ch, null, clone, SocketConnection.MessageTarget.character);
                text = String.Format("{0} clones {1}.", ch._name, clone._shortDescription);
                ImmortalChat.SendImmortalChat(ch, ImmortalChat.IMMTALK_LOAD, ch.GetTrust(), text);
                return;
            }
        }

        /// <summary>
        /// Loads a mobile into the game by creating it from a template.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void LoadMobile(CharData ch, string[] str)
        {
            if( ch == null ) return;

            MobTemplate pMobIndex;
            CharData realChar = ch.GetChar();

            if (str.Length == 0 || !MUDString.IsNumber(str[0]))
            {
                ch.SendText("Syntax: mload <index number>.\r\n");
                return;
            }

            int indexNumber;
            Int32.TryParse(str[0], out indexNumber);
            if (!(pMobIndex = Database.GetMobTemplate(indexNumber)))
            {
                ch.SendText("No mob has that index number.\r\n");
                return;
            }

            CharData victim = Database.CreateMobile(pMobIndex);
            victim.AddToRoom(ch._inRoom);
            ch.SendText("Done.\r\n");
            SocketConnection.Act("$n has created $N!", ch, null, victim, SocketConnection.MessageTarget.room);
            string text = String.Format("{0} has mloaded {1} at {2} [{3}]", ch._name, victim._shortDescription,
                                       ch._inRoom.Title, ch._inRoom.IndexNumber);
            ImmortalChat.SendImmortalChat(ch, ImmortalChat.IMMTALK_LOAD, realChar.GetTrust(), text);
            return;
        }

        public static void LoadObject(CharData ch, string[] str)
        {
            if( ch == null ) return;

            ObjTemplate objTemplate;
            int level;

            CharData realChar = ch.GetChar();

            if (str.Length < 1 || String.IsNullOrEmpty(str[0]) || !MUDString.IsNumber(str[0]))
            {
                ch.SendText("Syntax: load object <index number> <level>.\r\n");
                return;
            }

            if (str.Length < 2 || String.IsNullOrEmpty(str[1]))
            {
                level = ch.GetTrust();
            }
            else
            {
                if (!MUDString.IsNumber(str[1]))
                {
                    ch.SendText("Syntax: load object <index number> <level>.\r\n");
                    return;
                }
                Int32.TryParse(str[1], out level);
                if (level < 0 || level > ch.GetTrust())
                {
                    ch.SendText("Limited to your trust level, which is " + ch.GetTrust() + ".\r\n");
                    return;
                }
            }

            int indexNumber;
            Int32.TryParse(str[0], out indexNumber);
            if (!(objTemplate = Database.GetObjTemplate(indexNumber)))
            {
                ch.SendText("No object has that index number.\r\n");
                return;
            }

            Object obj = Database.CreateObject(objTemplate, level);
            if (obj.HasWearFlag(ObjTemplate.WEARABLE_CARRY))
            {
                obj.ObjToChar(ch);
            }
            else
            {
                obj.AddToRoom(ch._inRoom);
                SocketConnection.Act("$n&n has created $p&n!", ch, obj, null, SocketConnection.MessageTarget.room);
            }
            ch.SendText("Done.\r\n");
            string text = String.Format("{0} has loaded {1} at {2} [{3}]", ch._name, obj.ShortDescription,
                                       ch._inRoom.Title, ch._inRoom.IndexNumber);
            ImmortalChat.SendImmortalChat(ch, ImmortalChat.IMMTALK_LOAD, realChar.GetTrust(), text);
            return;
        }

        /// <summary>
        /// Immortal command to clear the room of junk (mobs and objects).
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Purge(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("purge"))
            {
                return;
            }

            if (str.Length == 0)
            {
                /* 'purge' */
                for( int i = (ch._inRoom.People.Count - 1); i >= 0; i-- )
                {
                    if (ch._inRoom.People[i].IsNPC() && ch._inRoom.People[i] != ch)
                    {
                        CharData.ExtractChar(ch._inRoom.People[i], true);
                    }
                }

                for( int i = (ch._inRoom.Contents.Count - 1); i >= 0; i-- )
                {
                    ch._inRoom.Contents[i].RemoveFromWorld();
                }

                ch.SendText("Done.\r\n");
                SocketConnection.Act("$n purges the room!", ch, null, null, SocketConnection.MessageTarget.room);
                return;
            }

            CharData victim = ch.GetCharWorld(str[0]);
            if (!victim)
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (!victim.IsNPC())
            {
                ch.SendText("Not on PC's.\r\n");
                return;
            }

            SocketConnection.Act("$n&n purges $N&n.", ch, null, victim, SocketConnection.MessageTarget.everyone_but_victim);
            CharData.ExtractChar(victim, true);
            return;
        }

        /// <summary>
        /// Immortal command to change a player's level.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Advance(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;
            string text;
            int level = 0;
            int iLevel = 0;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("advance"))
            {
                return;
            }

            if (str.Length < 2 || String.IsNullOrEmpty(str[0]) || String.IsNullOrEmpty(str[1]) || !MUDString.IsNumber(str[1]))
            {
                ch.SendText("Syntax: advance <char> <level>.\r\n");
                return;
            }

            if (!(victim = ch.GetCharRoom(str[0])))
            {
                ch.SendText("That player is not here.\r\n");
                return;
            }

            if (victim.IsNPC())
            {
                ch.SendText("Not on NPC's.\r\n");
                return;
            }

            Int32.TryParse(str[1], out level);

            if (level < 1 || level > Limits.MAX_LEVEL)
            {
                ch.SendText(String.Format("Advance within range 1 to {0}.\r\n", Limits.MAX_LEVEL));
                return;
            }

            if (level > ch.GetTrust())
            {
                ch.SendText("Limited to your trust level.\r\n");
                return;
            }

            /*
            * Lower level:
            *   Reset to level 1.
            *   Then raise again.
            *   Currently, an imp can lower another imp.
            */
            if (level <= victim._level)
            {
                ch.SendText("Lowering a player's level!\r\n");
                victim.SendText("**** OOOOHHHHHHHHHH  NNNNOOOO ****\r\n");
                victim._level = 1;
                // Max_hit should only be accessed for PERMENANT changes.
                victim._maxHitpoints = 20;
                if (ch._charClass.GainsMana)
                {
                    victim._maxMana = 50;
                    // Mana bonuses for newbies.
                    victim._maxMana += (victim.GetCurrInt() / 10);
                    victim._maxMana += (victim.GetCurrWis() / 14);
                    victim._maxMana += (victim.GetCurrPow() / 7);
                }
                else
                {
                    victim._maxMana = 0;
                }
                victim._maxMoves = 150;
                // removed resetting of skills.
                victim._hitpoints = victim.GetMaxHit();
                victim._currentMana = victim._maxMana;
                victim._currentMoves = victim._maxMoves;
                text = String.Format("{0} has been demoted to level {1} by {2}", victim._name,
                        level, ch._name);
                ImmortalChat.SendImmortalChat(victim, ImmortalChat.IMMTALK_LEVELS, realChar.GetTrust(), text);
            }
            else
            {
                ch.SendText("Raising a player's level!\r\n");
                victim.SendText("**** OOOOHHHHHHHHHH  YYYYEEEESSS ****\r\n");
                text = String.Format("{0} has been advanced to level {1} by {2}", victim._name,
                        level, ch._name);
                ImmortalChat.SendImmortalChat(victim, ImmortalChat.IMMTALK_LEVELS, realChar.GetTrust(), text);
            }

            // Do not advance skills -- rerolling someone will auto-master
            // their skills with no effort from the player... so we advance
            // them with skills set to false -- Xangis
            for (iLevel = victim._level; iLevel < level; iLevel++)
            {
                victim.AdvanceLevel(victim);
            }
            victim._experiencePoints = 1;
            victim._trustLevel = 0;

            return;
        }

        public static void Trust(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;
            string arg1 = String.Empty;
            string arg2 = String.Empty;
            int level;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("trust"))
            {
                return;
            }

            if (String.IsNullOrEmpty(arg1) || String.IsNullOrEmpty(arg2) || !MUDString.IsNumber(arg2))
            {
                ch.SendText("Syntax: trust <char> <level>.\r\n");
                return;
            }

            if (!(victim = ch.GetCharRoom(arg1)))
            {
                ch.SendText("That player is not here.\r\n");
                return;
            }

            Int32.TryParse(arg2, out level);

            if (level < 1 || level > Limits.MAX_LEVEL)
            {
                ch.SendText(String.Format("Trust within range 1 to {0}.\r\n", Limits.MAX_LEVEL));
                return;
            }

            if (level > ch.GetTrust())
            {
                ch.SendText("Limited to your trust.\r\n");
                return;
            }

            string text = String.Format("{0} has been trusted at level {1} by {2}", victim._name,
                                       level, ch._name);
            ImmortalChat.SendImmortalChat(ch, ImmortalChat.IMMTALK_LEVELS, realChar.GetTrust(), text);

            victim._trustLevel = level;
            return;
        }

        /// <summary>
        /// Immortal command to restore players to a fully rested state with full hits, moves, and mana.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Restore(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;
            string text;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("restore"))
            {
                return;
            }

            if (str.Length == 0 || !MUDString.StringsNotEqual(str[0], "room"))
            {
                foreach (CharData vch in ch._inRoom.People)
                {
                    if (vch.IsNPC())
                    {
                        continue;
                    }
                    ch.Restore(vch);
                }
                text = String.Format("{0} has restored room {1}.", realChar._name, ch._inRoom.IndexNumber);
                ImmortalChat.SendImmortalChat(ch, ImmortalChat.IMMTALK_RESTORE, realChar.GetTrust(), text);
                ch.SendText("Room restored.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[0], "all"))
            {
                foreach (CharData it in Database.CharList)
                {
                    victim = it;
                    if (!victim._inRoom || victim.IsNPC())
                    {
                        continue;
                    }
                    ch.Restore(victim);
                }
                text = String.Format("{0} has restored the whole mud.", ch._name);
                ImmortalChat.SendImmortalChat(ch, ImmortalChat.IMMTALK_RESTORE, realChar.GetTrust(), text);
                ch.SendText("Aww...how sweet :)...Done.\r\n");
            }
            else
            {
                if (!(victim = ch.GetCharWorld(str[0])))
                {
                    ch.SendText("They aren't here.\r\n");
                    return;
                }
                ch.Restore(victim);
                text = String.Format("{0} has restored {1}.", ch._name, victim._name);
                ImmortalChat.SendImmortalChat(ch, ImmortalChat.IMMTALK_RESTORE, realChar.GetTrust(), text);
                ch.SendText("Done.\r\n");
            }

            return;
        }

        /// <summary>
        /// Immortal command to paralyze a player.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Freeze(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;
            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("freeze"))
            {
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Freeze whom?\r\n");
                return;
            }

            if (!(victim = ch.GetCharWorld(str[0])))
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (ch == victim && ch.HasActBit(PC.PLAYER_FREEZE))
            {
                ch.RemoveActBit(PC.PLAYER_FREEZE);
            }

            if (victim.IsNPC())
            {
                ch.SendText("Not on NPC's.\r\n");
                return;
            }

            if (victim.GetTrust() >= ch.GetTrust())
            {
                ch.SendText("You failed.\r\n");
                return;
            }

            if (victim.HasActBit(PC.PLAYER_FREEZE))
            {
                victim.RemoveActBit(PC.PLAYER_FREEZE);
                ch.SendText("FREEZE removed.\r\n");
                victim.SendText("You can Play again.\r\n");
            }
            else
            {
                victim.SetActBit(PC.PLAYER_FREEZE);
                ch.SendText("FREEZE set.\r\n");
                victim.SendText("You can't do ANYthing!\r\n");
            }

            CharData.SavePlayer(victim);

            return;
        }

        /// <summary>
        /// Immortal command to turn logging on for target(s).
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void LogCommand(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("log"))
            {
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Log whom?\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[0], "all"))
            {
                if (MUDString.StringsNotEqual(str[0], "confirm") && !CommandType.fLogAll)
                {
                    ch.SendText("&+rType log all confirm to log everything everyone does!\r\n");
                    return;
                }
                if (CommandType.fLogAll)
                {
                    CommandType.fLogAll = false;
                    ch.SendText("Log ALL off.\r\n");
                }
                else
                {
                    CommandType.fLogAll = true;
                    ch.SendText("&+RLog ALL on. Logging everything!\r\n");
                }
                return;
            }

            if (!(victim = ch.GetCharWorld(str[0])))
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (victim.IsNPC())
            {
                ch.SendText("Not on NPC's.\r\n");
                return;
            }

            /*
            * No level check, gods can log anyone.
            */
            if (victim.HasActBit(PC.PLAYER_LOG))
            {
                victim.RemoveActBit(PC.PLAYER_LOG);
                ch.SendText("LOG removed.\r\n");
            }
            else
            {
                victim.SetActBit(PC.PLAYER_LOG);
                ch.SendText("LOG set.\r\n");
            }

            return;
        }

        /// <summary>
        /// Immortal command to take away a player's ability to emote.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void NoEmote(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("noemote"))
                return;

            if (str.Length == 0)
            {
                ch.SendText("Noemote whom?\r\n");
                return;
            }

            if (!(victim = ch.GetCharWorld(str[0])))
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (victim.IsNPC())
            {
                ch.SendText("Not on NPC's.\r\n");
                return;
            }

            if (victim.GetTrust() >= ch.GetTrust())
            {
                ch.SendText("You failed.\r\n");
                return;
            }

            if (victim.HasActBit(PC.PLAYER_NO_EMOTE))
            {
                victim.RemoveActBit(PC.PLAYER_NO_EMOTE);
                ch.SendText("NO_EMOTE removed.\r\n");
                victim.SendText("You can emote again.\r\n");
            }
            else
            {
                victim.SetActBit(PC.PLAYER_NO_EMOTE);
                victim.SendText("You can't emote!\r\n");
                ch.SendText("NO_EMOTE set.\r\n");
            }

            return;
        }

        /// <summary>
        /// Immortal command to make a player shut up permanently.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Silence(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("silence"))
            {
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Silence whom?\r\n");
                return;
            }

            if (!(victim = ch.GetCharWorld(str[0])))
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (victim.IsNPC())
            {
                ch.SendText("Not on NPC's.\r\n");
                return;
            }

            if (victim.GetTrust() >= ch.GetTrust())
            {
                ch.SendText("You failed.\r\n");
                return;
            }

            if (victim.HasActBit(PC.PLAYER_SILENCE))
            {
                victim.RemoveActBit(PC.PLAYER_SILENCE);
                victim.SendText("You can use channels again.\r\n");
                ch.SendText("SILENCE removed.\r\n");
            }
            else
            {
                victim.SetActBit(PC.PLAYER_SILENCE);
                victim.SendText("You can't use channels!\r\n");
                ch.SendText("SILENCE set.\r\n");
            }

            return;
        }

        /// <summary>
        /// Immortal commnand to stop all fights in the current room.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Peace(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData ich = ch.GetChar();

            if (!ich.Authorized("peace"))
            {
                return;
            }

            foreach (CharData rch in ch._inRoom.People)
            {
                if (rch._fighting)
                {
                    Combat.StopFighting(rch, true);
                }
                rch.StopHatingAll();
                Combat.StopHunting(rch);
                Combat.StopFearing(rch);
            }

            ch.SendText("Done.\r\n");
            return;
        }

        /// <summary>
        /// Immortal command to ban a site from the game.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Ban(CharData ch, string[] str)
        {
            if( ch == null ) return;

            BanData ban;

            if (ch.IsNPC())
            {
                return;
            }

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("ban"))
            {
                return;
            }

            if (str.Length == 0)
            {
                string text = "Banned sites:\r\n";
                foreach (BanData it in Database.BanList)
                {
                    ban = it;
                    text += ban.Name;
                    text += "\r\n";
                }
                ch.SendText(text);
                return;
            }

            foreach (BanData it in Database.BanList)
            {
                ban = it;

                if (!MUDString.StringsNotEqual(str[0], ban.Name))
                {
                    ch.SendText("That site is already banned!\r\n");
                    return;
                }
            }

            ban = new BanData();

            ban.Name = str[0];
            Database.BanList.Add(ban);
            ch.SendText("Done.\r\n");
            Event.UpdateBans();
            return;
        }

        /// <summary>
        /// Immortal command to remove a site from the ban list.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Allow(CharData ch, string[] str)
        {
            if( ch == null ) return;

            BanData curr;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("allow"))
            {
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Remove which site from the ban list?\r\n");
                return;
            }

            foreach (BanData it in Database.BanList)
            {
                curr = it;

                if (!MUDString.StringsNotEqual(str[0], curr.Name))
                {
                    Database.BanList.Remove(it);
                    ch.SendText("Done.\r\n");
                    Event.UpdateBans();
                    return;
                }
            }

            ch.SendText("Site is not banned.\r\n");
            return;
        }

        /// <summary>
        /// Command to lock the game so it can be entered by immortals only.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Wizlock(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("wizlock"))
            {
                return;
            }

            Database.SystemData.GameIsWizlocked = !Database.SystemData.GameIsWizlocked;

            if (Database.SystemData.GameIsWizlocked)
            {
                ch.SendText("Game wizlocked.\r\n");
            }
            else
            {
                ch.SendText("Game un-wizlocked.\r\n");
            }

            return;
        }

        /// <summary>
        /// Display information about a skill or group of skills.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void StatSkill(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string buf;
            string buf1 = String.Empty;
            string arg = String.Empty;
            int count;

            if (str.Length == 0)
            {
                ch.SendText("Stat which skill?\r\n");
                return;
            }
            if (!MUDString.StringsNotEqual(arg, "all"))
            {/* This is buggy for skills 59 through Skill.SkillList.Length-1.  Dunno why. */
                foreach( Skill skll in Skill.SkillList.Values)
                {
                    if (skll.Name == null)
                        continue;
                    if (buf1.Length > 4096 * 12 - 500)
                    {
                        ch.SendText("&+WToo many skills to display!!\r\n");
                        break;
                    }
                    buf = String.Format("Skill: '{1}' Lag: {2}\r\n", skll.Name, skll.Delay);
                    buf1 += buf;
                    for (count = 0; count < CharClass.ClassList.Length; ++count)
                    {
                        buf = String.Format("{0}: {1} ", MUDString.PadStr(CharClass.ClassList[count].Name, 18),
                                skll.ClassAvailability[count]);
                        if (count % 3 == 2)
                            buf1 += "\r\n";
                        buf1 += buf;
                    }
                    buf1 += "\r\n";
                }
                ch.SendText(buf1);
                return;
            }
            else
            {
                Skill skl = Skill.SkillList[arg];
                if (skl == null)
                {
                    ch.SendText("No such skill.\r\n");
                    return;
                }

                ch.SendText(skl.ToString());
            }

            return;
        }

        /// <summary>
        /// Shows statistics for a given spell or group of spells.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void StatSpell(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string arg = String.Join(" ", str);

            ch.GetChar();
                
            if (str.Length == 0)
            {
                ch.SendText("Stat what spell?\r\nYou can use 'stat spell all', 'stat spell <type>', types being 'ignore', 'offensive', 'object', or 'defensive'.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(arg, "all") || !MUDString.StringsNotEqual(arg, "offensive") || !MUDString.StringsNotEqual(arg, "none"))
            {
                TargetType type = TargetType.none;
                bool specificType = false;

                if ("offensive".StartsWith(arg, StringComparison.CurrentCultureIgnoreCase))
                {
                    specificType = true;
                    type = TargetType.singleCharacterOffensive;
                }
                else if ("ignore".StartsWith(arg, StringComparison.CurrentCultureIgnoreCase))
                {
                    specificType = true;
                    type = TargetType.none;
                }
                else if ("defensive".StartsWith(arg, StringComparison.CurrentCultureIgnoreCase))
                {
                    specificType = true;
                    type = TargetType.singleCharacterDefensive;
                }
                else if ("object".StartsWith(arg, StringComparison.CurrentCultureIgnoreCase))
                {
                    specificType = true;
                    type = TargetType.objectInInventory;
                }

                foreach (Spell spll in Spell.SpellList.Values)
                {
                    if (String.IsNullOrEmpty(spll.Name))
                        continue;

                    if (specificType && type != spll.ValidTargets)
                        continue;

                    ch.SendText(String.Format("Spell: '{0}'. ", spll.Name));
                    if (specificType)
                    {
                        ch.SendText(String.Format("Lag: {0}. Castable in battle: {1}. School: {2}.\r\n",
                                spll.CastingTime,
                                spll.CanCastInCombat ? "Yes." : "No. ",
                                StringConversion.SpellSchoolString(spll.School)));
                    }
                    else
                    {
                        ch.SendText("\r\n");
                    }
                }
            }
            else
            {
                try
                {
                    Spell sn = Spell.SpellList[arg];

                    ch.SendText(sn.ToString());
                }
                catch (KeyNotFoundException)
                {
                    ch.SendText("No such spell.\r\n");
                    return;
                }
            }

            return;
        }

        /// <summary>
        /// Set a skill to the specified value.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void SetSkill(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (str.Length < 3 ||  String.IsNullOrEmpty(str[0]) || String.IsNullOrEmpty(str[1]) || String.IsNullOrEmpty(str[2]))
            {
                ch.SendText("Syntax: set skill <victim> <skill> <value>\r\n");
                ch.SendText("or:     set skill <victim> all     <value>\r\n");
                ch.SendText("Skill being any skill.\r\n");
                return;
            }

            CharData victim;
            if (!(victim = ch.GetCharWorld(str[0])))
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (victim.IsNPC())
            {
                ch.SendText("Not on NPC's.\r\n");
                return;
            }

            if (ch._level <= victim._level && ch != victim)
            {
                ch.SendText("You may not set your peer nor your superior.\r\n");
                return;
            }

            bool all = (str[1].Equals("all", StringComparison.CurrentCultureIgnoreCase));
            Skill skl = null;
            if (!all && ((skl = Skill.SkillLookup(str[1])) == null))
            {
                ch.SendText("No such skill.\r\n");
                return;
            }

            if (!MUDString.IsNumber(str[2]))
            {
                ch.SendText("Value must be numeric.\r\n");
                return;
            }

            int value = 0;
            Int32.TryParse(str[2], out value);
            if (value < 0 || value > Limits.MAX_SKILL_ADEPT)
            {
                ch.SendText("Value range is 0 to " + Limits.MAX_SKILL_ADEPT.ToString() + ".\r\n");
                return;
            }

            if (all)
            {
                if (ch.GetTrust() < Limits.LEVEL_OVERLORD)
                {
                    ch.SendText("Only immortals level " + Limits.LEVEL_OVERLORD.ToString() + " and up may set all skills.\r\n");
                    return;
                }
                foreach( SkillEntry entry in ch._charClass.Skills )
                {
                    if( entry.Level < victim.GetTrust() )
                    {
                        ((PC)victim).SkillAptitude[entry.Name] = value;
                    }
                    else
                    {
                        ((PC)victim).SkillAptitude[entry.Name] = 1;
                    }
                }
            }
            else
            {
                ((PC)victim).SkillAptitude[skl.Name] = value;
            }

            ch.SendText("Ok.\r\n");

            return;
        }

        public static void SetRace(CharData ch, string[] str)
        {
            if( ch == null ) return;

            ch.SendText("Sorry, 'set race' is not done yet.\r\n");
            return;
        }

        public static void SetClass(CharData ch, string[] str)
        {
            if( ch == null ) return;

            ch.SendText("Sorry, 'set class' is not done yet.\r\n");
            return;
        }

        // TODO: FIXME: BUG: Not working with new code.
        public static void SetSpell(CharData ch, string[] str)
        {
            if( ch == null ) return;

            //CharData victim;
            //string arg1 = String.Empty;
            //string arg2 = String.Empty;
            //string arg3 = String.Empty;
            //int value;
            //int sn;
            //bool fAll;

            //argument = MUDString.OneArgument(argument, ref arg1);
            //argument = MUDString.OneArgument(argument, ref arg2);
            //MUDString.OneArgument(argument, ref arg3);

            //if (String.IsNullOrEmpty(arg1) || String.IsNullOrEmpty(arg2) || String.IsNullOrEmpty(arg3))
            //{
            //    ch.SendText("Syntax: set spell <victim> <spell> <value>\r\n");
            //    ch.SendText("or:     set spell <victim> all     <value>\r\n");
            //    ch.SendText("Skill being any skill.\r\n");
            //    return;
            //}

            //if (!(victim = ch.GetCharWorld(arg1)))
            //{
            //    ch.SendText("They aren't here.\r\n");
            //    return;
            //}

            //if (victim.IsNPC())
            //{
            //    ch.SendText("Not on NPC's.\r\n");
            //    return;
            //}

            //if (ch._level <= victim._level && ch != victim && MUDString.StringsNotEqual(ch._name, "Xangis"))
            //{
            //    ch.SendText("You may not set your peer or your superior.\r\n");
            //    return;
            //}

            //fAll = !MUDString.StringsNotEqual(arg2, "all");
            //sn = 0;
            //if (!fAll && (sn = StringLookup.SpellLookup(arg2)) < 0)
            //{
            //    ch.SendText("No such spell.\r\n");
            //    return;
            //}

            ///*
            //* Snarf the value.
            //*/
            //if (!MUDString.IsNumber(arg3))
            //{
            //    ch.SendText("Value must be numeric.\r\n");
            //    return;
            //}

            //Int32.TryParse(arg3, out value);
            //if (value < 0 || value > Limits.MAX_SPELL_ADEPT)
            //{
            //    ch.SendText("Value range is 0 to 99.\r\n");
            //    return;
            //}

            //if (fAll)
            //{
            //    if (ch.GetTrust() < Limits.L_DIR)
            //    {
            //        ch.SendText("Only Directors may set all.\r\n");
            //        return;
            //    }
            //    for (sn = 0; sn < Spell.Table.Length; sn++)
            //    {
            //        if (Spell.Table[sn]._name.Length > 0)
            //        {
            //            if (Spell.Table[sn]._spellCircle[(int)victim._charClass._classNumber] <= 11
            //                    || victim.IsImmortal())
            //                ((PC)victim).SpellAptitude[sn] = value;
            //        }
            //        else
            //        {
            //            if (Spell.Table[sn]._spellCircle[(int)victim._charClass._classNumber]
            //                    <= ((victim.GetTrust() + 4) / 5))
            //                ((PC)victim).SpellAptitude[sn] = 1;
            //        }
            //    }
            //}
            //else
            //{
            //    ((PC)victim).SpellAptitude[sn] = value;
            //}

            //return;
        }

        public static void SetMob(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;
            string buf = String.Empty;

            int value;

            ch.GetChar();

            if (str.Length < 3)
            {
                ch.SendText("Syntax: set mob <victim> <field>  <value>\r\n");
                ch.SendText("or:     set mob <victim> <string> <value>\r\n");
                ch.SendText("\r\n");
                ch.SendText("Field being one of:\r\n");
                ch.SendText("  str int wis dex con agi cha pow luck size\r\n");
                ch.SendText("  class hp mana move align wait height weight\r\n");
                ch.SendText("  sex race level thirst hunger drunk full security\r\n");
                ch.SendText("  copper silver gold platinum position exp faction\r\n");
                ch.SendText("  resistant immune susceptible vulnerable\r\n");
                ch.SendText("String being one of:\r\n");
                ch.SendText("  name short long title spec clan rank\r\n");
                return;
            }

            if (!(victim = ch.GetCharWorld(str[0])))
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            /*
            * Snarf the value (which need not be numeric).
            */
            bool ok = Int32.TryParse(str[2], out value);
            if (!ok)
            {
                value = -1;
            }

            /*
            * Set something.
            */
            if ("strength".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (value < 1 || value > Limits.MAX_BASE_ATTRIBUTE)
                {
                    buf += "Strength range is 1 to " + Limits.MAX_BASE_ATTRIBUTE + ".\r\n";
                    ch.SendText(buf);
                    return;
                }

                victim._permStrength = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("intelligence".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (value < 1 || value > Limits.MAX_BASE_ATTRIBUTE)
                {
                    buf += "Intelligence range is 1 to " + Limits.MAX_BASE_ATTRIBUTE + ".\r\n";
                    ch.SendText(buf);
                    return;
                }

                victim._permIntelligence = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("wisdom".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (value < 1 || value > Limits.MAX_BASE_ATTRIBUTE)
                {
                    buf += "Wisdom range is 1 to " + Limits.MAX_BASE_ATTRIBUTE + ".\r\n";
                    ch.SendText(buf);
                    return;
                }

                victim._permWisdom = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("dexterity".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (value < 1 || value > Limits.MAX_BASE_ATTRIBUTE)
                {
                    buf += "Dexterity range is 1 to " + Limits.MAX_BASE_ATTRIBUTE + ".\r\n";
                    ch.SendText(buf);
                    return;
                }

                victim._permDexterity = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("constitution".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (value < 1 || value > Limits.MAX_BASE_ATTRIBUTE)
                {
                    buf += "Constitution range is 1 to " + Limits.MAX_BASE_ATTRIBUTE + ".\r\n";
                    ch.SendText(buf);
                    return;
                }

                victim._permConstitution = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("agility".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (value < 1 || value > Limits.MAX_BASE_ATTRIBUTE)
                {
                    buf += "Agility range is 1 to " + Limits.MAX_BASE_ATTRIBUTE + ".\r\n";
                    ch.SendText(buf);
                    return;
                }

                victim._permAgility = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("charisma".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (value < 1 || value > Limits.MAX_BASE_ATTRIBUTE)
                {
                    buf += "Charisma range is 1 to " + Limits.MAX_BASE_ATTRIBUTE + ".\r\n";
                    ch.SendText(buf);
                    return;
                }

                victim._permCharisma = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("power".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (value < 1 || value > Limits.MAX_BASE_ATTRIBUTE)
                {
                    buf += "Power range is 1 to " + Limits.MAX_BASE_ATTRIBUTE + ".\r\n";
                    ch.SendText(buf);
                    return;
                }

                victim._permPower = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("luck".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (value < 1 || value > Limits.MAX_BASE_ATTRIBUTE)
                {
                    buf += "Luck range is 1 to " + Limits.MAX_BASE_ATTRIBUTE + ".\r\n";
                    ch.SendText(buf);
                    return;
                }

                victim._permLuck = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            /* size */
            if ("size".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                Race.Size newsize;

                int val;
                Int32.TryParse(str[2], out val);

                if (val == 0)
                    newsize = StringLookup.SizeLookup(str[2]);
                else
                    newsize = (Race.Size)val;

                if (newsize < 0 || newsize > Race.Size.none)
                {
                    buf += "Size range is from 0 to " + Race.MAX_SIZE + ".\r\n";
                    ch.SendText(buf);
                    return;
                }

                victim._size = newsize;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("position".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (value < 0 || value > (int)Position.standing)
                {
                    buf += "Position range is from 0 to " + Position.standing + ".\r\n";
                    ch.SendText(buf);
                    return;
                }

                victim._position = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("faction".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (victim.IsNPC())
                {
                    ch.SendText("Can't set faction values on an NPC.\r\n");
                    return;
                }

                ch.SendText("Setting faction values isn't done yet.\r\n");
                return;

                //if( value < Limits.MIN_FACTION || value > Limits.MAX_FACTION )
                //{
                //    ch.SendText( String.Format( "Valid faction values range from {0} to {1}.\r\n",
                //        Limits.MIN_FACTION, Limits.MAX_FACTION ));
                //    return;
                //}

            }

            if ("class".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                CharClass.Names cclass = CharClass.ClassLookup(str[2]);
                if (cclass < 0 || (int)cclass >= CharClass.ClassList.Length)
                {
                    int cval;
                    if (Int32.TryParse(str[2], out cval))
                    {
                        cclass = (CharClass.Names)cval;
                    }
                }

                if (cclass < 0 || (int)cclass >= CharClass.ClassList.Length)
                {
                    string buf4 = String.Format("Class range is 0 to {0}.\n", CharClass.ClassList.Length - 1);
                    ch.SendText(buf4);
                    return;
                }
                SocketConnection.Act("You set $N&n's class to $t.", ch, CharClass.ClassList[value].Name, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("Your class is now $t.", ch, CharClass.ClassList[value].Name, victim, SocketConnection.MessageTarget.victim); 
                victim._charClass = CharClass.ClassList[value];
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("sex".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (victim.IsAffected( Affect.AFFECT_CHANGE_SEX))
                {
                    ch.SendText("This person is affect by change sex.\r\n");
                    ch.SendText("Try again later.\r\n");
                    return;
                }

                if (value < 0 || value > 2)
                {
                    ch.SendText("Sex range is 0 to 2.\r\n");
                    return;
                }

                victim._sex = (MobTemplate.Sex)value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("race".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                Object wield;
                Object wield2;

                if (victim.IsAffected( Affect.AFFECT_POLYMORPH))
                {
                    ch.SendText("This person is affected by polymorph other.\r\n");
                    ch.SendText("Try again later.\r\n");
                    return;
                }

                int race = Race.RaceLookup(str[1]);

                if (race < 0 || race >= Race.RaceList.Length)
                    Int32.TryParse(str[2], out race);

                if (race < 0 || race >= Race.RaceList.Length)
                {
                    ch.SendText("Invalid race.\r\n");
                    return;
                }

                victim.SetPermRace(race);

                if ((wield = Object.GetEquipmentOnCharacter(victim, ObjTemplate.WearLocation.hand_one))
                        && wield.ItemType == ObjTemplate.ObjectType.weapon
                        && !victim.HasInnate(Race.RACE_WEAPON_WIELD))
                {
                    SocketConnection.Act("You drop $p&n.", victim, wield, null, SocketConnection.MessageTarget.character);
                    SocketConnection.Act("$n&n drops $p&n.", victim, wield, null, SocketConnection.MessageTarget.room);
                    wield.RemoveFromChar();
                    wield.AddToRoom(victim._inRoom);
                }

                if ((wield2 = Object.GetEquipmentOnCharacter(victim, ObjTemplate.WearLocation.hand_two))
                        && wield2.ItemType == ObjTemplate.ObjectType.weapon
                        && !victim.HasInnate(Race.RACE_WEAPON_WIELD))
                {
                    SocketConnection.Act("You drop $p&n.", victim, wield2, null, SocketConnection.MessageTarget.character);
                    SocketConnection.Act("$n&n drops $p&n.", victim, wield2, null, SocketConnection.MessageTarget.room);
                    wield2.RemoveFromChar();
                    wield2.AddToRoom(victim._inRoom);
                }

                ch.SendText("Ok.\r\n");
                return;
            }

            if ("level".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (!victim.IsNPC())
                {
                    ch.SendText("Not on PC's.\r\n");
                    return;
                }

                if (value < 0 || value > Limits.MAX_ADVANCE_LEVEL)
                {
                    ch.SendText("Level range is 0 to 40.\r\n");
                    return;
                }
                victim._level = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("wait".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (value < 0 || value > 120)
                {
                    ch.SendText("Wait range is 0 to 120.\r\n");
                    return;
                }
                victim._wait = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            //if ( !MUDString.strcasecmp( arg2, "copper" ) )
            //{
            //    victim.money.copper = value;
            //    return;
            //}
            //if ( !MUDString.strcasecmp( arg2, "silver" ) )
            //{
            //    victim.money.silver = value;
            //    return;
            //}
            //if ( !MUDString.strcasecmp( arg2, "gold" ) )
            //{
            //    victim.money.gold = value;
            //    return;
            //}
            //if ( !MUDString.strcasecmp( arg2, "platinum" ) )
            //{
            //    victim.money.platinum = value;
            //    return;
            //}

            if ("hp".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase) || "hitpoints".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (value < -10 || value > 30000)
                {
                    ch.SendText("HP range is -10 to 30,000 hit points.\r\n");
                    return;
                }
                if (victim._fighting && value < 0)
                {
                    ch.SendText("You cannot set a fighting person's hp below 0.\r\n");
                    return;
                }

                // Set their perm hitpoints so that their current max hitpoints will be reflected
                if (!ch.IsNPC())
                {
                    victim._maxHitpoints = ((value * 100) / victim.GetCurrCon()) + 1;
                }
                else
                {
                    victim._maxHitpoints = value;
                }

                ch.SendText("Ok.\r\n");
                return;
            }

            if ("mana".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (value < 0 || value > 30000)
                {
                    ch.SendText("Mana range is 0 to 30,000 mana points.\r\n");
                    return;
                }
                victim._maxMana = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("moves".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (value < 0 || value > 30000)
                {
                    ch.SendText("Move range is 0 to 30,000 move points.\r\n");
                    return;
                }
                victim._maxMoves = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("alignment".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (value < -1000 || value > 1000)
                {
                    ch.SendText("Alignment range is -1000 to 1000.\r\n");
                    return;
                }
                victim._alignment = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("thirsty".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (victim.IsNPC())
                {
                    ch.SendText("Not on NPC's.\r\n");
                    return;
                }

                if ((value < 0 || value > 100) && victim.GetTrust() < Limits.LEVEL_AVATAR)
                {
                    ch.SendText("Thirst range is 0 to 100.\r\n");
                    return;
                }
                if (value < -1 || value > 100)
                {
                    ch.SendText("Thirst range is -1 to 100.\r\n");
                    return;
                }

                ((PC)victim).Thirst = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ( "hunger".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase) || "hungry".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase) )
            {
                if (victim.IsNPC())
                {
                    ch.SendText("Not on NPC's.\r\n");
                    return;
                }

                if ((value < 0 || value > 100) && victim.GetTrust() < Limits.LEVEL_AVATAR)
                {
                    ch.SendText("Hunger range is 0 to 100.\r\n");
                    return;
                }
                if (value < -1 || value > 100)
                {
                    ch.SendText("Hunger range is -1 to 100.\r\n");
                    return;
                }

                ((PC)victim).Hunger = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("experience".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (victim.IsNPC())
                {
                    ch.SendText("Not on NPC's.\r\n");
                    return;
                }

                if (value < 0 || value > 100)
                {
                    ch.SendText("Experience range is 0 to 100 (in percent).\r\n");
                    return;
                }

                victim._experiencePoints = (value * ExperienceTable.Table[victim._level].LevelExperience) / 100;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("frags".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (victim.IsNPC())
                {
                    ch.SendText("Not on NPC's.\r\n");
                    return;
                }

                if (value < -1000 || value > 1000)
                {
                    ch.SendText("Frag range is -1000 to 1000.\r\n");
                    return;
                }

                ((PC)victim).Frags = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("drunkenness".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (victim.IsNPC())
                {
                    ch.SendText("Not on NPC's.\r\n");
                    return;
                }

                if (value < 0 || value > 100)
                {
                    ch.SendText("Drunk range is 0 to 100.\r\n");
                    return;
                }

                ((PC)victim).Drunk = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("weight".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (victim.IsNPC())
                {
                    ch.SendText("Not on NPC's.\r\n");
                    return;
                }

                if (value < 1 || value > 1000)
                {
                    ch.SendText("Weight range is 1 to 1000 pounds.\r\n");
                    return;
                }

                ((PC)victim).Weight = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("height".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (victim.IsNPC())
                {
                    ch.SendText("Not on NPC's.\r\n");
                    return;
                }

                if (value < 1 || value > 120)
                {
                    ch.SendText("Height range is 1 to 120 inches.\r\n");
                    return;
                }

                ((PC)victim).Height = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("full".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (victim.IsNPC())
                {
                    ch.SendText("Not on NPC's.\r\n");
                    return;
                }

                if ((value < 0 || value > 100)
                        && victim.GetTrust() < Limits.LEVEL_AVATAR)
                {
                    ch.SendText("Full range is 0 to 100.\r\n");
                    return;
                }
                if (value < -1 || value > 100)
                {
                    ch.SendText("Full range is -1 to 100.\r\n");
                    return;
                }

                ((PC)victim).Hunger = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("name".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (!victim.IsNPC())
                {
                    ch.SendText("Not on PC's.\r\n");
                    return;
                }

                if (ch.StringTooLong(str[2]))
                    return;

                victim._name = str[2];
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "short"))
            {
                if (ch.StringTooLong(str[2]))
                    return;

                victim._shortDescription = str[2];
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "long"))
            {
                if (ch.StringTooLong(str[2]))
                    return;

                victim._fullDescription = str[2] + "\r\n";
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "clan"))
            {
                Guild clan;
                Guild clanold;
                int count;
                bool found = false;

                if (victim.IsNPC())
                {
                    ch.SendText("Not on NPC's.\r\n");
                    return;
                }

                if ((clan = Guild.GetClan(str[2])) == null)
                {
                    ch.SendText("That clan doesn't exist.\r\n");
                    return;
                }

                // remember the number of the available slot in the count
                // variable so we can fill that slot at the end of this code
                for (count = 0; count < Limits.MAX_CLAN_MEMBERS; ++count)
                {
                    if (clan.Members[count].Filled == false)
                    {
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    ch.SendText("That clan is full.\r\n");
                    return;
                }

                if (((PC)victim).Clan != null)
                {
                    clanold = ((PC)victim).Clan;
                    clanold.NumMembers--;

                    int count2;
                    for (count2 = 0; count2 < Limits.MAX_CLAN_MEMBERS; count2++)
                    {
                        if (clanold.Members[count2].Name.Length == 0 || !MUDString.StringsNotEqual(clanold.Members[count2].Name, victim._name))
                        {
                            clanold.Members[count2].Filled = false;
                        }
                    }

                    clanold.Save();
                }

                ((PC)victim).Clan = clan;
                ((PC)victim).Clan.Name = clan.Name;
                ((PC)victim).Clan.NumMembers++;

                if (((PC)victim).ClanRank == 0)
                    ((PC)victim).ClanRank = Guild.Rank.normal;

                clan.Members[count].Name = victim._name;
                clan.Members[count].Rank = ((PC)victim).ClanRank;
                clan.Members[count].Fine = 0;
                clan.Members[count].JoinTime = Database.SystemData.CurrentTime;
                clan.Members[count].Filled = true;

                ch.SendText("Clan initiation successful.  Be sure to set rank.\r\n");

                clan.Save();

                ch.SendText("Ok.\r\n");
                return;
            }

            if ("resistant".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                victim._resistant = (Race.DamageType)value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("immune".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                victim._immune = (Race.DamageType)value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("susceptible".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                victim._susceptible = (Race.DamageType)value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("vulnerable".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                victim._vulnerable = (Race.DamageType)value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if ("title".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                if (victim.IsNPC())
                {
                    ch.SendText("Not on NPC's.\r\n");
                    return;
                }

                SetTitle(victim, str[2]);
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "spec"))
            {
                if (!victim.IsNPC())
                {
                    ch.SendText("Not on PC's.\r\n");
                    return;
                }

                List<MobSpecial> spec = MobSpecial.SpecMobLookup(str[2]);
                if (spec.Count < 1)
                {
                    ch.SendText("No such spec fun.\r\n");
                    return;
                }

                victim._mobIndexData.AddSpecFun(spec[0]);

                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "death"))
            {
                if (!victim.IsNPC())
                {
                    ch.SendText("Not on PC's.\r\n");
                    return;
                }

                if ((victim._mobIndexData.DeathFun = MobSpecial.SpecMobLookup(str[2])) == null)
                {
                    ch.SendText("No such death fun.\r\n");
                    return;
                }

                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "rank"))
            {
                if (victim.IsNPC())
                {
                    ch.SendText("Not on NPC's.\r\n");
                    return;
                }

                Guild.Rank rank;
                try
                {
                    rank = (Guild.Rank)Enum.Parse(typeof(Guild.Rank), str[1], false);
                }
                catch (Exception)
                {
                    ch.SendText("That's not a valid rank.\r\n");
                    return;
                }

                ((PC)victim).ClanRank = rank;
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "points"))
            {
                if (victim.IsNPC())
                {
                    ch.SendText("Not on NPC's.\r\n");
                    return;
                }
                ((PC)victim).SkillPoints = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "tradition"))
            {
                if (victim.IsNPC())
                {
                    ch.SendText("Not on NPC's.\r\n");
                    return;
                }
                if (value < 0 || value >= TraditionData.Table.Length)
                {
                    ch.SendText("Value out of range\r\n");
                    return;
                }

                ((PC)victim).Tradition = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "security"))
            {
                if (victim.IsNPC())
                {
                    ch.SendText("Not on NPC's.\r\n");
                    return;
                }

                if ((value > ((PC)ch).Security && ch.GetTrust() < Limits.LEVEL_OVERLORD)
                        || value < 0)
                {
                    if (((PC)ch).Security > 0)
                    {
                        buf += "Valid security is 0-" + ((PC)ch).Security + ".\r\n";
                        ch.SendText(buf);
                    }
                    else
                    {
                        ch.SendText("Valid security is 0 only.\r\n");
                    }
                    return;
                }
                ((PC)victim).Security = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            /*
            * Generate usage message.
            */
            CommandType.Interpret(ch, "set mob");
            return;
        }

        /// <summary>
        /// Immortal command to change object values and properties.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void SetObject(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object obj;
            int value;

            ch.GetChar();

            if (str.Length < 3)
            {
                ch.SendText("Syntax: set o <object> <field>  <value>\r\n");
                ch.SendText("or:     set o <object> <string> <value>\r\n");
                ch.SendText("\r\n");
                ch.SendText("Field being one of:\r\n");
                ch.SendText("  value0 value1 value2 value3 value4\r\n");
                ch.SendText("  value6 value7 type condition craft\r\n");
                ch.SendText("  extra wear level weight cost timer\r\n");
                ch.SendText("  aff0 aff1 aff2 aff3 aff4 index_aff\r\n");
                ch.SendText("\r\n");
                ch.SendText("String being one of:\r\n");
                ch.SendText("  name short long ed use spec\r\n");
                return;
            }

            if (!(obj = Object.GetObjectInWorld(ch, str[0])))
            {
                ch.SendText("Nothing like that in this universe.\r\n");
                return;
            }

            /*
            * Snarf the value (which need not be numeric).
            */
            Int32.TryParse(str[2], out value);

            /*
            * Set something.
            */
            if (!MUDString.StringsNotEqual(str[1], "value0") || !MUDString.StringsNotEqual(str[1], "v0"))
            {
                obj.Values[0] = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "value1") || !MUDString.StringsNotEqual(str[1], "v1"))
            {
                obj.Values[1] = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "value2") || !MUDString.StringsNotEqual(str[1], "v2"))
            {
                obj.Values[2] = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "value3") || !MUDString.StringsNotEqual(str[1], "v3"))
            {
                obj.Values[3] = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "value4") || !MUDString.StringsNotEqual(str[1], "v4"))
            {
                obj.Values[4] = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "value5") || !MUDString.StringsNotEqual(str[1], "v5"))
            {
                obj.Values[5] = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "value6") || !MUDString.StringsNotEqual(str[1], "v6"))
            {
                obj.Values[6] = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "value7") || !MUDString.StringsNotEqual(str[1], "v7"))
            {
                obj.Values[7] = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "aff0") || !MUDString.StringsNotEqual(str[1], "a0"))
            {
                obj.AffectedBy[0] = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "aff1") || !MUDString.StringsNotEqual(str[1], "a1"))
            {
                obj.AffectedBy[1] = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "aff2") || !MUDString.StringsNotEqual(str[1], "a2"))
            {
                obj.AffectedBy[2] = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "aff3") || !MUDString.StringsNotEqual(str[1], "a3"))
            {
                obj.AffectedBy[3] = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "aff4") || !MUDString.StringsNotEqual(str[1], "a4"))
            {
                obj.AffectedBy[4] = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "extra"))
            {
                if (!MUDString.IsNumber(str[2]))
                {
                    ch.SendText("Extra value must be a number.\r\n");
                    return;
                }

                obj.ExtraFlags[0] = value;
                ch.SendText("Extra flag is set.\r\n");
                return;
            }

            // TODO: FIXME: BUG: Does not work with new code.
            //if (!MUDString.StringsNotEqual(str[1], "index_aff") || !MUDString.StringsNotEqual(str[1], "ia"))
            //{
            //    argument = MUDString.OneArgument(argument, ref str[2]);
            //    argument = MUDString.OneArgument(argument, ref arg4);
            //    if (String.IsNullOrEmpty(str[2]) || String.IsNullOrEmpty(arg4))
            //    {
            //        ch.SendText("Syntax: set o <object> index_aff <aff_number> <value>\r\n");
            //        return;
            //    }

            //    if (!MUDString.IsNumber(str[2]) || !MUDString.IsNumber(arg4))
            //    {
            //        ch.SendText("The index affect and its value must be a number.\r\n");
            //        return;
            //    }

            //    Affect af;
            //    int val4 = 0;
            //    Affect.Apply affval = Affect.Apply.none;
            //    try
            //    {
            //        affval = (Affect.Apply)Enum.Parse(typeof(Affect.Apply), str[2]);
            //    }
            //    catch (Exception ex)
            //    {
            //        ch.SendText("Invalid affect apply type.\r\n");
            //        return;
            //    }

            //    Int32.TryParse(arg4, out val4);
            //    af = new Affect(0, 0, 0, -1, affval, val4, Affect.AFFECT_NONE);
            //    obj.AddAffect(af);

            //    ch.SendText("Added index affect.\r\n");
            //    return;

            //}

            if (!MUDString.StringsNotEqual(str[1], "extra"))
            {
                if (!MUDString.IsNumber(str[2]))
                {
                    ch.SendText("Extra value must be a number.\r\n");
                    return;
                }

                obj.ExtraFlags[0] = value;
                ch.SendText("Extra flag is set.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "extra2"))
            {
                if (!MUDString.IsNumber(str[2]))
                {
                    ch.SendText("Extra value must be a number.\r\n");
                    return;
                }

                obj.ExtraFlags[1] = value;
                ch.SendText("Extra2 flag is set.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "extra3"))
            {
                if (!MUDString.IsNumber(str[2]))
                {
                    ch.SendText("Extra value must be a number.\r\n");
                    return;
                }

                obj.ExtraFlags[2] = value;
                ch.SendText("Extra3 flag is set.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "wear"))
            {
                obj.WearFlags[0] = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "level"))
            {
                obj.Level = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "type"))
            {
                try
                {
                    obj.ItemType = (ObjTemplate.ObjectType)Enum.Parse(typeof(ObjTemplate.ObjectType), str[1], false);
                    ch.SendText("Ok.\r\n");
                }
                catch (Exception)
                {
                    ch.SendText("Invalid object type.");
                }
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "weight"))
            {
                if (obj.CarriedBy != null && !obj.CarriedBy.IsNPC())
                {
                    ch.SendText("You may not modify an item's weight while on a PC.\r\n");
                    return;
                }
                obj.Weight = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "condition"))
            {
                obj.Condition = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "craft"))
            {
                try
                {
                    obj.Craftsmanship = (ObjTemplate.Craftsmanship)value;
                    ch.SendText("Ok.\r\n");
                }
                catch (Exception)
                {
                    ch.SendText("Bad value for craftsmanship.\r\n");
                }
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "cost"))
            {
                obj.Cost = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "timer"))
            {
                obj.Timer = value;
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "name"))
            {
                if (ch.StringTooLong(str[2]))
                    return;

                obj.Name = str[2];
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "short"))
            {
                if (ch.StringTooLong(str[2]))
                    return;

                obj.ShortDescription = str[2];
                ch.SendText("Ok.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "long"))
            {
                if (ch.StringTooLong(str[2]))
                    return;

                obj.FullDescription = str[2];
                ch.SendText("Ok.\r\n");
                return;
            }
            if (!MUDString.StringsNotEqual(str[1], "spec"))
            {
                // Changed because it wasn't checking objindex data right now. -Tryden
                //objindex = obj.pIndexData;
                obj.SpecFun = StringLookup.SpecObjLookup(str[2]);
                if (obj.SpecFun == null)
                    ch.SendText("Object Special is null.  No such special.\r\n");
                else
                    ch.SendText("Object special set.\r\n");
                return;
            }

            /*if (!MUDString.strcasecmp(str[1], "use")) {
            objindex = obj.pIndexData;

            uf = spec_use_lookup(str[2]);
            if (!uf)
            {
            ch.SendText( "Object Use is null.  No such use.\r\n" );
            return;
            }
            use_temp = new SPEC_ObjIndex.USE_DATA;
            if (!use_temp) {
            ch.SendText( "ERROR: Could not make a new use record. RAM low!\r\n" );
            return;
            }
            use_temp.next = spec_use;
            spec_use = use_temp;
            spec_use.spec_fun = uf;
            spec_use.vnum = objindex.vnum;
            ch.SendText( "Object use set.\r\n" );
            return;
            }*/
            if (!MUDString.StringsNotEqual(str[1], "ed"))
            {
                if (str.Length < 4 )
                {
                    ch.SendText("Syntax: oset <object> ed <keyword> <string>\r\n");
                    return;
                }

                ExtendedDescription ed = new ExtendedDescription();

                ed.Keyword = str[2];
                ed.Description = str[3];
                obj.ExtraDescription.Add(ed);
                ch.SendText("Ok.\r\n");
                return;
            }

            /*
            * Generate usage message.
            */
            CommandType.Interpret(ch, "oset");
            return;
        }

        /// <summary>
        /// Set bits and flags in a room.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void SetRoom(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int value;

            if (str.Length < 3)
            {
                ch.SendText("Syntax: set room <location> <field> <value>\r\n");
                ch.SendText("\r\n");
                ch.SendText("Field being one of:\r\n");
                ch.SendText("  flags flags2 sector\r\n");
                return;
            }

            Room location = Room.FindLocation(ch, str[0]);
            if (!location)
            {
                ch.SendText("No such location.\r\n");
                return;
            }

            /*
            * Snarf the value (which need not be numeric).
            */
            Int32.TryParse(str[2], out value);

            foreach (CharData person in location.People)
            {
                if (!person.IsNPC() && person != ch && person._level >= ch._level && MUDString.StringsNotEqual(ch._name, "Xangis"))
                {
                    ch.SendText("Your superior is in this room, no rsetting now.\r\n");
                    return;
                }
            }

            /*
            * Set something.
            */
            if (!MUDString.StringsNotEqual(str[1], "flags"))
            {
                /*
                * Value-based flagging has been disabled until we have an
                * equivalent _function that handles bitvector data.
                * -- Xangis
                if ( !MUDString.is_number( arg3 ) )
                {
                if ( ( value = flag_value( room_flags, arg3 ) ) != NO_FLAG )
                {
                Macros.TOGGLE_BIT( location.room_flags[0], value );
                ch.SendText( "Room flag toggled.\r\n" );
                }

                return;
                }
                */

                location.CurrentRoomFlags[0] = value;
                ch.SendText("Room flags set.\r\n");
                location.CurrentRoomFlags[0] = value;
                return;
            }
            if (!MUDString.StringsNotEqual(str[1], "flags2"))
            {
                /*
                * Value-based flagging has been disabled until we have an
                * equivalent _function that handles bitvector data.
                * -- Xangis
                if ( !MUDString.is_number( arg3 ) )
                {
                if ( ( value = flag_value( room_flags, arg3 ) ) != NO_FLAG )
                {
                Macros.TOGGLE_BIT( location.room_flags[1], value );
                ch.SendText( "Room flag toggled.\r\n" );
                }

                return;
                }
                */

                location.CurrentRoomFlags[1] = value;
                ch.SendText("Room flags 2 set.\r\n");
                location.CurrentRoomFlags[1] = value;
                return;
            }
            if (!MUDString.StringsNotEqual(str[1], "sector"))
            {
                try
                {
                    TerrainType terr = (TerrainType)Enum.Parse(typeof(TerrainType), str[1], false);
                    location.TerrainType = terr;
                    ch.SendText("Sector type set.\r\n");
                }
                catch (Exception)
                {
                    // They entered something wrong.  We don't care.
                    ch.SendText("Invalid sector type.\r\n");
                }

                return;
            }

            /*
            * Generate usage message.
            */
            CommandType.Interpret(ch, "rset");
            return;
        }

        /// <summary>
        /// Lists all users in the game.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Users(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();
            SocketConnection socket;
            string text = String.Empty;
            string arg = String.Empty;

            if (!realChar.Authorized("users"))
            {
                return;
            }

            int count = 0;

            if (arg.Length > 0)
            {
                CharData victim = realChar.GetCharWorld(arg);
                if (!victim)
                {
                    realChar.SendText("They don't seem to be online.\r\n");
                    return;
                }
                foreach (SocketConnection it in Database.SocketList)
                {
                    socket = it;

                    if (socket.Character != victim)
                        continue;
                    text = String.Format("[{0} {1}] {2}@{3}\r\n",
                            MUDString.PadStr(socket.ToString(), 3),
                            socket._connectionState.ToString(),
                            socket.Original ? socket.Original._name :
                            socket.Character ? socket.Character._name : "(none)",
                            socket._host);
                    ch.SendText(text);
                }
                return;
            }

            foreach (SocketConnection it in Database.SocketList)
            {
                socket = it;

                if (socket.Character && CharData.CanSee(ch, socket.Character))
                {
                    ++count;
                    text = String.Format("[{1}] {2}@{3}\r\n",
                            socket._connectionState.ToString(),
                            socket.Original ? socket.Original._name :
                            socket.Character ? socket.Character._name : "(none)",
                            socket._host);
                }
            }

            string buf2 = String.Format("{0} user{1}\r\n", count, count == 1 ? String.Empty : "s");
            text += buf2;
            ch.SendText(text);
            return;
        }

        /// <summary>
        /// Immortal command to force someone to do something.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Force(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("force"))
                return;

            if (str.Length < 2)
            {
                ch.SendText("Force whom to do what?\r\n");
                return;
            }

            /*
            * Look for command in command table.
            */
            int trust = ch.GetTrust();
            foreach (CommandType cmd in CommandType.CommandTable)
            {
                if ( !MUDString.IsPrefixOf(str[0], cmd.Name)
                        && (cmd.MinLevel > trust))
                {
                    ch.SendText("You can't even do that yourself!\r\n");
                    return;
                }
            }

            string action = String.Join(" ", str, 1, (str.Length - 1));

            if (!MUDString.StringsNotEqual(str[0], "all"))
            {
                CharData vch;

                foreach (CharData it in Database.CharList)
                {
                    vch = it;

                    if (!vch.IsNPC() && vch.GetTrust() < ch.GetTrust())
                    {
                        SocketConnection.Act("$n forces you to '$t'.", ch, action, vch, SocketConnection.MessageTarget.victim);
                        CommandType.Interpret(vch, action);
                    }
                }
            }
            else
            {
                CharData victim;

                if (!(victim = ch.GetCharWorld(str[0])))
                {
                    ch.SendText("They aren't here.\r\n");
                    return;
                }

                if (victim == ch)
                {
                    ch.SendText("Aye aye, right away!\r\n");
                    return;
                }

                if (victim.GetTrust() >= ch.GetTrust())
                {
                    ch.SendText("Do it yourself!\r\n");
                    return;
                }

                SocketConnection.Act("$n forces you to '$t'.", ch, action, victim, SocketConnection.MessageTarget.victim);
                CommandType.Interpret(victim, action);
            }

            ch.SendText("Done.\r\n");
            return;
        }

        /// <summary>
        /// Immortal invisibility command.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Invis(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch.IsNPC())
                return;

            if (!ch.Authorized("wizinvis"))
                return;

            if (ch.HasActBit(PC.PLAYER_WIZINVIS))
            {
                ch.RemoveActBit(PC.PLAYER_WIZINVIS);
                ch.SendText("You slowly fade back into existence.\r\n");
                SocketConnection.Act("$n slowly fades into existence.", ch, null, null, SocketConnection.MessageTarget.room);
            }
            else
            {
                ch.SendText("You slowly vanish into thin air.\r\n");
                SocketConnection.Act("$n slowly fades into thin air.", ch, null, null, SocketConnection.MessageTarget.room);
                ch.SetActBit(PC.PLAYER_WIZINVIS);
            }

            return;
        }

        public static void GodMode(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch.IsNPC())
                return;

            if (!ch.Authorized("godmode"))
                return;

            if (ch.HasActBit(PC.PLAYER_GODMODE))
            {
                ch.RemoveActBit(PC.PLAYER_GODMODE);
                ch.SendText("God mode off.\r\n");
            }
            else
            {
                ch.SetActBit(PC.PLAYER_GODMODE);
                ch.SendText("God mode on.\r\n");
            }

            return;
        }

        public static void Wizify(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;
            string arg1 = String.Empty;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("wizify"))
                return;

            if (String.IsNullOrEmpty(arg1))
            {
                ch.SendText("Syntax: wizify <_name>\r\n");
                return;
            }
            if (!(victim = ch.GetCharWorld(arg1)))
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }
            if (victim.IsNPC())
            {
                ch.SendText("Not on mobs.\r\n");
                return;
            }


            if (!victim.HasActBit(PC.PLAYER_WIZBIT))
            {
                victim.SetActBit(PC.PLAYER_WIZBIT);
                SocketConnection.Act("$N wizified.", ch, null, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n has wizified you!", ch, null, victim, SocketConnection.MessageTarget.victim);
            }
            else
            {
                victim.RemoveActBit(PC.PLAYER_WIZBIT);
                SocketConnection.Act("$N dewizzed.", ch, null, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n has dewizzed you!", ch, null, victim, SocketConnection.MessageTarget.victim);
            }

            CommandType.Interpret(ch, "save");
            return;
        }

        public static void ObjectWhere(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object obj;
            Object inObj;
            string buf;
            int objCounter = 1;
            bool found = false;

            if (str.Length == 0)
            {
                ch.SendText("Syntax:  owhere <object>.\r\n");
                return;
            }
            int indexNumber;
            Int32.TryParse(str[0], out indexNumber);

            foreach (Object it in Database.ObjectList)
            {
                obj = it;
                if (!CharData.CanSeeObj(ch, obj))
                    continue;
                if (!MUDString.NameContainedIn(str[0], obj.Name) && obj.ObjIndexData && obj.ObjIndexData.IndexNumber != indexNumber)
                    continue;

                found = true;

                for (inObj = obj; inObj.InObject;
                     inObj = inObj.InObject)
                {
                }

                if (inObj.CarriedBy)
                {
                    if (!CharData.CanSee(ch, inObj.CarriedBy))
                        continue;
                    buf = String.Format("[{0}] {1}&n carried by {2}&n at [{3}].\r\n",
                                        MUDString.PadInt(objCounter, 2), obj.ShortDescription,
                                        inObj.CarriedBy.ShowNameTo(ch, false),
                                        MUDString.PadInt(inObj.CarriedBy._inRoom.IndexNumber, 4));
                }
                else
                {
                    buf = String.Format("[{0}] {1}&n in {2}&n at [{3}].\r\n", MUDString.PadInt(objCounter, 2),
                                        obj.ShortDescription, (!inObj.InRoom) ?
                                                                                     "somewhere" : inObj.InRoom.Title,
                                        MUDString.PadInt((!inObj.InRoom) ? 0 : inObj.InRoom.IndexNumber, 4));
                }

                objCounter++;
                ch.SendText(buf.ToUpper());

                /* Only see the first 101 */
                if (objCounter > 100)
                    break;
            }

            if (!found)
                ch.SendText("Nothing like that in noting like that in this universe.\r\n");

            return;


        }

        public static void Numlock(CharData ch, string[] str)  /*By Globi*/
        {
            if( ch == null ) return;

            string buf;
            int temp;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("numlock"))
                return;

            if (str.Length == 0)
            {
                ch.SendText("Numlock to what level?\r\n");
                return;
            }

            if (String.IsNullOrEmpty(str[0])) /* Prints out the current value */
            {
                buf = String.Format("Current numlock setting is:  {0}.\r\n", Database.SystemData.NumlockLevel);
                ch.SendText(buf);
                return;
            }

            Int32.TryParse(str[0], out temp);
            if ((temp < 0) || (temp > Limits.LEVEL_HERO))
            {
                buf = String.Format("Level must be between 0 and {0}.\r\n", Limits.LEVEL_HERO);
                ch.SendText(buf);
                return;
            }

            Database.SystemData.NumlockLevel = temp;  /* Only set _numlockLevel if arg supplied and within range */

            if (Database.SystemData.NumlockLevel != 0)
            {
                buf = String.Format("Game numlocked to levels {0} and below.\r\n", Database.SystemData.NumlockLevel);
                ch.SendText(buf);
            }
            else
                ch.SendText("Game now open to all levels.\r\n");

            return;

        }

        public static void NewPlayerLock(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string buf;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("newlock"))
                return;

            if (Database.SystemData.NumlockLevel != 0 && ch.GetTrust() < Limits.LEVEL_GREATER_GOD)
            {
                ch.SendText("You may not change the current _numlockLevel setting\r\n");
                buf = String.Format("Game numlocked to levels {0} and below.\r\n", Database.SystemData.NumlockLevel);
                ch.SendText(buf);
                return;
            }

            if (Database.SystemData.NumlockLevel != 0)
            {
                buf = String.Format("Game numlocked to levels {0} and below.\r\n", Database.SystemData.NumlockLevel);
                ch.SendText(buf);
                ch.SendText("Changing to: ");
            }

            Database.SystemData.NumlockLevel = 1;
            ch.SendText("Game locked to new characters.\r\n");
            return;

        }

        public static void Sstime(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string text;
            string arg1 = String.Empty;
            int number;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("sstime"))
                return;

            if (!MUDString.StringsNotEqual(arg1, "reboot"))
            {
                Database.Reboot = !Database.Reboot;
                text = String.Format("Reboot is {0}.\r\n", Database.Reboot ? "on" : "off");
                ch.SendText(text);
                return;
            }

            Int32.TryParse(arg1, out number);

            if (String.IsNullOrEmpty(arg1) || !MUDString.IsNumber(arg1) || number < 0)
            {
                ch.SendText("Syntax: sstime <value>/reboot\r\n");
                ch.SendText("\r\n");
                ch.SendText("Value is number of minutes till reboot/shutdown.");
                ch.SendText("  Or 0 to turn off.\r\n");
                ch.SendText("Reboot will toggle reboot on or off.\r\n");
                ch.SendText("\r\n");
                if (Database.SystemData.ShutdownIsScheduled)
                {
                    TimeSpan span = Database.SystemData.ShutdownTime - Database.SystemData.CurrentTime;
                    text = String.Format("{0}{1} minutes ({2} seconds).\r\n",
                            Database.Reboot ? "Reboot:       " : "Shutdown:     ",
                            span.TotalMinutes,
                            span.TotalSeconds);
                    ch.SendText(text);
                }
                else
                    ch.SendText("Automatic reboot/shutdown:  off.\r\n");
                return;
            }

            /* Set something */
            if (number > 0)
            {
                Database.SystemData.ShutdownTime = Database.SystemData.CurrentTime + TimeSpan.FromMinutes(number);
                TimeSpan span = Database.SystemData.ShutdownTime - Database.SystemData.CurrentTime;
                text = String.Format("{0} will be in {1} minutes ({2} seconds).\r\n",
                        Database.Reboot ? "Reboot" : "Shutdown",
                        span.TotalMinutes,
                        span.TotalSeconds);
                ch.SendText(text);
            }
            else
            {
                Database.SystemData.ShutdownTime = new DateTime();
                text = String.Format("Auto{0} is now off.\r\n",
                        Database.Reboot ? "reboot" : "shutdown");
                ch.SendText(text);
            }

            return;

        }

        public static void ImmortalSkillSet(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;
            bool all = false;
            int col = 0;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("imtlset") || !realChar.IsImmortal() )
            {
                return;
            }

            if (str.Length < 1)
            {
                ch.SendText("Syntax: imtlset <victim> +|- <immortal skill>\r\n");
                ch.SendText("or:     imtlset <victim> +|- all\r\n");
                ch.SendText("or:     imtlset <victim>\r\n");
                return;
            }

            if (!(victim = realChar.GetCharWorld(str[0])))
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (victim.IsNPC())
            {
                ch.SendText("Not on NPC's.\r\n");
                return;
            }

            if (!victim.IsImmortal())
            {
                ch.SendText("They're not immortal.\r\n");
                return;
            }

            if (realChar._level <= victim._level && realChar != victim && MUDString.StringsNotEqual(ch._name, "Xangis"))
            {
                ch.SendText("You may not imtlset your peer nor your superior.\r\n");
                return;
            }

            if (str.Length > 2 && str[1] == "+" || str[1] == "-")
            {
                if (!MUDString.StringsNotEqual(str[2], "all"))
                {
                    all = true;
                }

                if( str[1] == "+")
                {
                    if (!all)
                    {
                        if (MUDString.NameContainedIn(str[2], ((PC)victim).ImmortalData.ImmortalSkills))
                        {
                            ch.SendText("That skill has already been set.\r\n");
                            return;
                        }

                    }

                    foreach (CommandType cmd in CommandType.CommandTable)
                    {
                        if (cmd.MinLevel > realChar.GetTrust())
                        {
                            continue;
                        }
                        if (all)
                        {
                            if (cmd.MinLevel <= victim.GetTrust() && cmd.MinLevel >= Limits.LEVEL_HERO
                                    && !MUDString.NameContainedIn(cmd.Name,
                                                "delet reboo sla shutdow :"))
                            {
                                ((PC)victim).ImmortalData.ImmortalSkills += cmd.Name + " ";
                            }
                        }
                        else /* Add only one skill */
                        {
                            if (str[2] == cmd.Name)
                            {
                                if (MUDString.NameContainedIn(str[2], "terminat reboo sla shutdow :"))
                                {
                                    ch.SendText("That is not an immskill.\r\n");
                                    return;
                                }
                                ((PC)victim).ImmortalData.ImmortalSkills += str[2] + " ";
                                break;
                            }
                        }
                    }
                }
                else /* str1 == "-" */
                {
                    if (all)
                    {
                        ((PC)victim).ImmortalData.ImmortalSkills = String.Empty;
                        ch.SendText("All Immskills have been deleted.\r\n");
                        return;
                    }
                    /* Remove one skill */
                    string buf2 = ((PC)victim).ImmortalData.ImmortalSkills;

                    if (!MUDString.NameContainedIn(str[2], ((PC)victim).ImmortalData.ImmortalSkills))
                    {
                        ch.SendText("That Immskill is not set.\r\n");
                        return;
                    }

                    ((PC)victim).ImmortalData.ImmortalSkills = ((PC)victim).ImmortalData.ImmortalSkills.Remove(((PC)victim).ImmortalData.ImmortalSkills.IndexOf(buf2, buf2.Length));
                }
            }

            string text = "Immortal skills set for " + victim._name + ":\r\n";
            foreach (CommandType cmd in CommandType.CommandTable)
            {
                if (cmd.MinLevel < Limits.LEVEL_HERO
                        || !MUDString.NameContainedIn(cmd.Name, ((PC)victim).ImmortalData.ImmortalSkills))
                {
                    continue;
                }

                text += MUDString.PadStr(cmd.Name, 10);
                if (++col % 7 == 0)
                {
                    text += "\r\n";
                }
            }

            if (col % 7 != 0)
            {
                text += "\r\n";
            }
            ch.SendText(text);

            return;
        }

        public static void Rename(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();
            CharData victim;

            if (!realChar.Authorized("rename"))
            {
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Rename whom?\r\n");
                return;
            }

            if (str.Length < 2)
            {
                ch.SendText("Rename them to what?\r\n");
                return;
            }

            if (!(victim = ch.GetCharWorld(str[0])))
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (realChar._level <= victim._level)
            {
                ch.SendText("You may not rename your peer nor your superior.\r\n");
                return;
            }

            if (!SocketConnection.CheckPlayerName(str[1]))
            {
                ch.SendText("Illegal _name, try again.\r\n");
                return;
            }

            if (victim.IsNPC())
            {
                ch.SendText("You can't rename NPCs, you fool!");
                return;
            }

            Log.Trace("Rename: Saving");
            CharData.SavePlayer(victim);
            Log.Trace("Rename: Backing Up");
            CharData.BackupPlayer(victim);
            Log.Trace("Rename: Deleting");
            CharData.DeletePlayer(victim);

            Log.Trace("Rename: Giving New Name to Player");
            string oldname = victim._name;
            victim._name = str[1].ToUpper();

            Log.Trace("Rename: Saving Renamed Player");
            CharData.SavePlayer(victim);
            ch.SendText("Done.\r\n");
            string text = String.Format("Your new _name is {0}.\r\n", victim._name);
            victim.SendText(text);

            text = String.Format("{0} has just renamed {1} to {2}.", ch._name, oldname, victim._name);
            ImmortalChat.SendImmortalChat(ch, ImmortalChat.IMMTALK_SECURE, realChar.GetTrust(), text);
            Log.Trace(text);

            return;
        }

        public static void Terminat(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("terminate"))
            {
                return;
            }

            ch.SendText("If you want to TERMINATE someone, spell it out.\r\n");
            return;
        }

        /// <summary>
        /// Deletes/destroys a character and removes them from the game.  Reserved for use
        /// on real grade-A jerks.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Terminate(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;
            SocketConnection socket;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("terminate"))
            {
                return;
            }

            if (str.Length == 0 )
            {
                ch.SendText("Terminate whom?\r\n");
                return;
            }

            if (!(victim = realChar.GetCharWorld(str[0])))
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (!victim._socket)
            {
                SocketConnection.Act("$N&n doesn't have a descriptor.", ch, null, victim, SocketConnection.MessageTarget.character);
            }

            if (realChar == victim)
            {
                ch.SendText("You may not terminate yourself, use RETIRE.\r\n");
                return;
            }

            if (realChar._level <= victim._level && realChar != victim)
            {
                ch.SendText("You may not terminate your peer nor your superior.\r\n");
                return;
            }

            foreach (SocketConnection it in Database.SocketList)
            {
                socket = it;

                if (socket == victim._socket)
                {
                    /* By saving first i assure i am not removing a non existing file
                    * i know it's stupid and probably useless but... 
                    */
                    victim.SendText("&+RYour soul has been revoked by the gods!&n\r\n");
                    SocketConnection.Act("&+R$n&+R grabs ahold of $N&+R's soul and tears it to shreds.&n\r\n" +
                        "&+R$n&+R then proceeds to jump all over the little pieces while cackling fiendishly.&n", realChar, null, victim, SocketConnection.MessageTarget.room);
                    Log.Trace("Terminate: Saving");
                    CharData.SavePlayer(victim);
                    Log.Trace("Terminate: Backing Up");
                    CharData.BackupPlayer(victim);
                    Log.Trace("Terminate: Deleting");
                    CharData.DeletePlayer(victim);
                    Log.Trace("Terminate: Extracting");
                    CharData.ExtractChar(victim, true);
                    Log.Trace("Terminate: Closing Socket");
                    socket.CloseSocket();
                    realChar.SendText("&+RVic&+rtim des&+Rtro&+ryed&+R!&n\r\n");
                    return;
                }
            }

            ch.SendText("Termination target not found!\r\n");
            return;
        }

        /// <summary>
        /// Makes any character instantly sober.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Sober(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();
            CharData victim;
            string arg = String.Empty;

            if (!realChar.Authorized("sober"))
            {
                return;
            }

            if (!(victim = ch.GetCharRoom(arg)))
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (victim.IsNPC())
            {
                ch.SendText("Not on mobs.\r\n");
                return;
            }

            ((PC)victim).Drunk = 0;

            ch.SendText("Done.\r\n");
            victim.SendText("You feel sober again.\r\n");

            return;
        }

        public static void StatClass(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int circle;
            int level;

            CharData realChar = ch.GetChar();
            int num = (int)realChar._charClass.ClassNumber;

            /*
            * Set default arguments.
            */
            CharClass cclass = realChar._charClass;

            if (str.Length != 0 && !String.IsNullOrEmpty(str[0]))
            {
                // If it's not a number try it as a class name.
                if (Int32.TryParse(str[0], out num))
                {
                    cclass = CharClass.ClassList[num];
                }
                else
                {
                    /*
                    * Look for class to turn on.
                    */
                    for (int iClass = 0; iClass < CharClass.ClassList.Length; iClass++)
                    {
                        if (CharClass.ClassList[iClass].Name.StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
                        {
                            num = iClass;
                            cclass = CharClass.ClassList[iClass];
                            break;
                        }
                    }
                }
            }

            if (cclass == null)
            {
                ch.SendText("No such class.\r\n");
                return;
            }

            string text = String.Format("Class: {0} ({1})  Class Number: &n&+W{2}&n\r\n",
                                       cclass.Name, cclass.WholistName, num);
            string buf1 = text;

            text = String.Format("File: {0}  Prime Attribute: {1}\r\n",
                    cclass.Filename, StringConversion.AffectApplyString(cclass.PrimeAttribute));
            buf1 += text;

            text = String.Format("Save Modifiers: {0} {1} {2} {3} {4}", cclass.SaveModifiers[0], cclass.SaveModifiers[1],
                cclass.SaveModifiers[2], cclass.SaveModifiers[3], cclass.SaveModifiers[4] );

            text = String.Format("Thac0Lvl0: {0}  Thac0Lvl40: {1}  Experience Modifier:  {2}\r\n",
                    MUDString.PadInt(cclass.HitrollLevel0, 5), cclass.HitrollLevel40, cclass.ExperienceModifier);
            buf1 += text;

            text = String.Format("Hp Min/Hp Max: {0}/{1}  Mana: {2}  Weapon: {3}\r\n",
                    cclass.MinHpGain, cclass.MaxHpGain, cclass.GainsMana ? "yes" : "no", cclass.FirstWeapon);
            buf1 += text;

            buf1 += "\r\nSkills available for this class.\r\n";
            buf1 += "Lv          Abilities\r\n";

            for (level = 0; level < Limits.LEVEL_AVATAR; level++)
            {
                foreach (KeyValuePair<String, Skill> kvp in Skill.SkillList)
                {
                    if (kvp.Value.ClassAvailability[num] != level)
                        continue;

                    text = String.Format("&+c{0}:&n {1}\r\n", MUDString.PadInt(level, 2), kvp.Value.Name);
                    buf1 += text;

                }
            }

            buf1 += "\r\nSpells available for this class.\r\n";
            buf1 += "Circle      Spells\r\n";

            for (circle = 0; circle < Limits.MAX_CIRCLE; circle++)
            {
                foreach (KeyValuePair<String, Spell> kvp in Spell.SpellList)
                {
                    if (kvp.Value.SpellCircle[num] != circle)
                        continue;

                    text = String.Format("&+c{0}:&n {1}\r\n", MUDString.PadInt(circle, 2), kvp.Key);
                    buf1 += text;
                }
            }

            realChar.SendText(buf1);
            return;
        }

        /// <summary>
        /// Immortal command to set or display game-wide configuration settings.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void MudConfig(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("world"))
                return;

            if (str.Length == 0)
            {
                ch.SendText("&+L+--------------+----------------------------------------------------------+&n\r\n");
                ch.SendText("&+L|&n&+m   Option&+L     |&n&+r Description&n                                              &+L|&n\r\n");
                ch.SendText("&+L+--------------+----------------------------------------------------------+&n\r\n");

                ch.SendText(Macros.IsSet((int)Database.SystemData.ActFlags, (int)Sysdata.MudFlags.newlock)
                            ? "&+L[&+WX&+L]&n Newlock    &+L|&+c The mud is locked to new players.                        &+L|&n\r\n"
                            : "&+L[ ]&n Newlock    &+L|&+c The mud allows new players.                              &+L|&n\r\n"
                            );
                ch.SendText(Macros.IsSet((int)Database.SystemData.ActFlags, (int)Sysdata.MudFlags.turbolevel)
                            ? "&+L[&+WX&+L]&n Turbolevel &+L|&+c Players get up to 10 levels at a time.                   &+L|&n\r\n"
                            : "&+L[ ]&n Turbolevel &+L|&+c Players level as normal.                                 &+L|&n\r\n"
                            );
                ch.SendText(Macros.IsSet((int)Database.SystemData.ActFlags, (int)Sysdata.MudFlags.equipmentdamage)
                            ? "&+L[&+WX&+L]&n Eqdamage   &+L|&+c Equipment will take damage.                              &+L|&n\r\n"
                            : "&+L[ ]&n Eqdamage   &+L|&+c Equipment is practically indestructible.                 &+L|&n\r\n");
                ch.SendText(Macros.IsSet((int)Database.SystemData.ActFlags, (int)Sysdata.MudFlags.capturetheflag)
                            ? "&+L[&+WX&+L]&n CTF        &+L|&+c Capture the flag is enabled.                             &+L|&n\r\n"
                            : "&+L[ ]&n CTF        &+L|&+c Capture the flag is not enabled.                         &+L|&n\r\n");
                ch.SendText(Macros.IsSet((int)Database.SystemData.ActFlags, (int)Sysdata.MudFlags.equipmentpvp)
                            ? "&+L[&+WX&+L]&n EqPVP      &+L|&+c Equipment effects ability in PvP and stealing (NYI).     &+L|&n\r\n"
                            : "&+L[ ]&n EqPVP      &+L|&+c Equipment doesn't effect PvP and stealing (NYI).         &+L|&n\r\n");
                ch.SendText(Macros.IsSet((int)Database.SystemData.ActFlags, (int)Sysdata.MudFlags.stricteqpvp)
                            ? "&+L[&+WX&+L]&n StrictEQ   &+L|&+c Strict equipment PvP requirements.                       &+L|&n\r\n"
                            : "&+L[ ]&n StrictEQ   &+L|&+c Lenient equipment PvP requirements.                      &+L|&n\r\n");
                ch.SendText(Macros.IsSet((int)Database.SystemData.ActFlags, (int)Sysdata.MudFlags.mobcastslots)
                            ? "&+L[&+WX&+L]&n Mobcast    &+L|&+c Mobs use slots for spellcasting.                         &+L|&n\r\n"
                            : "&+L[ ]&n Mobcast    &+L|&+c Mobs have unlimited spells.                              &+L|&n\r\n");
                ch.SendText(Macros.IsSet((int)Database.SystemData.ActFlags, (int)Sysdata.MudFlags.mobslootplayers)
                            ? "&+L[&+WX&+L]&n Mobloot    &+L|&+c Mobs will loot PC corpses.                               &+L|&n\r\n"
                            : "&+L[ ]&n Mobloot    &+L|&+c Mobs will not loot PC corpses.                           &+L|&n\r\n");
                ch.SendText(Macros.IsSet((int)Database.SystemData.ActFlags, (int)Sysdata.MudFlags.autoprice)
                            ? "&+L[&+WX&+L]&n Autoprice  &+L|&+c The MUD overrides prices set on EQ in the area file.     &+L|&n\r\n"
                            : "&+L[ ]&n Autoprice  &+L|&+c The MUD doesn't override EQ prices in the area file.     &+L|&n\r\n");
                ch.SendText(Macros.IsSet((int)Database.SystemData.ActFlags, (int)Sysdata.MudFlags.walkableocean)
                            ? "&+L[&+WX&+L]&n Walkocean  &+L|&+c Players can walk on the ocean. (NYI)                     &+L|&n\r\n"
                            : "&+L[ ]&n Walkocean  &+L|&+c Players can't travel the ocean without a boat. (NYI).    &+L|&n\r\n");
                ch.SendText(Macros.IsSet((int)Database.SystemData.ActFlags, (int)Sysdata.MudFlags.powerlevel)
                            ? "&+L[&+WX&+L]&n Plevel     &+L|&+c Power leveling is enabled.                               &+L|&n\r\n"
                            : "&+L[ ]&n Plevel     &+L|&+c Power leveling is disabled.                              &+L|&n\r\n");
                ch.SendText(CommandType.fLogAll
                            ? "&+L[&+WX&+L]&n Logall     &+L|&+c The MUD logs every command.                              &+L|&n\r\n"
                            : "&+L[ ]&n Logall     &+L|&+c The MUD does not log all commands.                       &+L|&n\r\n");
                ch.SendText(Macros.IsSet((int)Database.SystemData.ActFlags, (int)Sysdata.MudFlags.candelete)
                            ? "&+L[&+WX&+L]&n Candelete  &+L|&+c Players can delete their characters.                     &+L|&n\r\n"
                            : "&+L[ ]&n Candelete  &+L|&+c Players cannot delete their characters.                  &+L|&n\r\n");
                ch.SendText(Macros.IsSet((int)Database.SystemData.ActFlags, (int)Sysdata.MudFlags.levelrestrictedeq)
                            ? "&+L[&+WX&+L]&n Eqrestrict &+L|&+c Players cannot use equipment 25+ levels above them.      &+L|&n\r\n"
                            : "&+L[ ]&n Eqrestrict &+L|&+c Players can use equipment of any level.                  &+L|&n\r\n");
                ch.SendText(Macros.IsSet((int)Database.SystemData.ActFlags, (int)Sysdata.MudFlags.nameapproval)
                            ? "&+L[&+WX&+L]&n Nameapprove&+L|&+c Players have to wait for name approval.                  &+L|&n\r\n"
                            : "&+L[ ]&n Nameapprove&+L|&+c Players don't have to wait for name approval.            &+L|&n\r\n");
                ch.SendText(Macros.IsSet((int)Database.SystemData.ActFlags, (int)Sysdata.MudFlags.disablemccp)
                            ? "&+L[&+WX&+L]&n DisableMCCP&+L|&+c MCCP is disabled MUD-wide.                               &+L|&n\r\n"
                            : "&+L[ ]&n DisableMCCP&+L|&+c The MUD supports MCCP.                                   &+L|&n\r\n");
                ch.SendText(Macros.IsSet((int)Database.SystemData.ActFlags, (int)Sysdata.MudFlags.disablemsp)
                            ? "&+L[&+WX&+L]&n DisableMSP &+L|&+c The MUD Sound Protocol (MSP) is disabled MUD-wide.       &+L|&n\r\n"
                            : "&+L[ ]&n DisableMSP &+L|&+c The MUD supports MSP.                                    &+L|&n\r\n");
                ch.SendText(Macros.IsSet((int)Database.SystemData.ActFlags, (int)Sysdata.MudFlags.disablefaction)
                            ? "&+L[&+WX&+L]&n Faction    &+L|&+c Faction is disabled.                                     &+L|&n\r\n"
                            : "&+L[ ]&n Faction    &+L|&+c Faction is enabled.                                      &+L|&n\r\n");
                ch.SendText(Macros.IsSet((int)Database.SystemData.ActFlags, (int)Sysdata.MudFlags.checkfactionbit)
                            ? "&+L[&+WX&+L]&n Factionbit &+L|&+c Checking of faction bit on mobs is enabled.              &+L|&n\r\n"
                            : "&+L[ ]&n Factionbit &+L|&+c Checking of faction bit on mobs is disabled.             &+L|&n\r\n");
                ch.SendText(Macros.IsSet((int)Database.SystemData.ActFlags, (int)Sysdata.MudFlags.alwaysequip)
                            ? "&+L[&+WX&+L]&n Alwaysequip&+L|&+c Players always get newbie equipment when they die.       &+L|&n\r\n"
                            : "&+L[ ]&n Alwaysequip&+L|&+c Players over lvl 5 don't get newbie eq after death.      &+L|&n\r\n");

                ch.SendText("&+L+--------------+----------------------------------------------------------+&n\r\n");
                ch.SendText("World save to save sysdata, the fraglist, corpses, and crimes.\r\n");
                ch.SendText("World stat to show mud stats.\r\n");

            }
            else
            {
                string text;
                Sysdata.MudFlags bit;
                bool setting;

                if (str[0][0] == '+')
                {
                    setting = true;
                }
                else if (str[0][0] == '-')
                {
                    setting = false;
                }
                else
                {
                    if (!MUDString.StringsNotEqual(str[0], "save"))
                    {
                        Sysdata.Save();
                        FraglistData.Fraglist.Save();
                        Database.CorpseList.Save();
                        Crime.Save();
                        ch.SendText("Sysdata, Fraglist, Corpses, and Crimes saved.\r\n");
                        return;
                    }

                    if (!MUDString.StringsNotEqual(str[0], "stat"))
                    {
                        ch.SendText(String.Format("Players: {0}  MaxPlayers:    {1}\r\n",
                                        MUDString.PadInt(Database.SystemData.NumPlayers, 5), MUDString.PadInt(Database.SystemData.MaxPlayers, 5)));
                        ch.SendText(String.Format("MaxEver: {0}  Recorded at:   {1}\r\n",
                                       MUDString.PadInt(Database.SystemData.MaxPlayersEver, 5), Database.SystemData.MaxPlayersTime));
                        ch.SendText(String.Format("Mobs:    {0}  MobTemplates:  {1}\r\n",
                                        MUDString.PadInt(CharData.Count, 5), MUDString.PadInt(MobTemplate.Count, 5)));
                        ch.SendText(String.Format("Rooms:   {0}\r\n",
                                        MUDString.PadInt(RoomTemplate.Count, 5), MUDString.PadInt(RoomTemplate.Count, 5)));
                        ch.SendText(String.Format("Objects: {0}  ObjTemplates:  {1}\r\n",
                                        MUDString.PadInt(Object.Count, 5), MUDString.PadInt(ObjTemplate.Count, 5)));
                        ch.SendText(String.Format("Shops:   {0}\r\n",
                                        MUDString.PadInt(Shop.Count, 5)));
                        ch.SendText(String.Format("Traps:   {0}\r\n",
                                        MUDString.PadInt(Trap.Count, 5)));
                        ch.SendText(String.Format("Skills:  {0}\r\n",
                                        MUDString.PadInt(Skill.Count, 5)));
                        ch.SendText(String.Format("Spells:  {0}\r\n",
                                        MUDString.PadInt(Spell.Count, 5)));
                        ch.SendText(String.Format("Resets:  {0}\r\n",
                                        MUDString.PadInt(Reset.Count, 5)));
                        ch.SendText(String.Format("Races:   {0}\r\n",
                                        MUDString.PadInt(Race.Count, 5)));
                        ch.SendText(String.Format("Exits:   {0}\r\n",
                                        MUDString.PadInt(Exit.Count, 5)));
                        ch.SendText(String.Format("Classes: {0}\r\n",
                                        MUDString.PadInt(CharClass.Count, 5)));
                        ch.SendText(String.Format("Areas:   {0}\r\n",
                                        MUDString.PadInt(Area.Count, 5)));
                        ch.SendText(String.Format("Affects: {0}\r\n",
                                        MUDString.PadInt(Affect.Count, 5)));
                        ch.SendText(String.Format("Bounties:{0}\r\n",
                                        MUDString.PadInt(Bounty.Count, 5)));
                        ch.SendText(String.Format("QuestTemplates:   {0}\r\n",
                                        MUDString.PadInt(QuestTemplate.Count, 5)));
                        ch.SendText(String.Format("QuestItems:       {0}\r\n",
                                        MUDString.PadInt(QuestItem.Count, 5)));
                        ch.SendText(String.Format("QuestData:        {0}\r\n",
                                        MUDString.PadInt(QuestData.Count, 5)));

                        Assembly assembly = Assembly.GetExecutingAssembly();
                        AssemblyCopyrightAttribute copyright =
                            (AssemblyCopyrightAttribute)AssemblyCopyrightAttribute.GetCustomAttribute(
                                assembly, typeof(AssemblyCopyrightAttribute));
                        AssemblyTitleAttribute title =
                            (AssemblyTitleAttribute)AssemblyTitleAttribute.GetCustomAttribute(
                                assembly, typeof(AssemblyTitleAttribute));
                        FileInfo info = new FileInfo(assembly.Location);
                        DateTime date = info.LastWriteTime;

                        // Create a bitvector class just so we can get info about the base assembly.
                        Bitvector bv = new Bitvector();
                        string baseName = bv.GetType().Assembly.GetName().Name;
                        string baseVersion = bv.GetType().Assembly.GetName().Version.ToString();
                        FileInfo baseInfo = new FileInfo(bv.GetType().Assembly.Location);
                        DateTime baseDate = baseInfo.LastWriteTime;

                        Spell spell = new Spell();
                        string baseName2 = spell.GetType().Assembly.GetName().Name;
                        string baseVersion2 = spell.GetType().Assembly.GetName().Version.ToString();
                        FileInfo baseInfo2 = new FileInfo(spell.GetType().Assembly.Location);
                        DateTime baseDate2 = baseInfo2.LastWriteTime;

                        string version = title.Title +
                            " version " +
                            assembly.GetName().Version +
                            " built on " +
                            date.ToShortDateString() +
                            ".\r\nBased on version " +
                            baseVersion +
                            " of " +
                            baseName +
                            " built on " +
                            baseDate.ToShortDateString() +
                            ".\r\nBased on version " +
                            baseVersion2 +
                            " of " +
                            baseName2 +
                            " built on " +
                            baseDate2.ToShortDateString() + "\r\n";
                        ch.SendText(version);
                        return;
                    }

                    ch.SendText("World -option or +option?\r\n");
                    ch.SendText("or:        save              \r\n");
                    ch.SendText("or:        stat              \r\n");
                    return;
                }

                string tmparg = str[0];
                if ("newlock".StartsWith(tmparg.Substring(1), StringComparison.CurrentCultureIgnoreCase))
                    bit = Sysdata.MudFlags.newlock;
                else if ("turbolevel".StartsWith(tmparg.Substring(1), StringComparison.CurrentCultureIgnoreCase))
                    bit = Sysdata.MudFlags.turbolevel;
                else if ("eqdamage".StartsWith(tmparg.Substring(1), StringComparison.CurrentCultureIgnoreCase))
                    bit = Sysdata.MudFlags.equipmentdamage;
                else if ("ctf".StartsWith(tmparg.Substring(1), StringComparison.CurrentCultureIgnoreCase))
                    bit = Sysdata.MudFlags.capturetheflag;
                else if ("eqpvp".StartsWith(tmparg.Substring(1), StringComparison.CurrentCultureIgnoreCase))
                    bit = Sysdata.MudFlags.equipmentpvp;
                else if ("mobloot".StartsWith(tmparg.Substring(1), StringComparison.CurrentCultureIgnoreCase))
                    bit = Sysdata.MudFlags.mobslootplayers;
                else if ("walkocean".StartsWith(tmparg.Substring(1), StringComparison.CurrentCultureIgnoreCase))
                    bit = Sysdata.MudFlags.walkableocean;
                else if ("autoprice".StartsWith(tmparg.Substring(1), StringComparison.CurrentCultureIgnoreCase))
                    bit = Sysdata.MudFlags.autoprice;
                else if ("stricteq".StartsWith(tmparg.Substring(1), StringComparison.CurrentCultureIgnoreCase))
                    bit = Sysdata.MudFlags.stricteqpvp;
                else if ("mobcast".StartsWith(tmparg.Substring(1), StringComparison.CurrentCultureIgnoreCase))
                    bit = Sysdata.MudFlags.mobcastslots;
                else if ("plevel".StartsWith(tmparg.Substring(1), StringComparison.CurrentCultureIgnoreCase))
                    bit = Sysdata.MudFlags.powerlevel;
                else if ("eqrestrict".StartsWith(tmparg.Substring(1), StringComparison.CurrentCultureIgnoreCase))
                    bit = Sysdata.MudFlags.levelrestrictedeq;
                else if ("nameapprove".StartsWith(tmparg.Substring(1), StringComparison.CurrentCultureIgnoreCase))
                    bit = Sysdata.MudFlags.nameapproval;
                else if ("candelete".StartsWith(tmparg.Substring(1), StringComparison.CurrentCultureIgnoreCase))
                    bit = Sysdata.MudFlags.candelete;
                else if ("disablemccp".StartsWith(tmparg.Substring(1), StringComparison.CurrentCultureIgnoreCase))
                    bit = Sysdata.MudFlags.disablemccp;
                else if ("disablemsp".StartsWith(tmparg.Substring(1), StringComparison.CurrentCultureIgnoreCase))
                    bit = Sysdata.MudFlags.disablemsp;
                else if ("faction".StartsWith(tmparg.Substring(1), StringComparison.CurrentCultureIgnoreCase))
                    bit = Sysdata.MudFlags.disablefaction;
                else if ("factionbit".StartsWith(tmparg.Substring(1), StringComparison.CurrentCultureIgnoreCase))
                    bit = Sysdata.MudFlags.checkfactionbit;
                else if ("alwaysequip".StartsWith(tmparg.Substring(1), StringComparison.CurrentCultureIgnoreCase))
                    bit = Sysdata.MudFlags.alwaysequip;               
                else
                {
                    ch.SendText("World which option?\r\n");
                    return;
                }

                // Convert to int so we can use SET_BIT.
                int flags = (int)Database.SystemData.ActFlags;
                if (setting)
                {
                    Macros.SetBit(ref flags, (int)bit);
                    text = String.Format("{0} is now ON.\r\n", tmparg);
                    ch.SendText(text.ToUpper());
                }
                else
                {
                    Macros.RemoveBit(ref flags, (int)bit);
                    text = String.Format("{0} is now OFF.\r\n", tmparg);
                    ch.SendText(text.ToUpper());
                }
                // Store modified value in our act flags.
                Database.SystemData.ActFlags = (Sysdata.MudFlags)flags;

            }

            return;
        }

        /// <summary>
        /// Fog: Immortal command to turn combat vulnerability on or off.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Fog(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch.IsNPC())
            {
                return;
            }
            if (!ch.Authorized("fog"))
            {
                return;
            }
            ch.ToggleActBit(PC.PLAYER_FOG);
            if (ch.HasActBit(PC.PLAYER_FOG))
            {
                ch.SendText("Fog is now on.\r\n");
            }
            else
            {
                ch.SendText("Fog is now off.\r\n");
            }
            return;
        }

        /// <summary>
        /// Attempts to engage an opponent in combat.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Kill(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch.IsAffected(Affect.AFFECT_HOLD) || ch.IsAffected(Affect.AFFECT_MINOR_PARA))
            {
                ch.SendText("You can't move!\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Kill whom?\r\n");
                return;
            }

            CharData victim = ch.GetCharRoom(str[0]);
            if (!victim)
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (victim == ch)
            {
                ch.SendText("Don't be a moron.\r\n");
                return;
            }

            ch.AttackCharacter(victim);
        }

        public static void Backstab(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (!ch.HasSkill("backstab"))
            {
                ch.SendText("You better leave the assassination trade to those more skilled.\r\n");
                return;
            }

            if (ch.IsBlind())
            {
                return;
            }

            if (ch._riding)
            {
                ch.SendText("You can't get close enough while mounted.\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Backstab whom?\r\n");
                return;
            }

            CharData victim = ch.GetCharRoom(str[0]);
            if (!victim)
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (victim == ch)
            {
                ch.SendText("How can you sneak up on yourself?\r\n");
                return;
            }

            Combat.Backstab(ch, victim);
            return;
        }

        public static void Circle(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;

            /* Verify that ch can circle. */
            if (!ch.IsNPC() && !ch.HasSkill("circle"))
            {
                ch.SendText("You'd better leave the assassination trade to those more skilled.\r\n");
                return;
            }

            /* No charmies or NPC's are allowed to circle. */
            if (ch.IsNPC() && ch.IsAffected(Affect.AFFECT_CHARM))
            {
                return;
            }

            /* Yeah, gallop around them without them noticing. */
            if (ch._riding)
            {
                ch.SendText("You can't circle while mounted.\r\n");
                return;
            }

            /* Find the unlucky soul. */
            if (str.Length == 0)
            {
                victim = ch._fighting;
            }
            else
            {
                if (!(victim = ch.GetCharRoom(str[0])))
                {
                    ch.SendText("They aren't here.\r\n");
                    return;
                }
            }

            /* No target. */
            if (!victim)
            {
                ch.SendText("Circle who?\r\n");
                return;
            }

            /* Run around yourself? Ok. */
            if (victim == ch)
            {
                ch.SendText("You spin around in a circle.  Whee!\r\n");
                return;
            }

            /* Check for protection of victim. */
            victim = Combat.CheckGuarding(ch, victim);
            if (Combat.IsSafe(ch, victim))
            {
                return;
            }

            // is_safe could wipe out victim, as it calls procs if a boss
            // check and see that victim is still valid
            if (!victim)
            {
                return;
            }

            /* Check if someone is attacking ch. */
            CharData roomChar = null;
            foreach (CharData irch in ch._inRoom.People)
            {
                if (irch._fighting == ch)
                {
                    roomChar = irch;
                    break;
                }
            }
            if (roomChar)
            {
                ch.SendText("You're too busy being hit right now.\r\n");
                return;
            }

            Object obj = Object.GetEquipmentOnCharacter(ch, ObjTemplate.WearLocation.hand_one);
            if (!obj || obj.Values[3] != 11)
            {
                ch.SendText("You need to wield a piercing weapon.\r\n");
                return;
            }

            SocketConnection.Act("You circle around behind $N&n...", ch, null, victim, SocketConnection.MessageTarget.character);
            SocketConnection.Act("$n&n circles around behind $N&n...", ch, null, victim, SocketConnection.MessageTarget.room_vict);

            Crime.CheckAttemptedMurder(ch, victim);
            ch.WaitState(Skill.SkillList["circle"].Delay);

            if (ch.IsNPC() || MUDMath.NumberPercent() < ((PC)ch).SkillAptitude["circle"] +
                    ch.GetCurrAgi() - victim.GetCurrAgi())
            {
                /* Don't always switch. */
                if (MUDMath.NumberPercent() < 40)
                {
                    Combat.StopFighting(victim, false);
                }
                Combat.SingleAttack(ch, victim, "circle", ObjTemplate.WearLocation.hand_one);
            }
            else
            {
                SocketConnection.Act("You failed to get around $M!", ch, null, victim, SocketConnection.MessageTarget.character);
            }

            ch.PracticeSkill("circle");

            return;
        }

        /// <summary>
        /// Flee: Attempt to run away from combat.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Flee(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int attempt;
            int chances;

            if (ch._position < Position.reclining || ch._wait > 0)
            {
                return;
            }

            // Remove memorization and meditation bits - Xangis
            if (!ch.IsNPC() && ch.HasActBit(PC.PLAYER_MEDITATING))
            {
                SocketConnection.Act("$N&n is disrupted from meditation.", ch, null, null, SocketConnection.MessageTarget.room);
                SocketConnection.Act("Your meditation is disrupted.", ch, null, null, SocketConnection.MessageTarget.character);
                ch.RemoveActBit(PC.PLAYER_MEDITATING);
            }
            if (!ch.IsNPC() && ch.HasActBit(PC.PLAYER_MEMORIZING))
            {
                SocketConnection.Act("$N&n abandons $S studies.", ch, null, null, SocketConnection.MessageTarget.room);
                SocketConnection.Act("You abandon your studies.", ch, null, null, SocketConnection.MessageTarget.character);
                ch.RemoveActBit(PC.PLAYER_MEMORIZING);
            }

            if (ch._position < Position.fighting)
            {
                ch.SendText("You scramble madly to your feet!\r\n");
                SocketConnection.Act("$n&n scrambles madly to $s feet!",
                     ch, null, null, SocketConnection.MessageTarget.room);
                ch._position = Position.standing;
                return;
            }

            if (!ch._inRoom)
            {
                ch.SendText("You give up when you realize there's nowhere to flee to.\r\n");
            }

            // Panicked people can flee when not fighting.
            CharData victim = ch._fighting;
            if (!victim)
            {
                if (ch._position == Position.fighting)
                {
                    ch._position = Position.standing;
                }
            }

            if (ch.IsAffected(Affect.AFFECT_BERZERK))
            {
                ch.SendText("You can't flee, you're in a &+RBl&n&+ro&+Ro&n&+rd&+L Rage&n!!\r\n");
                return;
            }

            if (ch.IsAffected( Affect.AFFECT_BOUND))
            {
                ch.SendText("You are bound!  You can't move!\r\n");
                SocketConnection.Act("$n&n tries to flee, but is tied up!",
                     ch, null, null, SocketConnection.MessageTarget.room);
                return;
            }

            if (ch.IsAffected( Affect.AFFECT_HOLD) ||
                    ch.IsAffected( Affect.AFFECT_MINOR_PARA))
            {
                ch.SendText("You can't move!\r\n");
                SocketConnection.Act("$n&n tries to flee, but $e can't move!",
                     ch, null, null, SocketConnection.MessageTarget.room);
                return;
            }

            // You should almost always be able to flee when not fighting.
            if (ch._position == Position.standing)
            {
                chances = 30;
            }
            else
            {
                chances = 6;
            }

            Room wasIn = ch._inRoom;
            for (attempt = 0; attempt < chances; attempt++)
            {
                Exit exit;

                int door = Database.RandomDoor();
                if ((exit = wasIn.ExitData[door]) == null || !exit.TargetRoom
                        || exit.TargetRoom == wasIn || exit.HasFlag(Exit.ExitFlag.closed)
                        || (ch.IsNPC() && (Room.GetRoom(exit.IndexNumber).HasFlag(RoomTemplate.ROOM_NO_MOB)
                        || (ch.HasActBit(MobTemplate.ACT_STAY_AREA) && exit.TargetRoom.Area != ch._inRoom.Area))))
                {
                    continue;
                }

                if (ch._riding && ch._riding._fighting)
                {
                    Combat.StopFighting(ch._riding, true);
                }

                // Just to keep the damned messages from being wacky...
                ch.SetAffBit(Affect.AFFECT_IS_FLEEING);
                ch.Move(door);
                ch.RemoveAffect(Affect.AFFECT_IS_FLEEING);
                if (ch._inRoom == wasIn)
                {
                    break;
                }
                Room nowIn = ch._inRoom;
                ch._inRoom = wasIn;

                SocketConnection.Act("$n&n panics and attempts to flee...", ch, null, null, SocketConnection.MessageTarget.room, true);
                string text;
                if (ch.CheckSneak())
                {
                    SocketConnection.Act("$n&n has fled!", ch, null, null, SocketConnection.MessageTarget.room);
                }
                else
                {
                    text = String.Format("$n&n flees {0}ward.", Exit.DirectionName[door]);
                    SocketConnection.Act(text, ch, null, null, SocketConnection.MessageTarget.room, true);
                }
                ch._inRoom = nowIn;

                text = String.Format("You flee {0}ward!\r\n", Exit.DirectionName[door]);
                ch.SendText(text);

                Combat.StopFighting(ch, true);
                return;
            }

            SocketConnection.Act("$n&n tries to flee but can't make it out of here!", ch, null, null, SocketConnection.MessageTarget.room, true);
            ch.SendText("&+WYour escape is blocked!\r\n");
            return;
        }

        public static void Berzerk(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Affect af = new Affect();

            /* Don't allow charmed mobs to do this, check player's level */
            if ((ch.IsNPC() && ch.IsAffected( Affect.AFFECT_CHARM))
                    || (!ch.IsNPC() && !ch.HasSkill("berzerk")))
            {
                ch.SendText("You're not enough of a warrior to enter a &+RBl&n&+ro&+Ro&n&+rd&+L Rage&n.\r\n");
                return;
            }

            if (ch.IsAffected(Affect.AFFECT_BERZERK))
            {
                if (MUDMath.NumberPercent() + 10 > ((PC)ch).SkillAptitude["berzerk"])
                {
                    ch.SendText("You failed to calm yourself down!\r\n");
                    ch.WaitState(Skill.SkillList["berzerk"].Delay);
                    return;
                }
                ch.SendText("You no longer see targets everywhere.\r\n");
                ch.RemoveAffect(Affect.AFFECT_BERZERK);
                ch.WaitState(Skill.SkillList["berzerk"].Delay);
                return;
            }

            ch.SendText("Your slam your weapon into yourself and &+Rbl&n&+ro&+Ro&n&+rd&n splatters all over!\r\n");
            ch.SendText("The sight of &+Rbl&n&+ro&+Ro&n&+rd&n begins to drive you crazy!\r\n");

            if (ch.CheckSkill("berzerk"))
            {
                af.Value = "berzerk";
                af.Type = Affect.AffectType.skill;
                af.Duration = MUDMath.Dice(1, 2);
                af.AddModifier( Affect.Apply.hitroll, Math.Max(ch._level / 6, 2));
                af.AddModifier( Affect.Apply.damroll, Math.Max(ch._level / 6, 2));
                af.AddModifier( Affect.Apply.ac, (ch._level / 2));
                af.AddModifier( Affect.Apply.max_constitution, MUDMath.Dice(5, 9));
                af.AddModifier( Affect.Apply.agility, 0 - MUDMath.Dice(5, 9));
                af.AddModifier( Affect.Apply.max_strength, MUDMath.Dice(5, 9));
                af.SetBitvector(Affect.AFFECT_BERZERK);
                ch.AddAffect(af);

                ch.SendText("You are overcome by &+RBl&n&+ro&+Ro&n&+rd&+L Rage&n!!\r\n");
                SocketConnection.Act("$n has slipped into a &+RBl&n&+ro&+Ro&n&+rd&+L Rage&n!!", ch, null, null, SocketConnection.MessageTarget.room);

                return;
            }
            ch.SendText("You get a little angry, but fail to call up a &+Rblood rage&n.\r\n");

            return;
        }

        /// <summary>
        /// Rescue command.  Interpose yourself between the target and their opponent so you become
        /// the one taking damage.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Rescue(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;

            /* Don't allow the unskilled to rescue */
            if ((!ch.HasSkill("rescue")))
            {
                ch.SendText("You'd better leave the heroic acts to warriors.\r\n");
                return;
            }

            if (ch.IsAffected(Affect.AFFECT_BERZERK))
            {
                ch.SendText("You can't rescue anyone, you're in a &+RBl&n&+ro&+Ro&n&+rd&+L Rage&n!!\r\n");
                return;
            }

            if (ch._riding)
            {
                ch.SendText("You can't do that while mounted.\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Rescue whom?\r\n");
                return;
            }

            if (!(victim = ch.GetCharRoom(str[0])))
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (victim == ch)
            {
                ch.SendText("What about fleeing instead?\r\n");
                return;
            }

            if (ch._fighting == victim)
            {
                ch.SendText("Too late.\r\n");
                return;
            }

            if (!victim._fighting)
            {
                ch.SendText("That person is not fighting right now.\r\n");
                return;
            }

            if (ch.IsBlind())
            {
                return;
            }

            ch.WaitState(Skill.SkillList["rescue"].Delay);

            int count = 0;
            CharData fch = null;
            foreach (CharData ifch in ch._inRoom.People)
            {
                if (ifch._fighting == victim)
                {
                    if (MUDMath.NumberRange(0, count) == 0)
                    {
                        fch = ifch;
                        break;
                    }
                    ++count;
                }
            }

            if (!fch || !ch.CheckSkill("rescue"))
            {
                SocketConnection.Act("$n&n fails miserably in $s attempt to rescue $N&n.", ch, null, victim, SocketConnection.MessageTarget.room_vict);
                SocketConnection.Act("$n&n fails miserably in $s attempt to rescue you.", ch, null, victim, SocketConnection.MessageTarget.victim);
                SocketConnection.Act("You fail in your attempt to rescue $N&n.", ch, null, victim, SocketConnection.MessageTarget.character);
                return;
            }

            SocketConnection.Act("&+WYou leap in front of $N&n!", ch, null, victim, SocketConnection.MessageTarget.character);
            SocketConnection.Act("&+W$n&+W rescues you!", ch, null, victim, SocketConnection.MessageTarget.victim);
            SocketConnection.Act("&+w$n&+w leaps in front of $N&+w taking his place in battle!&n", ch, null, victim, SocketConnection.MessageTarget.room_vict);

            Combat.StopFighting(fch, false);
            Combat.StopFighting(victim, false);

            Combat.SetFighting(fch, ch);
            if (!ch._fighting)
            {
                Combat.SetFighting(ch, fch);
            }
            return;
        }

        public static void Kick(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string arg1 = String.Empty;
            int chance;
            int wallkickchance;

            /* Check player's level and class, allow mobs to do this too */
            if ((!ch.HasSkill("kick")))
            {
                ch.SendText("You'd better leave the martial arts to fighters.\r\n");
                return;
            }

            if (ch.IsBlind() && !ch._fighting)
            {
                return;
            }

            CharData victim = ch._fighting;

            if (str.Length != 0)
            {
                victim = ch.GetCharRoom(str[0]);
                if (!victim || victim._position == Position.dead)
                {
                    ch.SendText("They aren't here.\r\n");
                    return;
                }
            }
            else
            {
                if (!victim || victim._position == Position.dead)
                {
                    ch.SendText("You aren't fighting anyone.\r\n");
                    return;
                }
            }

            if (victim == ch)
            {
                ch.SendText("You kick yourself for being a dummy.\r\n");
                return;
            }

            ch.WaitState(MUDMath.FuzzyNumber(Skill.SkillList["kick"].Delay));

            if (!ch.IsNPC())
            {
                chance = ((PC)ch).SkillAptitude["kick"];
                ch.PracticeSkill("kick");
            }
            else
            {
                chance = ch._level * 3 / 2 + 20;
            }
            // It's much harder to kick really tiny things; imagine trying to kick
            // a fly.
            if (ch._size > victim._size + 5)
            {
                chance -= (ch._size - victim._size) * 5;
            }

            // It's harder to kick things that move faster than you.
            chance += ((ch.GetCurrAgi() - victim.GetCurrAgi()) / 5);

            // Huge bonus against incapacitated and mortally wounded foes.
            if (victim._position <= Position.incapacitated)
            {
                chance += 50;
            }
            
            // Damned high penalty for kicking blind
            if (ch.IsAffected(Affect.AFFECT_BLIND) && !victim.IsAffected(Affect.AFFECT_BLIND))
            {
                chance /= 10;
            }
            if (ch.IsAffected(Affect.AFFECT_BLIND) && victim.IsAffected(Affect.AFFECT_BLIND))
            {
                chance /= 4;
            }

            // If the victim is two or more sizes smaller than the kicker give them a chance
            // to be kicked into a wall or out of the room.
            //
            // Chance of 5% per size class difference, no maximum
            // (wall/room kick is 50% at a difference of 10 sizes)
            if (victim._size - 1 >= ch._size)
            {
                wallkickchance = 0;
            }
            else
            {
                wallkickchance = ((ch._size - victim._size) * 5) - 5;
            }

            // Check for kick success
            if (MUDMath.NumberPercent() < chance)
            {
                /* Check for wall kick. */
                /* to be kicked out of the room (random direction). */
                if (MUDMath.NumberPercent() < wallkickchance)
                {
                    // Let immortals choose the direction to kick the victim
                    int door;
                    bool valid = Int32.TryParse(arg1, out door);
                    if (!ch.IsImmortal() || !valid || door >= Limits.MAX_DIRECTION)
                    {
                        door = Database.RandomDoor();
                    }

                    // Check for valid room stuff on victim
                    Room kickedInto;
                    if (victim && victim._inRoom && victim._inRoom.ExitData != null
                            && victim._inRoom.ExitData[door]
                            && victim._inRoom.ExitData[door].TargetRoom
                            && victim._inRoom.ExitData[door].ExitFlags != 0
                            && !victim._inRoom.ExitData[door].HasFlag(Exit.ExitFlag.secret)
                            && !victim._inRoom.ExitData[door].HasFlag(Exit.ExitFlag.blocked)
                            && !victim._inRoom.ExitData[door].HasFlag(Exit.ExitFlag.walled)
                            && !victim._inRoom.ExitData[door].HasFlag(Exit.ExitFlag.closed)
                            && !Room.GetRoom(victim._inRoom.ExitData[door].IndexNumber).IsPrivate()
                            && victim._inRoom.ExitData[door].TargetRoom.TerrainType != TerrainType.underground_impassable
                            && (kickedInto = Room.GetRoom(victim._inRoom.ExitData[door].IndexNumber)))
                    {
                        Combat.StopFighting(victim, true);
                        string buf = String.Format("$N&n is sent flying out of the room {0}ward by $n&n's mighty kick.", Exit.DirectionName[door]);
                        SocketConnection.Act(buf, ch, null, victim, SocketConnection.MessageTarget.room_vict);
                        buf = String.Format("$N&n is sent flying out of the room {0}ward by your mighty kick.", Exit.DirectionName[door]);
                        SocketConnection.Act(buf, ch, null, victim, SocketConnection.MessageTarget.character);
                        SocketConnection.Act("You are sent flying out of the room by $n's mighty kick!", ch, null, victim, SocketConnection.MessageTarget.victim);
                        victim.RemoveFromRoom();
                        victim.AddToRoom(kickedInto);

                        SocketConnection.Act("$n&n is stunned!", victim, null, null, SocketConnection.MessageTarget.room);
                        victim.SendText("You are stunned!\r\n");
                        victim.WaitState((Skill.SkillList["kick"].Delay * 9) / 10);
                        if (victim._position > Position.resting)
                        {
                            victim._position = Position.resting;
                        }
                    }
                    else
                    {
                        // If no exit in our chosen direction, must be a wall.
                        SocketConnection.Act("$N&n is sent flying into the wall by $n&n's mighty kick.", ch, null, victim, SocketConnection.MessageTarget.room_vict);
                        SocketConnection.Act("$N&n is sent flying into the wall by your mighty kick.", ch, null, victim, SocketConnection.MessageTarget.character);
                        SocketConnection.Act("You are smacked into the wall by $n's mighty kick!", ch, null, victim, SocketConnection.MessageTarget.victim);
                        if (victim._position > Position.resting)
                        {
                            victim._position = Position.resting;
                        }
                        // At least a two second stun
                        victim.WaitState(8);
                        /* Check for stunning victim. */
                        if ((MUDMath.NumberPercent() * 2) > victim.GetCurrAgi())
                        {
                            SocketConnection.Act("$N&n is stunned!", ch, null, victim, SocketConnection.MessageTarget.room_vict);
                            victim.SendText("You are stunned!\r\n");
                            victim.WaitState((Skill.SkillList["kick"].Delay * 9) / 10);
                        }
                        else
                        {
                            victim.WaitState(1);
                        }
                    }
                    // Do excessive damage compared to a normal kick
                    Combat.InflictDamage(ch, victim, MUDMath.Dice(2, ch._level), String.Empty, ObjTemplate.WearLocation.none, AttackType.DamageType.bludgeon);

                } // Check for wall kick (execute regular kick)
                else
                {
                    Combat.InflictDamage(ch, victim, MUDMath.NumberRange(1, ch._level), "kick", ObjTemplate.WearLocation.none, AttackType.DamageType.bludgeon);
                }
            } // Check for successful kick (missed kick)
            else
            {
                Combat.InflictDamage(ch, victim, 0, "kick", ObjTemplate.WearLocation.none, AttackType.DamageType.bludgeon);
            }

            return;
        }

        /// <summary>
        /// Bash. Usable to initiate combat and during combat.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Bash(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int chance;

            /* Check player's level and class, mobs can use this skill */
            if ((!ch.HasSkill("bash")))
            {
                ch.SendText("You'd better leave that to those with more skills.\r\n");
                return;
            }

            if (ch.IsBlind() && !ch._fighting)
            {
                return;
            }

            /* Verify a target. */
            CharData victim = ch._fighting;
            if (str.Length != 0)
            {
                victim = ch.GetCharRoom(str[0]);
                if (!victim || victim._position == Position.dead)
                {
                    ch.SendText("They aren't anywhere to be found.\r\n");
                    return;
                }
            }
            else
            {
                if (!victim || victim._position == Position.dead)
                {
                    ch.SendText("You aren't fighting anyone.\r\n");
                    return;
                }
            }

            /* Bash self? Ok! */
            // Toned down the damage cuz you can't really bash yourself
            // like you could with someone else.
            if (victim == ch)
            {
                ch.SendText("You throw yourself to the ground!\r\n");
                SocketConnection.Act("$N&n knocks $mself to the ground.", ch, null, victim, SocketConnection.MessageTarget.room_vict);
                ch._position = Position.kneeling;
                ch.WaitState((Skill.SkillList["bash"].Delay * 8) / 10);
                Combat.InflictDamage(ch, ch, MUDMath.NumberRange(1, 3), "bash", ObjTemplate.WearLocation.none,
                        AttackType.DamageType.bludgeon);
                return;
            }

            /* Check size of ch vs. victim. */
            /* If ch is too small. */
            if (ch._size < victim._size)
            {
                SocketConnection.Act("$N&n is too big for you to bash!", ch, null, victim, SocketConnection.MessageTarget.character);
                return;
            }
            /* Ch 2 or more sizes larger than victim => bad! */
            if (ch._size - 2 > victim._size)
            {
                SocketConnection.Act("You nearly topple over as you try to bash $N&n.", ch, null, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n nearly topples over as $e attempts to bash you.", ch, null, victim, SocketConnection.MessageTarget.victim);
                SocketConnection.Act("$n&n nearly topples over as $e attempts to bash $N&n.", ch, null, victim, SocketConnection.MessageTarget.room_vict);
                ch.WaitState((Skill.SkillList["bash"].Delay));
                ch._position = Position.kneeling;
                if (victim._fighting == null)
                {
                    Combat.SetFighting(victim, ch);
                }
                return;
            }

            /* Lag to basher from bash. Pets get more lag because pets are cheesy */
            if (!ch.IsNPC())
            {
                ch.WaitState(MUDMath.FuzzyNumber(Skill.SkillList["bash"].Delay));
            }
            else
            {
                ch.WaitState((Skill.SkillList["bash"].Delay * 6 / 5));
            }

            /* Base chance to bash, followed by chance modifications. */
            if (ch.IsNPC())
            {
                chance = (ch._level * 3) / 2 + 15;
            }
            else
            {
                chance = ((PC)ch).SkillAptitude["bash"] - 5;
            }

            if (victim._position < Position.fighting)
            {
                chance /= 5; //used to be 0
            }
            else
            {
                chance += ch.GetCurrAgi() - victim.GetCurrAgi();
            }

            if (chance > 95)
            {
                chance = 95;
            }

            Object obj = Object.GetEquipmentOnCharacter(ch, ObjTemplate.WearLocation.hand_one);
            if (!obj)
            {            /* No primary item. */
                if (!(obj = Object.GetEquipmentOnCharacter(ch, ObjTemplate.WearLocation.hand_two)))
                {          /* No items in hand. */
                    if (!ch.IsClass(CharClass.Names.paladin) && !ch.IsClass(CharClass.Names.antipaladin))
                    {
                        if (!ch.IsClass(CharClass.Names.warrior))
                        {
                            chance -= 25;
                        }
                        else
                        {
                            chance -= 20;
                        }
                        ch.SendText("You lower your shoulder and attempt to bash without a shield...\r\n");
                    }
                    else
                    {
                        chance -= 3; // Hidden penalty for not having a shield
                    }
                }
                else if (obj.ItemType != ObjTemplate.ObjectType.shield)
                {          /* Secondary item isn't a shield, no primary. */
                    if (!ch.IsClass(CharClass.Names.paladin) && !ch.IsClass(CharClass.Names.antipaladin))
                    {
                        if (!ch.IsClass(CharClass.Names.warrior))
                        {
                            chance -= 25;
                        }
                        else
                        {
                            chance -= 20;
                        }
                        ch.SendText("Bashing without a shield is tough, but you try anyway...\r\n");
                    }
                    else
                    {
                        chance -= 5; // Small hidden penalty for not having a shield
                    }
                }          /* Secondary item is a shield, no primary. */
                else if (ch.IsClass(CharClass.Names.paladin) || ch.IsClass(CharClass.Names.antipaladin))
                {
                    chance += 3; // Small hidden bonus for having a shield
                }
            }
            else if (obj.ItemType != ObjTemplate.ObjectType.shield)
            {            /* Primary item isn't a shield. */
                if (!(obj = Object.GetEquipmentOnCharacter(ch, ObjTemplate.WearLocation.hand_two)))
                {          /* No secondary. */
                    if (!ch.IsClass(CharClass.Names.paladin) && !ch.IsClass(CharClass.Names.antipaladin))
                    {
                        if (!ch.IsClass(CharClass.Names.warrior))
                        {
                            chance -= 25;
                        }
                        else
                        {
                            chance -= 20;
                        }
                        ch.SendText("Without a shield, bashing is a wistful thought, but you try anyway...\r\n");
                    }
                    else
                    {
                        chance -= 5; // Hidden penalty for not having a shield
                    }
                }
                else if (obj.ItemType != ObjTemplate.ObjectType.shield)
                {          /* Secondary item is not a shield. */
                    if (!ch.IsClass(CharClass.Names.paladin) && !ch.IsClass(CharClass.Names.antipaladin))
                    {
                        if (!ch.IsClass(CharClass.Names.warrior))
                        {
                            chance -= 25;
                        }
                        else
                        {
                            chance -= 20;
                        }
                        ch.SendText("Without a shield, your shoulder bash is but wishful thinking...\r\n");
                    }
                    else
                    {
                        chance -= 5; // Hidden penalty for not having a shield
                    }
                }
                else if (ch.IsClass(CharClass.Names.paladin) || ch.IsClass(CharClass.Names.antipaladin))
                {          /* Secondary is a shield. */
                    chance += 3; // Small hidden bonus for having a shield
                }
                else if (ch.IsClass(CharClass.Names.ranger))
                {
                    chance -= 8;
                }
                else if (ch.IsClass(CharClass.Names.warrior))
                {
                    chance -= 5;
                }
            }

            // Centaurs are awful damned hard to bash -- Xangis
            if (victim.GetRace() == Race.RACE_CENTAUR)
            {
                chance -= 25;
            }

            // damned high penalty for bashing blind
            if (ch.IsAffected(Affect.AFFECT_BLIND) && !victim.IsAffected(Affect.AFFECT_BLIND))
            {
                chance /= 10;
            }
            if (ch.IsAffected(Affect.AFFECT_BLIND) && victim.IsAffected(Affect.AFFECT_BLIND))
            {
                chance /= 4;
            }

            ch.PracticeSkill("bash");

            /* Start a fight if not already in one. */
            if (ch != victim)
            {
                if (!ch._fighting)
                {
                    Combat.SetFighting(ch, victim);
                }
                if (!victim._fighting)
                {
                    Combat.SetFighting(victim, ch);
                }
            }

            string lbuf = "Bash: " + ch._name + " bashing " + victim._name + " with " + chance + " chance.";
            ImmortalChat.SendImmortalChat(null, ImmortalChat.IMMTALK_SPAM, 0, lbuf);

            /* Do the bash, deal the damage. */
            if (MUDMath.NumberPercent() < chance)
            {
                /* Hit the bash. */
                if (victim.IsAffected(Affect.AFFECT_SINGING))
                {
                    victim.RemoveAffect(Affect.AFFECT_SINGING);
                    SocketConnection.Act("$n&n chokes on a note and falls silent as $e slams into the ground!", victim, null, null, SocketConnection.MessageTarget.room);
                    victim.SendText("You abort your singing!\r\n");
                }
                if (victim.IsAffected(Affect.AFFECT_CASTING))
                {
                    victim.RemoveAffect(Affect.AFFECT_CASTING);
                    SocketConnection.Act("$n&n's eyes roll back in $s head and $e forgets all about $s spell.", victim, null, null, SocketConnection.MessageTarget.room);
                    victim.SendText("Being knocked over so forcefully makes it hard to cast.\r\n");
                }
                if (!Combat.CheckTumble(victim))
                {
                    victim.WaitState(((Skill.SkillList["bash"].Delay * 5) / 6));
                    if (victim._position > Position.kneeling)
                    {
                        victim._position = Position.kneeling;
                    }
                    victim.SendText("You are knocked to the ground!\r\n");
                    Combat.InflictDamage(ch, victim, MUDMath.NumberRange(1, ch._level), "bash", ObjTemplate.WearLocation.none, AttackType.DamageType.bludgeon);
                }
                else
                {
                    Combat.InflictDamage(ch, victim, MUDMath.NumberRange(1, (ch._level / 3)), "bash", ObjTemplate.WearLocation.none, AttackType.DamageType.bludgeon);
                    victim.SendText("You roll with the blow, finally landing on your feet.\r\n");
                    SocketConnection.Act("$n&n rolls with the blow, finally landing on $s feet.", victim, null, null, SocketConnection.MessageTarget.room);
                }
            }
            else
            { /* Miss the bash. */
                SocketConnection.Act("As $N&n avoids your bash, you topple to the &n&+yground&n with a loud crash.", ch, null, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n crashes to the &n&+yground&n as you sidestep $s bash.", ch, null, victim, SocketConnection.MessageTarget.victim);
                SocketConnection.Act("$n&n misses $s bash at $N&n and is driven to the &n&+yground&n.", ch, null, victim, SocketConnection.MessageTarget.room_vict);
                ch._position = Position.kneeling;
            }

            return;
        }

        /// <summary>
        /// Attempt to trip a foe.  Can initiate combat with this and can use during combat.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Trip(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int chance;

            /* Check player's level and class, mobs can use this skill */
            if ((!ch.HasSkill("trip")))
            {
                ch.SendText("You would just fall over if you tried to trip someone.\r\n");
                return;
            }

            if (ch.IsBlind())
            {
                return;
            }

            CharData victim = ch._fighting;

            if (str.Length != 0)
            {
                victim = ch.GetCharRoom(str[0]);
                if (!victim)
                {
                    ch.SendText("You look around, unable to find them.\r\n");
                    return;
                }
            }
            else
            {
                if (!victim)
                {
                    ch.SendText("You aren't fighting anyone.\r\n");
                    return;
                }
            }

            /* anti 'trip me' code */
            if (victim == ch)
            {
                ch.SendText("You don't think you're clumsy enough already?\r\n");
                return;
            }

            ch.WaitState(MUDMath.FuzzyNumber(Skill.SkillList["trip"].Delay));
            ch.PracticeSkill("trip");

            if (ch.IsNPC())
            {
                chance = (ch._level * 3) / 2 + 10;
            }
            else
            {
                chance = ((PC)ch).SkillAptitude["trip"];
            }

            if (chance > 90)
            {
                chance = 90;
            }

            if ((ch._fighting == null) && (ch != victim))
            {
                Combat.SetFighting(ch, victim);
            }
            if ((!victim._fighting) && (victim != ch))
            {
                Combat.SetFighting(victim, ch);
            }

            /* Mobs do NOT auto-trip! */
            if (MUDMath.NumberPercent() < chance)
            {
                victim.WaitState((Skill.SkillList["trip"].Delay * 5 / 6));
                SocketConnection.Act("You trip $N&n and send $M sprawling to the &n&+yearth&n!", ch, null, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n trips you and you go down!", ch, null, victim, SocketConnection.MessageTarget.victim);
                SocketConnection.Act("$n&n trips $N&n and $E falls face-first to the &n&+yground&n!", ch, null, victim, SocketConnection.MessageTarget.room_vict);
                if (victim._position > Position.reclining)
                {
                    victim._position = Position.reclining;
                }
            }
            else
            {
                SocketConnection.Act("You try to trip $N&n and fall down!", ch, null, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n attempts to knock you from your feet, and falls down $sself!", ch, null, victim, SocketConnection.MessageTarget.victim);
                SocketConnection.Act("$n&n tries to trip $N&n and tumbles to the &n&+yground&n!", ch, null, victim, SocketConnection.MessageTarget.room_vict);
                ch._position = Position.reclining;
            }

            return;
        }

        /// <summary>
        /// Springleap.  Can be used to initiate combat and can be used during combat.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Springleap(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int chance;

            /* Check player's level and class, mobs can use this skill */
            if ((!ch.HasSkill("springleap")))
            {
                ch.SendText("You'd better leave the martial arts to Bruce Lee.\r\n");
                return;
            }

            if (ch.GetRace() == Race.RACE_CENTAUR)
            {
                ch.SendText("Your anatomy prevents you from springleaping.\r\n");
                return;
            }

            if (ch.IsBlind())
            {
                return;
            }

            CharData victim = ch._fighting;

            if (str.Length != 0)
            {
                if (!(victim = ch.GetCharRoom(str[0])) || victim._position == Position.dead)
                {
                    ch.SendText("You don't see them here.\r\n");
                    return;
                }
            }
            else
            {
                if (!victim || victim._position == Position.dead)
                {
                    ch.SendText("You aren't fighting anyone.\r\n");
                    return;
                }
            }

            /* springleap self */
            if (ch == victim)
            {
                ch.SendText("You can't quite figure out how to do that.\r\n");
                return;
            }

            /* Check size of ch vs. victim. */
            /* If ch is too small. */
            if (ch._size - 2 > victim._size)
            {
                SocketConnection.Act("Your acrobatic maneuver cannot accurately leap into such a small being.", ch, null, victim, SocketConnection.MessageTarget.character);
                return;
            }
            /* Ch 2 or more sizes larger than victim => bad! */
            if (ch._size + 2 < victim._size)
            {
                SocketConnection.Act("Your acrobatic maneuver does not seem to work on someone so large.", ch, null, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n jumps into you, and slides down your leg.", ch, null, victim, SocketConnection.MessageTarget.victim);
                SocketConnection.Act("$n&n jumps into $N&n and slides down $S leg.", ch, null, victim, SocketConnection.MessageTarget.room_vict);

                ch.WaitState(Skill.SkillList["springleap"].Delay);
                ch._position = Position.reclining;
                if (victim._fighting == null)
                {
                    Combat.SetFighting(victim, ch);
                }
                return;
            }

            ch.WaitState(MUDMath.FuzzyNumber(Skill.SkillList["springleap"].Delay));
            ch.PracticeSkill("springleap");


            if (ch.IsNPC())
            {
                chance = (ch._level * 3) / 2 + 15;
            }
            else
            {
                chance = ((PC)ch).SkillAptitude["springleap"] - 5;
            }

            if (chance > 95)
            {
                chance = 95;
            }

            if (victim._position < Position.fighting)
            {
                chance /= 4;
            }

            if (MUDMath.NumberPercent() < chance)
            {
                ch._position = Position.fighting;
                SocketConnection.Act("&+WYour springleap knocks $N&n&+W on $S butt.&n", ch, null, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("&+W$n&n&+W leaps gracefully at $N&n&+W, sending $M to the ground.&n", ch, null, victim, SocketConnection.MessageTarget.room);
                SocketConnection.Act("&+W$n&n&+W leaps at you, knocking you to the ground!&n", ch, null, victim, SocketConnection.MessageTarget.victim);
                if (victim.IsAffected(Affect.AFFECT_SINGING))
                {
                    victim.RemoveAffect(Affect.AFFECT_SINGING);
                    SocketConnection.Act("$n&n gasps and falls silent as $e falls over backward!", victim, null, null, SocketConnection.MessageTarget.room);
                    victim.SendText("You abort your singing!\r\n");
                }
                if (victim.IsAffected(Affect.AFFECT_CASTING))
                {
                    victim.RemoveAffect(Affect.AFFECT_CASTING);
                    SocketConnection.Act("$n&n no longer has any idea what $e was casting.", victim, null, null, SocketConnection.MessageTarget.room);
                    victim.SendText("Lying on the ground, you realize you have no idea what you were just casting.\r\n");
                }

                if (!ch._fighting)
                {
                    Combat.SetFighting(ch, victim);
                }
                if (!victim._fighting)
                {
                    Combat.SetFighting(victim, ch);
                }
                if (!Combat.CheckTumble(victim))
                {
                    victim.WaitState((Skill.SkillList["springleap"].Delay * 5 / 6));
                    if (victim._position > Position.sitting)
                    {
                        victim._position = Position.sitting;
                    }
                    Combat.InflictDamage(ch, victim, MUDMath.NumberRange(1, ch._level), "springleap", ObjTemplate.WearLocation.none, AttackType.DamageType.bludgeon);
                }
                else
                {
                    Combat.InflictDamage(ch, victim, MUDMath.NumberRange(1, (ch._level / 3)), "springleap", ObjTemplate.WearLocation.none, AttackType.DamageType.bludgeon);
                    ch.SendText("You roll with the blow, finally landing on your feet.\r\n");
                    SocketConnection.Act("$n&n rolls with the blow, finally landing on $s feet.", victim, null, null, SocketConnection.MessageTarget.room);
                }
            }
            else
            {
                bool pissedOff = false;
                if (ch._fighting == victim || victim.GetCurrInt() > MUDMath.NumberPercent())
                {
                    pissedOff = true;
                }
                if (pissedOff)
                {
                    SocketConnection.Act("As $N&n avoids your leap you crash to the ground.", ch, null, victim, SocketConnection.MessageTarget.character);
                    SocketConnection.Act("$n&n crashes to the ground as you avoid $s springleap.", ch, null, victim, SocketConnection.MessageTarget.victim);
                    if (!ch._fighting)
                    {
                        Combat.SetFighting(ch, victim);
                    }
                    if (!victim._fighting)
                    {
                        Combat.SetFighting(victim, ch);
                    }
                }
                else
                {
                    SocketConnection.Act("You ungracefully leap at $N and miss, landing head first!", ch, null, victim, SocketConnection.MessageTarget.character);
                }
                SocketConnection.Act("$n&n misses a springleap and falls awkwardly to the ground.", ch, null, null, SocketConnection.MessageTarget.room);
                ch._position = Position.reclining;
                Combat.InflictDamage(ch, ch, MUDMath.NumberRange(1, 4), "springleap",
                        ObjTemplate.WearLocation.none, AttackType.DamageType.bludgeon);
            }

            return;
        }

        /// <summary>
        /// Bodyslam an opponent.  Can only be used to initiate combat.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Bodyslam(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;

            /* Check player's level and class, mobs can use this skill */
            if (!ch.HasInnate(Race.RACE_BODYSLAM))
            {
                ch.SendText("You don't feel massive enough to manhandle that.\r\n");
                return;
            }

            if (ch.IsBlind())
            {
                return;
            }
            if (ch._riding)
            {
                ch.SendText("You can't do that while mounted.\r\n");
                return;
            }

            if (str.Length != 0)
            {
                if (!(victim = ch.GetCharRoom(str[0])) || victim._position == Position.dead)
                {
                    ch.SendText("They aren't here.\r\n");
                    return;
                }
            }
            else
            {
                ch.SendText("Bodyslam who?\r\n");
                return;
            }

            // Added size restrictions -- Xangis
            if (victim._size > ch._size)
            {
                if (ch.HasInnate(Race.RACE_SLAM_LARGER))
                {
                    // allowing centaurs to slam one size up if it's an ogre
                    if (victim._size > (ch._size + 1))
                    {
                        ch.SendText("You can't bodyslam something that much bigger than you.\r\n");
                        return;
                    }
                }
                else
                {
                    ch.SendText("You can't bodyslam something bigger than you.\r\n");
                    return;
                }
            }

            if ((ch._size > victim._size) && ((ch._size - victim._size) > 3))
            {
                ch.SendText("They're too small to slam.\r\n");
                return;
            }

            /* Bodyslam self?  Ok! */
            if (ch == victim)
            {
                ch.SendText("You slam yourself to the ground!\r\n");
                SocketConnection.Act("$n&n throws $mself to the ground in a fit of clumsiness.",
                     ch, null, victim, SocketConnection.MessageTarget.room_vict);
                ch.WaitState((Skill.SkillList["bodyslam"].Delay / 2));
                ch._position = Position.reclining;
                Combat.InflictDamage(ch, ch, MUDMath.NumberRange(1, 6), "bodyslam", ObjTemplate.WearLocation.none, AttackType.DamageType.bludgeon);
                return;
            }

            ch.WaitState(Skill.SkillList["bodyslam"].Delay);
            ch.PracticeSkill("bodyslam");

            int chance = (ch._level * 3) / 2 + 15;
            chance += ch.GetCurrAgi() - victim.GetCurrAgi();
            chance -= (victim._level - ch._level);

            switch (victim._position)
            {
                case Position.dead:
                    return;
                case Position.mortally_wounded:
                    chance += 15;
                    break;
                case Position.incapacitated:
                    chance += 10;
                    break;
                case Position.unconscious:
                    chance += 5;
                    break;
                case Position.stunned:
                    chance += 3;
                    break;
                case Position.sleeping:
                    chance += 2;
                    break;
                case Position.reclining:
                    chance -= 45;
                    break;
                case Position.resting:
                    chance -= 30;
                    break;
                case Position.sitting:
                    chance -= 20;
                    break;
                case Position.kneeling:
                    chance -= 15;
                    break;
                case Position.fighting:
                case Position.standing:
                default:
                    break;
            }

            // Small penalty for the small buggers -- Xangis
            if (victim._size < (ch._size - 1))
            {
                chance -= 15;
            }

            if (chance > 90)
            {
                chance = 90;
            }

            // Shaman bodyslam penalty.
            if (ch.IsClass(CharClass.Names.shaman) || ch.IsClass(CharClass.Names.druid))
            {
                chance = (chance * 2) / 3;
            }

            if (victim.IsAffected(Affect.AFFECT_AWARE))
            {
                chance -= 15;
            }
            else if (victim.IsAffected( Affect.AFFECT_SKL_AWARE))
            {
                if (ch.HasSkill("springleap"))
                {
                    if (ch.IsNPC())
                    {
                        if (MUDMath.NumberPercent() < ((ch._level * 3) / 2 + 15))
                        {
                            chance -= 15;
                        }
                    }
                    else if (MUDMath.NumberPercent() < ((PC)ch).SkillAptitude["awareness"])
                    {
                        ch.PracticeSkill("awareness");
                        chance -= 15;
                    }
                    else
                    {
                        ch.PracticeSkill("awareness");
                    }
                }
            }

            if (!ch._fighting)
            {
                Combat.SetFighting(ch, victim);
            }
            if (victim._fighting == null)
            {
                Combat.SetFighting(victim, ch);
            }

            if (ch.IsNPC() || MUDMath.NumberPercent() < chance)
            {
                if (victim.IsAffected( Affect.AFFECT_SINGING))
                {
                    victim.RemoveAffect(Affect.AFFECT_SINGING);
                    SocketConnection.Act("$n&n suddenly loses track of the key $e was singing in.", victim, null, null, SocketConnection.MessageTarget.room);
                    victim.SendText("You get the wind knocked out of you!\r\n");
                }
                if (victim.IsAffected( Affect.AFFECT_CASTING))
                {
                    victim.RemoveAffect(Affect.AFFECT_CASTING);
                    SocketConnection.Act("$n&n's thoughts of casting are scattered about as $e is slammed into the ground.", victim, null, null, SocketConnection.MessageTarget.room);
                    victim.SendText("Your brain slamming against your skull disrupts your concentration.\r\n");
                }
                // Moved damage to bottom because it would crash when a person died, because
                // it still tried to access them as a valid character.  Also added tumble check for
                // thieves.
                if (!Combat.CheckTumble(victim))
                {
                    victim.WaitState(Skill.SkillList["bodyslam"].Delay);
                    victim._position = Position.reclining;
                    Combat.InflictDamage(ch, victim, MUDMath.NumberRange(1, ch._level), "bodyslam", ObjTemplate.WearLocation.none, AttackType.DamageType.bludgeon);
                }
                else
                {
                    if (!Combat.InflictDamage(ch, victim, MUDMath.NumberRange(1, (ch._level / 3)), "bodyslam", ObjTemplate.WearLocation.none, AttackType.DamageType.bludgeon))
                    {
                        ch.SendText("You roll with the blow, finally landing on your feet.\r\n");
                        SocketConnection.Act("$n&n rolls with the blow, finally landing on $s feet.", ch, null, null, SocketConnection.MessageTarget.room);
                    }
                }
            }
            else
            {
                ch._hitpoints -= MUDMath.NumberRange(1, 5);
                SocketConnection.Act("As $N&n avoids your slam, you smack headfirst into the &n&+yground&n.", ch, null, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n throws $mself to the &n&+yground&n in a fit of clumsiness.", ch, null, victim, SocketConnection.MessageTarget.victim);
                SocketConnection.Act("$n&n misses a bodyslam on $N&n and slams $s head into the &n&+yground&n.", ch, null, victim, SocketConnection.MessageTarget.room_vict);
                ch._position = Position.reclining;
            }

            return;
        }

        /*
        * Modified to up the damage and allow for a 
        * chance to stun victim or self
        *   damage = (level) d2, for an average of 75 hp at level 50
        *   stun damage = (level) d3, for an average of 100 hp at level 50
        * Player vs player damage is reduced in damage()
        */
        /// <summary>
        /// Headbutt. Usable to initiate combat and during combat.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Headbutt(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int chance;
            int ko;
            string text;

            /* Check player's level and class, mobs can use this skill */
            if ((!ch.HasSkill("headbutt")))
            {
                ch.SendText("Your skull is much too soft to headbutt anyone.\r\n");
                return;
            }

            if (ch.IsBlind())
            {
                return;
            }

            CharData victim = ch._fighting;

            if (str.Length != 0)
            {
                if (!(victim = ch.GetCharRoom(str[0])) || victim._position == Position.dead)
                {
                    ch.SendText("They are nowhere to be seen.\r\n");
                    return;
                }
            }
            else
            {
                if (!victim || victim._position == Position.dead)
                {
                    ch.SendText("You aren't fighting anyone.\r\n");
                    return;
                }
            }

            /* anti headbutt me code */
            if (ch == victim)
            {
                ch.SendText("You get dizzy as you ponder the mechanics of headbutting yourself.\r\n");
                return;
            }

            if (ch._position < Position.fighting)
            {
                ch.SendText("You need to stand up to do that.\r\n");
                return;
            }
            /* Check size of ch vs. victim. */
            /* If ch is too small. */
            /* Made it 2 sizes */
            if (ch._size - 2 > victim._size)
            {
                SocketConnection.Act("You would crush such a small and delicate being with your mass.", ch, null, victim, SocketConnection.MessageTarget.character);
                return;
            }
            /* Ch 2 or more sizes larger than victim => bad! */
            if (ch._size + 1 < victim._size)
            {
                SocketConnection.Act("You can't reach their head!", ch, null, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n slams $s head into your thigh.", ch, null, victim, SocketConnection.MessageTarget.victim);
                SocketConnection.Act("$n&n slams $s head into $N's thigh.", ch, null, victim, SocketConnection.MessageTarget.room_vict);

                ch.WaitState((Skill.SkillList["headbutt"].Delay * 9) / 10);
                if (victim._fighting == null)
                {
                    Combat.SetFighting(victim, ch);
                }
                return;
            }

            ch.WaitState(MUDMath.FuzzyNumber(Skill.SkillList["headbutt"].Delay));
            ch.PracticeSkill("headbutt");

            if (!ch._fighting)
            {
                Combat.SetFighting(ch, victim);
            }
            if (!victim._fighting)
            {
                Combat.SetFighting(victim, ch);
            }

            /* Added a PC skill level
            */
            // Chance was over-downgraded at some point.  Was skill level - 5%,
            // then it was changed to skill level / 2 giving a level 50 a headbutt
            // success rate of about 47%.  I've upped it to 4/5 of skill level,
            // meaning that a level 50 has a success rate of 76%, which is a good
            // target success rate.  Keep in mind minotaur will have a success rate of
            // about 83%.
            if (ch.IsNPC())
            {
                chance = 50 + ch._level;
            }
            else
            {
                chance = ((PC)ch).SkillAptitude["headbutt"] * 4 / 5;
            }

            // Minotaur headbutt bonus
            if (ch.GetRace() == Race.RACE_MINOTAUR)
            {
                chance += 7;
            }

            if (victim._position < Position.fighting)
            {
                chance /= 3;
            }

            if (MUDMath.NumberPercent() < chance)
            /*  Headbutt successful, possible KO */
            {
                /* First give the victim a chance to dodge */
                if (Combat.CheckDodge(ch, victim))
                {
                    return;
                }
                /* OK, lets settle for stun right now
                * a skill level of 100% has a 20% chance of stun
                * a skill level of 50% has a 2.5% chance of stun
                * a skill level of 23% has a 1% chance of stun
                * immortals get a 15% bonus
                */
                // The stun math was bad.  Stun was way more often that it should have
                // been.  Now we have a flat /4 chance, meaning a the following stun chances
                // at each skill level:
                // 25 = 5%  50 = 10 %  75 = 15%  95 = 19%
                ko = chance / 4;
                if (ch.IsImmortal())
                {
                    ko += 15;
                }
                text = String.Format("Commandheadbutt: {0}&n attempting a KO with {1}%% chance.", ch._name, ko);
                ImmortalChat.SendImmortalChat(null, ImmortalChat.IMMTALK_SPAM, 0, text);
                if (MUDMath.NumberPercent() < ko + 1)
                {
                    // deal some decent damage
                    // This was previously level d 3 which was fairly pathetic.
                    // Level d 8 = 50 min, 400 max at level 50 with an average of 225
                    // PvP damage is quartered, so headbutt will do about 56 against a player.
                    if (ch.GetRace() != Race.RACE_MINOTAUR)
                    {
                        Combat.InflictDamage(ch, victim, MUDMath.Dice(ch._level, 8), "headbutt", ObjTemplate.WearLocation.none, AttackType.DamageType.bludgeon);
                    }
                    else
                    {
                        Combat.InflictDamage(ch, victim, MUDMath.Dice(ch._level, 9), "headbutt", ObjTemplate.WearLocation.none, AttackType.DamageType.bludgeon);
                    }
                    if (victim._position > Position.stunned)
                    {
                        SocketConnection.Act("$n&n staggers about, then collapses in a heap.", victim, null, null, SocketConnection.MessageTarget.room);
                        victim.SendText("You fall to the ground &+Wstunned&n.\r\n");
                        SocketConnection.Act("$n&n is &+Wstunned!&n", victim, null, null, SocketConnection.MessageTarget.room);
                        victim._position = Position.stunned;
                        victim.WaitState((Skill.SkillList["headbutt"].Delay));
                        text = String.Format("Commandheadbutt: {0}&n stunned {1}&n.", ch._name, victim._name);
                        ImmortalChat.SendImmortalChat(null, ImmortalChat.IMMTALK_SPAM, 0, text);
                    }
                }
                else
                {
                    // just your ordinary headbutt damage
                    // This was previously level d 2 which was fairly pathetic.
                    // Level d 6 = 50 min, 300 max at level 50 with an average of 175
                    // PvP damage is quartered, so headbutt will do about 43 against a player.
                    if (ch.GetRace() != Race.RACE_MINOTAUR)
                    {
                        if (!Combat.InflictDamage(ch, victim, MUDMath.Dice(ch._level, 6), "headbutt", ObjTemplate.WearLocation.none, AttackType.DamageType.bludgeon))
                        {
                            // Someone blasts you in the head it'll definitely stun you for 3/4 of a second.
                            victim.WaitState(3);
                        }
                    }
                    else
                    {
                        if (!Combat.InflictDamage(ch, victim, MUDMath.Dice(ch._level, 7), "headbutt", ObjTemplate.WearLocation.none, AttackType.DamageType.bludgeon))
                        {
                            // Someone blasts you in the head with horns it'll definitely stun you for a second.
                            // -- Xangis
                            victim.WaitState(4);
                        }
                    }
                }
            }
            else /* Headbutt failed, possible damgage to self, possible KO of self */
            {    /* Don't allow char to kill self, just mort self */
                /* Give them a chance to not take any damage */
                // Checking chance instead of player's level.  Since this should be based on skill
                // this should be about right (average of 24% chance of screwing yourself at level 50
                // instead of 50%, 17% chance for minos).
                if (MUDMath.NumberPercent() < chance)
                {
                    ch.SendText("Your headbutt fails to strike its target.\r\n");
                    SocketConnection.Act("$n&n tries to headbutt $N&n but can't quite connect.", ch, null,
                        victim, SocketConnection.MessageTarget.everyone_but_victim);
                    SocketConnection.Act("$n&n bobs around you in a feeble attempt at a headbutt.", ch,
                        null, victim, SocketConnection.MessageTarget.victim);
                    return;
                }
                SocketConnection.Act("You bang your head against the brick wall of $N&n.", ch, null,
                    victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n tries a headbutt but $N&n gets the best of $m.", ch, null,
                    victim, SocketConnection.MessageTarget.everyone_but_victim);
                SocketConnection.Act("$n&n bangs into you in a feeble attempt at a headbutt.", ch,
                    null, victim, SocketConnection.MessageTarget.victim);
                // KO chance of 24% for normals, 17% for minos.
                // You have to fail three checks to get your ass kicked by KO, one for the actual skill check,
                // one for the damage check and finally one for the KO check.
                // keep in mind this KO does damage of about 100 to self at level 50, which is a hell of a lot
                // for a failed skill.
                // The chance of ko'ing yourself at each skill level is as follows: (after all 3 checks)
                // Skill 25 = 59.2%  Skill 50 = 29.6%  Skill 75 = 14.4%  Skill 95 = 9.38%
                ko = 108 - chance;
                int dam;
                if (MUDMath.NumberPercent() < ko)
                {
                    // doh! This is gonna hurt
                    //deal some decent damage...to self!
                    if (ch.GetRace() != Race.RACE_MINOTAUR)
                    {
                        dam = MUDMath.Dice(ch._level, 3);
                    }
                    else
                    {
                        dam = MUDMath.Dice(ch._level, 2);
                    }
                    if (dam > ch._hitpoints)
                    {
                        dam = ch._hitpoints + 1;
                    }
                    if (Combat.InflictDamage(ch, ch, dam, "headbutt", ObjTemplate.WearLocation.none, AttackType.DamageType.bludgeon))
                    {
                        // ch invalidated, can't send messages.
                        return;
                    }
                    SocketConnection.Act("$n&n staggers about, then collapses in a heap.", ch, null, null, SocketConnection.MessageTarget.room);
                    ch.SendText("You fall to the ground stunned.\r\n");
                    SocketConnection.Act("$n&n is stunned!", ch, null, null, SocketConnection.MessageTarget.room);
                    ch._position = Position.stunned;
                    ch.WaitState((Skill.SkillList["headbutt"].Delay * 2));
                    text = String.Format("Commandheadbutt: {0}&n stunned self.", ch._name);
                    ImmortalChat.SendImmortalChat(null, ImmortalChat.IMMTALK_SPAM, 0, text);
                }
                else
                {
                    // Was previously level d 2, which averaged 30 damage at 20 and 75 at 50.  PC to PC
                    // damage is not quartered when it is done to yourself, so this it kind of high at the
                    // upper levels.  This has been reduced by level / 5, so the damage at 50 averages 65
                    // instead of 65.
                    // Keep in mind that the real penalties come from KO and comparitively someone that
                    // fails a bash doesen't take insane damage.
                    dam = MUDMath.Dice(ch._level, 2) - ch._level / 5;
                    if (dam > ch._hitpoints)
                    {
                        dam = ch._hitpoints + 1;
                    }
                    Combat.InflictDamage(ch, ch, dam, "headbutt", ObjTemplate.WearLocation.none, AttackType.DamageType.bludgeon);
                }
            } //end if() headbutt failed
            return;
        }

        /*
        * Charge. Usable to initiate combat.
        */
        public static void Charge(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;

            /* Check player's level and class, mobs can use this skill */
            if (!ch.HasInnate(Race.RACE_CHARGE))
            {
                ch.SendText("You can't do that.\r\n");
                return;
            }

            if (ch.IsBlind())
            {
                return;
            }

            if (str.Length != 0)
            {
                if (!(victim = ch.GetCharRoom(str[0])) || victim._position == Position.dead)
                {
                    ch.SendText("They aren't here.\r\n");
                    return;
                }
            }
            else
            {
                ch.SendText("Charge who?\r\n");
                return;
            }

            /* charge me trap */
            if (ch == victim)
            {
                ch.SendText("You chase your tail for a while.\r\n");
                return;
            }

            ch.WaitState(MUDMath.FuzzyNumber(Skill.SkillList["charge"].Delay));

            if (!ch._fighting)
            {
                Combat.SetFighting(ch, victim);
            }
            if (!victim._fighting)
            {
                Combat.SetFighting(victim, ch);
            }

            // Chance is based on level of charger and victim.
            int chance = (ch._level * 2) - victim._level + 25;
            if (chance > 95)
            {
                chance = 95;
            }

            if (ch.IsNPC() || MUDMath.NumberPercent() < chance)
            {
                Combat.InflictDamage(ch, victim, MUDMath.NumberRange(1, ch._level), "charge", ObjTemplate.WearLocation.none, AttackType.DamageType.bludgeon);
            }
            else
            {
                Combat.InflictDamage(ch, victim, 0, "charge", ObjTemplate.WearLocation.none, AttackType.DamageType.bludgeon);
            }

            return;
        }

        public static void DirtToss(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int percent;

            /* Don't allow the unskilled to do this, check player's level */
            if (!ch.HasSkill("dirt toss"))
            {
                ch.SendText("You get your feet dirty.\r\n");
                return;
            }

            if (ch.IsBlind())
            {
                ch.SendText("You can't see anything!\r\n");
                return;
            }

            if (ch._flyLevel != 0)
            {
                ch.SendText("Perhaps you should land first matey.\r\n");
                return;
            }

            CharData victim = ch._fighting;

            if (str.Length != 0)
            {
                if (!(victim = ch.GetCharRoom(str[0])) || victim._position == Position.dead)
                {
                    ch.SendText("They aren't here.\r\n");
                    return;
                }
            }
            if (!victim || victim._position == Position.dead)
            {
                ch.SendText("You aren't fighting anyone.\r\n");
                return;
            }


            if (victim == ch)
            {
                ch.SendText("Very funny.\r\n");
                return;
            }

            if (victim.IsAffected( Affect.AFFECT_BLIND))
            {
                SocketConnection.Act("$E's already been &+Lblinded&n.", ch, null, victim, SocketConnection.MessageTarget.character);
                return;
            }

            if (!ch.IsNPC())
            {
                percent = ((PC)ch).SkillAptitude["dirt toss"];
            }
            else
            {
                percent = (ch._level * 3) / 2 + 25;
            }

            percent += (ch._level - victim._level) * 2;
            percent += (ch.GetCurrDex() / 10);
            percent -= (victim.GetCurrDex() / 10);
            percent -= (victim.GetCurrAgi() / 10);

            // Why waste time listing sectors with no modifier?
            switch (ch._inRoom.TerrainType)
            {
                case TerrainType.inside:
                case TerrainType.arctic:
                case TerrainType.swamp:
                    percent -= 20;
                    break;
                case TerrainType.city:
                case TerrainType.mountain:
                    percent -= 10;
                    break;
                case TerrainType.plane_of_fire:
                case TerrainType.plane_of_air:
                case TerrainType.plane_of_water:
                case TerrainType.plane_ethereal:
                case TerrainType.plane_astral:
                case TerrainType.underwater_has_ground:
                case TerrainType.underwater_no_ground:
                case TerrainType.swimmable_water:
                case TerrainType.unswimmable_water:
                case TerrainType.air:
                case TerrainType.ocean:
                case TerrainType.underground_swimmable_water:
                case TerrainType.underground_unswimmable_water:
                    percent = 0;
                    break;
                case TerrainType.field:
                    percent += 5;
                    break;
                case TerrainType.desert:
                    percent += 10;
                    break;
                case TerrainType.plane_of_earth:
                    percent += 15;
                    break;
                default:
                    break;
            }

            if (percent > 75)
            {
                percent = 75;
            }
            else if (percent < 5)
            {
                percent = 5;
            }

            if (percent <= 0)
            {
                ch.SendText("There isn't any &n&+ydirt&n to kick.\r\n");
                return;
            }

            ch.PracticeSkill("dirt toss");

            if (percent < MUDMath.NumberPercent())
            {
                Affect af = new Affect();

                SocketConnection.Act("$n is &+Lblinded&n by the &n&+ydirt&n in $s eyes!", victim, null, null,
                     SocketConnection.MessageTarget.room);
                SocketConnection.Act("$n kicks &n&+ydirt&n into your eyes!", ch, null, victim, SocketConnection.MessageTarget.victim);

                victim.SendText("&+LYou can't see a thing!&n\r\n");

                af.Value = "dirt toss";
                af.Type = Affect.AffectType.skill;
                af.Duration = MUDMath.NumberRange(1, 2);
                af.AddModifier(Affect.Apply.hitroll, -4);
                af.SetBitvector(Affect.AFFECT_BLIND);
                victim.AddAffect(af);

            }
            else
            {
                ch.SendText("&+LYou kick dirt at your target!&n\r\n");
            }

            Combat.SetFighting(victim, ch);

            ch.WaitState(Skill.SkillList["dirt toss"].Delay);

            return;
        }

        // This function needs to be rewritten to take args!
        public static void Whirlwind(CharData ch, string[] str)
        {
            if( ch == null ) return;

            bool found = false;

            if (!ch.IsNPC() && !ch.HasSkill("whirlwind"))
            {
                ch.SendText("You don't know how to do that...\r\n");
                return;
            }

            Object wield = Object.GetEquipmentOnCharacter(ch, ObjTemplate.WearLocation.hand_one);
            if (!wield || wield.ItemType != ObjTemplate.ObjectType.weapon)
            {
                ch.SendText("You need to wield a weapon first.\r\n");
                return;
            }

            SocketConnection.Act("$n&n holds $p&n firmly, and starts spinning round...", ch, wield, null, SocketConnection.MessageTarget.room);
            SocketConnection.Act("You hold $p&n firmly, and start spinning round...", ch, wield, null, SocketConnection.MessageTarget.character);

            foreach (CharData pChar in ch._inRoom.People)
            {
                if ((pChar.IsNPC() || (ch.IsRacewar(pChar) && !pChar.IsImmortal()))
                        && CharData.CanSee(pChar, ch))
                {
                    found = true;
                    SocketConnection.Act("$n&n turns towards YOU!", ch, null, pChar, SocketConnection.MessageTarget.victim);
                    Combat.SingleAttack(ch, pChar, "whirlwind", ObjTemplate.WearLocation.hand_one);
                    // Added small amount of lag per _targetType hit
                    ch.WaitState(3);
                }
            }

            if (!found)
            {
                SocketConnection.Act("$n&n looks dizzy, and a tiny bit embarrassed.", ch, null, null,
                     SocketConnection.MessageTarget.room);
                SocketConnection.Act("You feel dizzy, and a tiny bit embarrassed.", ch, null, null,
                     SocketConnection.MessageTarget.character);
            }

            ch.WaitState(Skill.SkillList["whirlwind"].Delay);

            ch.PracticeSkill("whirlwind");

            if (!found && MUDMath.NumberPercent() < 25)
            {
                SocketConnection.Act("$n&n loses $s balance and colapses into a heap.", ch, null, null,
                     SocketConnection.MessageTarget.room);
                SocketConnection.Act("You lose your balance and fall into a heap.", ch, null, null,
                     SocketConnection.MessageTarget.character);
                ch._position = Position.stunned;
            }

            return;
        }

        public static void Disarm(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int odds;

            /* Don't allow charmed mobiles to do this, check player's level */
            if ((ch.IsNPC() && ch.IsAffected( Affect.AFFECT_CHARM))
                    || (!ch.IsNPC() && !ch.HasSkill("disarm")))
            {
                ch.SendText("You don't know how to disarm opponents.\r\n");
                return;
            }

            if (!Object.GetEquipmentOnCharacter(ch, ObjTemplate.WearLocation.hand_one)
                    && !Object.GetEquipmentOnCharacter(ch, ObjTemplate.WearLocation.hand_two))
            {
                ch.SendText("You must wield a weapon to disarm.\r\n");
                return;
            }

            if (!ch._fighting)
            {
                ch.SendText("You aren't fighting anyone.\r\n");
                return;
            }

            CharData victim = ch._fighting;

            if (str.Length != 0)
            {
                if (!(victim = ch.GetCharRoom(str[0])))
                {
                    ch.SendText("They aren't here.\r\n");
                    return;
                }
            }

            if (victim._fighting != ch && ch._fighting != victim)
            {
                SocketConnection.Act("$E is not fighting you!", ch, null, victim, SocketConnection.MessageTarget.character);
                return;
            }

            if (!Object.GetEquipmentOnCharacter(victim, ObjTemplate.WearLocation.hand_one)
                    && !Object.GetEquipmentOnCharacter(victim, ObjTemplate.WearLocation.hand_two))
            {
                ch.SendText("Your opponent is not wielding a weapon.\r\n");
                return;
            }

            if (victim._level > ch._level + 10)
            {
                ch.SendText("They are much too clever for such a clumsy attempt at that maneuver.\r\n");
                return;
            }

            ch.WaitState(Skill.SkillList["disarm"].Delay);
            ch.PracticeSkill("disarm");
            if (ch.IsNPC())
            {
                odds = ch._level;
            }
            else
            {
                odds = ((PC)ch).SkillAptitude["disarm"] / 2;
            }
            if (victim.IsNPC())
            {
                odds += 2 * (ch._level - victim._level);
            }
            else
            {
                /* Offense skill helps prevent disarms */
                odds -= ((PC)victim).SkillAptitude["offense"] / 4;
            }
            if (!Object.GetEquipmentOnCharacter(ch, ObjTemplate.WearLocation.hand_one))
            {
                odds /= 2;      /* 1/2 as likely with only 2nd weapon */
            }
            odds = Math.Min(odds, 98);
            odds = Math.Max(odds, 2);
            string lbuf = String.Format("Disarm: {0} attempting with {1}%% chance.", ch._name, odds);
            ImmortalChat.SendImmortalChat(null, ImmortalChat.IMMTALK_SPAM, 0, lbuf);
            if (MUDMath.NumberPercent() < odds)
            {
                Combat.Disarm(ch, victim);
            }
            else if (MUDMath.NumberPercent() > 80)
            {
                ch.SendText("Expertly countering your maneuver, they dislodge your weapon and send it flying.\r\n");
                Combat.Disarm(victim, ch);
            }
            else
            {
                ch.SendText("You failed in your attempt.\r\n");
            }
            return;
        }

        public static void Get(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object container;
            bool found;
            Object obj;

            if (ch.IsAffected(Affect.AFFECT_HOLD) || ch.IsAffected(Affect.AFFECT_MINOR_PARA))
            {
                ch.SendText("Try as you might, your body refuses to move!\r\n");
                return;
            }

            /* Get type. */
            if (str.Length == 0 || String.IsNullOrEmpty(str[0]))
            {
                ch.SendText("Get what?\r\n");
                return;
            }

            if (str.Length < 2)
            {
                if (str[0] != "all" && MUDString.IsPrefixOf("all.", str[0]))
                {
                    /* 'get obj' */
                    obj = Object.GetObjFromList(ch._inRoom.Contents, ch, str[0]);
                    if (obj == null)
                    {
                        SocketConnection.Act("I see no $T&n here.", ch, null, str[0], SocketConnection.MessageTarget.character);
                        return;
                    }

                    if (ch._carryNumber + 1 > Limits.MAX_CARRY)
                    {
                        ch.SendText("You have your hands full.\r\n");
                        return;
                    }

                    Object.GetObject(ch, obj, null);
                }
                else
                {
                    /* 'get all' or 'get all.obj' */
                    found = false;
                    for(int i = (ch._inRoom.Contents.Count - 1); i >= 0; i--)
                    {
                        Object iobj = ch._inRoom.Contents[i];
                        if (iobj.FlyLevel != ch._flyLevel)
                        {
                            continue;
                        }

                        if ((str[0].Equals("all", StringComparison.CurrentCultureIgnoreCase) ||
                            MUDString.NameContainedIn(str[0].Substring(4), iobj.Name))
                                && CharData.CanSeeObj(ch, iobj))
                        {
                            found = true;
                            if (ch._carryNumber + 1 > Limits.MAX_CARRY)
                            {
                                ch.SendText("You have your hands full.\r\n");
                                return;
                            }

                            Object.GetObject(ch, iobj, null);
                        }
                    }

                    if (!found)
                    {
                        if (str[0].Equals("all", StringComparison.CurrentCultureIgnoreCase))
                        {
                            ch.SendText("You see nothing here.\r\n");
                        }
                        else
                        {
                            SocketConnection.Act("You see no $T&n here.", ch, null, str[0].Substring(4), SocketConnection.MessageTarget.character);
                        }
                    }
                }
            }
            else
            {
                /* 'get ... container' */
                if (!MUDString.StringsNotEqual(str[1], "all") || !MUDString.IsPrefixOf("all.", str[1]))
                {
                    ch.SendText("That doesn't seem possible.\r\n");
                    return;
                }

                container = ch.GetObjHere(str[1]);
                if (!container)
                {
                    SocketConnection.Act("You don't see any $T&n here.", ch, null, str[1], SocketConnection.MessageTarget.character);
                    return;
                }

                switch (container.ItemType)
                {
                    default:
                        ch.SendText("Unfortunately, that's not a container.\r\n");
                        return;

                    case ObjTemplate.ObjectType.quiver:
                    case ObjTemplate.ObjectType.container:
                    case ObjTemplate.ObjectType.npc_corpse:
                        break;

                    case ObjTemplate.ObjectType.pc_corpse:
                        {
                            string descr = container.ShortDescription;
                            string name = String.Empty;
                        }
                        break;
                }

                if (ch._position == Position.fighting || ch._fighting)
                {
                    ch.SendText("You're too busy to be doing that!\r\n");
                    return;
                }

                if (Macros.IsSet(container.Values[1], ObjTemplate.CONTAINER_CLOSED.Vector))
                {
                    SocketConnection.Act("The $d&n is fastened shut.", ch, null, container.Name, SocketConnection.MessageTarget.character);
                    return;
                }

                if (str[0] != "all" && MUDString.IsPrefixOf("all.", str[0]))
                {
                    /* 'get obj container' */
                    obj = Object.GetObjFromList(container.Contains, ch, str[0]);
                    if (!obj)
                    {
                        SocketConnection.Act("You search the $T&n with little success.", ch, null, str[1], SocketConnection.MessageTarget.character);
                        return;
                    }
                    if (ch._carryNumber + 1 > Limits.MAX_CARRY)
                    {
                        ch.SendText("You have your hands full.\r\n");
                        return;
                    }
                    Object.GetObject(ch, obj, container);
                }
                else
                {
                    /* 'get all container' or 'get all.obj container' */
                    found = false;
                    for( int i = (container.Contains.Count - 1); i >= 0; i--)
                    {
                        if ((str[0].Equals("all", StringComparison.CurrentCultureIgnoreCase) ||
                            MUDString.NameContainedIn(str[0].Substring(4), container.Contains[i].Name))
                                && CharData.CanSeeObj(ch, container.Contains[i]))
                        {
                            found = true;
                            if (ch._carryNumber + 1 > Limits.MAX_CARRY)
                            {
                                ch.SendText("You have your hands full.\r\n");
                                return;
                            }
                            Object.GetObject(ch, container.Contains[i], container);
                            if (container.ItemType == ObjTemplate.ObjectType.pc_corpse)
                            {
                                CharData.SavePlayer(ch);
                                Database.CorpseList.Save();
                            }
                        }
                    }

                    if (!found)
                    {
                        if (str[0].Equals("all", StringComparison.CurrentCultureIgnoreCase))
                        {
                            SocketConnection.Act("You see nothing in the $T&n.", ch, null, str[1], SocketConnection.MessageTarget.character);
                        }
                        else
                        {
                            SocketConnection.Act("You see nothing like that in the $T&n.", ch, null, str[1], SocketConnection.MessageTarget.character);
                        }
                    }
                }
            }
            return;
        }

        /// <summary>
        /// Put an object into another object.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Put(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object obj;

            if (str.Length < 2)
            {
                ch.SendText("Put what into what?\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "all") || !MUDString.IsPrefixOf("all.", str[1]))
            {
                ch.SendText("You can't do that.\r\n");
                return;
            }

            Object container = ch.GetObjHere(str[1]);
            if (!container)
            {
                SocketConnection.Act("You see no $T&n here.", ch, null, str[1], SocketConnection.MessageTarget.character);
                return;
            }

            /*  Added put <missileweap> <quiver> */
            if (container.ItemType != ObjTemplate.ObjectType.container &&
                    container.ItemType != ObjTemplate.ObjectType.quiver)
            {
                ch.SendText("That's not a container.\r\n");
                return;
            }

            if (Macros.IsSet(container.Values[1], ObjTemplate.CONTAINER_CLOSED.Vector))
            {
                SocketConnection.Act("The $d&n is &n&+ystrapped&n shut.", ch, null, container.Name, SocketConnection.MessageTarget.character);
                return;
            }

            if (str[0] != "all" && MUDString.IsPrefixOf("all.", str[0]))
            {
                /* 'put obj container' */
                obj = ch.GetObjCarrying(str[0]);
                if (!obj)
                {
                    ch.SendText("You do not have that item.\r\n");
                    return;
                }

                if (obj == container)
                {
                    ch.SendText("You can't fold it into itself.\r\n");
                    return;
                }

                if (!ch.CanDropObject(obj))
                {
                    ch.SendText("You can't seem to let go of it.\r\n");
                    return;
                }

                if (obj.GetWeight() + container.GetWeight() - container.Weight > container.Values[0])
                {
                    ch.SendText("It won't fit.\r\n");
                    return;
                }

                /* Added put <missileweap> <quiver> */
                if (container.ItemType == ObjTemplate.ObjectType.quiver
                        && obj.ItemType != ObjTemplate.ObjectType.missile_weapon)
                {
                    SocketConnection.Act("$p&n doesn't belong in $P&n.", ch, obj, container, SocketConnection.MessageTarget.character);
                    return;
                }

                obj.RemoveFromChar();
                container.AddToObject(obj);
                SocketConnection.Act("You put $p&n in $P&n.", ch, obj, container, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n slips $p&n into $P&n.", ch, obj, container, SocketConnection.MessageTarget.room);
                if (obj.Trap != null && obj.Trap.CheckTrigger(Trap.TriggerType.get_put))
                {
                    ch.SetOffTrap(obj);
                }
            }
            else
            {
                /* 'put all container' or 'put all.obj container' */
                bool stuff = false;

                foreach (Object iobj in ch._carrying)
                {
                    if (iobj.WearLocation != ObjTemplate.WearLocation.none)
                    {
                        continue;
                    }

                    if (container.ItemType == ObjTemplate.ObjectType.quiver
                            && iobj.ItemType != ObjTemplate.ObjectType.missile_weapon)
                    {
                        continue;
                    }

                    if ((str[0][3] == '\0' || MUDString.NameContainedIn(str[0].Substring(4), iobj.Name))
                            && CharData.CanSeeObj(ch, iobj) && iobj.WearLocation == ObjTemplate.WearLocation.none
                            && iobj != container && ch.CanDropObject(iobj) && iobj.GetWeight() + container.GetWeight()
                            <= container.Values[0])
                    {
                        iobj.RemoveFromChar();
                        container.AddToObject(iobj);
                        stuff = true;
                        SocketConnection.Act("You put $p&n in $P&n.", ch, iobj, container, SocketConnection.MessageTarget.character);
                        //                Descriptor._actFlags( "$n&n puts $p&n in $P&n.", ch, iobj, container, Descriptor.MessageTarget.room );
                        if (iobj.Trap != null && iobj.Trap.CheckTrigger( Trap.TriggerType.get_put))
                        {
                            ch.SetOffTrap(iobj);
                            if (ch._position == Position.dead)
                            {
                                return;
                            }
                        }
                    }
                    else if (iobj.GetWeight() + container.GetWeight() > container.Values[0] && iobj != container)
                    {
                        SocketConnection.Act("$p&n won't fit into $P&n.", ch, iobj, container, SocketConnection.MessageTarget.character);
                    }
                }
                if (stuff)
                {
                    SocketConnection.Act("$n&n puts some stuff in $P&n.", ch, null, container, SocketConnection.MessageTarget.room);
                }
            }

            return;
        }

        public static void Drop(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object cash;

            if (ch.IsAffected( Affect.AFFECT_HOLD) || ch.IsAffected( Affect.AFFECT_MINOR_PARA))
            {
                ch.SendText("You muscles won't respond!\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Drop what?\r\n");
                return;
            }

            if (MUDString.IsNumber(str[0]))
            {
                /* 'drop NNNN coins' */
                int amount;

                Int32.TryParse(str[0], out amount);

                if (amount <= 0)
                {
                    ch.SendText("Sorry, you can't do that.\r\n");
                    return;
                }

                if (str.Length < 2)
                {
                    ch.SendText("That's fine, but *what* do you want to drop?\r\n");
                    return;
                }

                if ("copper".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
                {
                    if (ch.GetCopper() < amount)
                    {
                        ch.SendText("You haven't got that many &n&+ycopper&n coins.\r\n");
                        return;
                    }
                    ch.SpendCopper(amount);
                    cash = Object.CreateMoney(amount, 0, 0, 0);
                    cash.AddToRoom(ch._inRoom);
                    cash.FlyLevel = ch._flyLevel;
                }
                else if ("silver".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
                {
                    if (ch.GetSilver() < amount)
                    {
                        ch.SendText("You haven't got that many &n&+wsilver&n coins.\r\n");
                        return;
                    }
                    ch.SpendSilver(amount);
                    (Object.CreateMoney(0, amount, 0, 0)).AddToRoom(ch._inRoom);
                }
                else if ("gold".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
                {
                    if (ch.GetGold() < amount)
                    {
                        ch.SendText("You haven't got that many &+Ygold&n coins.\r\n");
                        return;
                    }
                    ch.SpendGold(amount);
                    (Object.CreateMoney(0, 0, amount, 0)).AddToRoom(ch._inRoom);
                }
                else if ("platinum".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
                {
                    if (ch.GetPlatinum() < amount)
                    {
                        ch.SendText("You haven't got that many &+Wplatinum&n coins.\r\n");
                        return;
                    }
                    ch.SpendPlatinum(amount);
                    (Object.CreateMoney(0, 0, 0, amount)).AddToRoom(ch._inRoom);
                }
                else
                {
                    ch.SendText("They haven't minted that type of &+Lcoin&n yet.\r\n");
                    return;
                }

                /* Disabled merging of coin types.  This should eventually be re-enabled
                for ( obj = ch.in_room.contents; obj; obj = obj_next )
                {
                obj_next = obj.next_content;

                switch ( obj.pIndexData.vnum )
                {
                case StaticObjects.OBJECT_NUMBER_MONEY_ONE:
                amount += 1;
                obj.ExtractFromWorld();;
                break;

                case StaticObjects.OBJECT_NUMBER_MONEY_SOME:
                amount += obj.value[0];
                obj.ExtractFromWorld();;
                break;
                }
                }
                */
                ch.SendText("Done.\r\n");
                SocketConnection.Act("$n&n drops some &n&+wcoins&n.", ch, null, null, SocketConnection.MessageTarget.room);
                return;
            }

            if (str[0] != "all" && MUDString.IsPrefixOf("all.", str[0]))
            {
                /* 'drop iobj' */
                Object iobj = ch.GetObjCarrying(str[0]);
                if (!iobj)
                {
                    ch.SendText("You do not have that item.\r\n");
                    return;
                }

                if (!ch.CanDropObject(iobj))
                {
                    ch.SendText("You can't release your grip on it.\r\n");
                    return;
                }

                iobj.RemoveFromChar();
                iobj.AddToRoom(ch._inRoom);

                // Prevent item duping - Xangis
                CharData.SavePlayer(ch);

                iobj.FlyLevel = ch._flyLevel;
                SocketConnection.Act("You drop $p&n.", ch, iobj, null, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n discards $p&n.", ch, iobj, null, SocketConnection.MessageTarget.room);
                if (iobj.HasFlag(ObjTemplate.ITEM_TRANSIENT))
                {
                    SocketConnection.Act("$p&n crumbles to dust.", ch, iobj, null, SocketConnection.MessageTarget.all);
                    iobj.RemoveFromWorld();
                }
                else if (ch._inRoom.TerrainType == TerrainType.lava && !iobj.HasFlag(ObjTemplate.ITEM_NOBURN))
                {
                    SocketConnection.Act("$p&n melts as it sinks into the &+RLava&n.", ch, iobj, null, SocketConnection.MessageTarget.all);
                    if (!ch.IsNPC())
                    {
                        ((PC)ch).Destroyed.AddItem(iobj);
                    }
                    iobj.RemoveFromWorld();
                }
            }
            else
            {
                /* 'drop all' or 'drop all.obj' */
                bool found = false;
                for (int i = ch._carrying.Count - 1; i >= 0 ; i--)
                {
                    Object obj = ch._carrying[i];
                    if ( (str.Length < 2 || MUDString.NameContainedIn(str[0].Substring(4), obj.Name))
                            && CharData.CanSeeObj(ch, obj)
                            && obj.WearLocation == ObjTemplate.WearLocation.none
                            && ch.CanDropObject(obj))
                    {
                        found = true;
                        obj.RemoveFromChar();
                        obj.AddToRoom(ch._inRoom);
                        SocketConnection.Act("You drop $p&n.", ch, obj, null, SocketConnection.MessageTarget.character);
                        SocketConnection.Act("$n&n drops $p&n.", ch, obj, null, SocketConnection.MessageTarget.room);
                        if (obj.HasFlag(ObjTemplate.ITEM_TRANSIENT))
                        {
                            SocketConnection.Act("$p&n crumbles to dust.", ch, obj, null, SocketConnection.MessageTarget.all);
                            if (!ch.IsNPC())
                            {
                                ((PC)ch).Destroyed.AddItem(obj);
                            }
                            obj.RemoveFromWorld();
                        }
                        else if (ch._inRoom.TerrainType == TerrainType.lava && !obj.HasFlag(ObjTemplate.ITEM_NOBURN))
                        {
                            SocketConnection.Act("$p&n melts as it sinks into the &+RLava&n.", ch, obj, null, SocketConnection.MessageTarget.all);
                            if (!ch.IsNPC())
                            {
                                ((PC)ch).Destroyed.AddItem(obj);
                            }
                            obj.RemoveFromWorld();
                        }
                    }
                }

                if (!found)
                {
                    if (str.Length > 1)
                    {
                        ch.SendText("You are not carrying anything.");
                    }
                    else
                    {
                        SocketConnection.Act("You are not carrying any $T&n.",
                             ch, null, str[0].Substring(4), SocketConnection.MessageTarget.character);
                    }
                }
            }
            return;
        }

        public static void Give(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;
            string arg1 = String.Empty;
            string arg2 = String.Empty;

            if (String.IsNullOrEmpty(arg1) || String.IsNullOrEmpty(arg2))
            {
                ch.SendText("Give what to whom?\r\n");
                return;
            }

            if (MUDString.IsNumber(arg1))
            {
                /* 'give NNNN coins victim' */
                string buf;
                string arg3 = String.Empty;
                int amount;

                Int32.TryParse(arg1, out amount);
                if (amount <= 0)
                {
                    ch.SendText("Sorry, you can't do that.\r\n");
                    return;
                }

                if (String.IsNullOrEmpty(arg3))
                {
                    ch.SendText("Give what to whom?\r\n");
                    return;
                }

                victim = ch.GetCharRoom(arg3);
                if (victim == null)
                {
                    ch.SendText("They aren't here.\r\n");
                    return;
                }

                if (!MUDString.IsPrefixOf(arg2, "copper"))
                {
                    if (ch.GetCopper() < amount)
                    {
                        ch.SendText("You haven't got that many &+ycopper&n coins.\r\n");
                        return;
                    }
                    ch.SpendCopper(amount);
                    SocketConnection.Act("You give $N&n some &+ycopper&n.", ch, null, victim, SocketConnection.MessageTarget.character);
                    buf = String.Format("$n&n gives you {0} &+ycopper&n.", amount);
                    SocketConnection.Act(buf, ch, null, victim, SocketConnection.MessageTarget.victim);
                    SocketConnection.Act("$n&n gives $N&n some &+ycopper&n.", ch, null, victim, SocketConnection.MessageTarget.everyone_but_victim);
                    //            prog_bribe_trigger( victim, ch, amount );
                    if (!ch.CheckQuest(victim, null, amount))
                    {
                        victim.ReceiveCopper(amount);
                    }
                    // Prevent money duping
                    CharData.SavePlayer(ch);
                    CharData.SavePlayer(victim);
                    return;
                }
                if (!MUDString.IsPrefixOf(arg2, "silver"))
                {
                    if (ch.GetSilver() < amount)
                    {
                        ch.SendText("You haven't got that many silver coins.\r\n");
                        return;
                    }
                    ch.SpendSilver(amount);
                    SocketConnection.Act("You give $N&n some silver.", ch, null, victim, SocketConnection.MessageTarget.character);
                    buf = String.Format("$n&n gives you {0} silver.", amount);
                    SocketConnection.Act(buf, ch, null, victim, SocketConnection.MessageTarget.victim);
                    SocketConnection.Act("$n&n gives $N&n some silver.", ch, null, victim, SocketConnection.MessageTarget.everyone_but_victim);
                    //            prog_bribe_trigger( victim, ch, amount * 10);
                    if (!ch.CheckQuest(victim, null, (amount * 10)))
                        victim.ReceiveSilver(amount);
                    // Prevent money duping
                    CharData.SavePlayer(ch);
                    CharData.SavePlayer(victim);
                    return;
                }
                if (!MUDString.IsPrefixOf(arg2, "gold"))
                {
                    if (ch.GetGold() < amount)
                    {
                        ch.SendText("You haven't got that many &+Ygold&n coins.\r\n");
                        return;
                    }
                    ch.SpendGold(amount);
                    SocketConnection.Act("You give $N&n some &+Ygold&n.", ch, null, victim, SocketConnection.MessageTarget.character);
                    buf = String.Format("$n&n gives you {0} &+Ygold&n.", amount);
                    SocketConnection.Act(buf, ch, null, victim, SocketConnection.MessageTarget.victim);
                    SocketConnection.Act("$n&n gives $N&n some &+Ygold&n.", ch, null, victim, SocketConnection.MessageTarget.everyone_but_victim);
                    //            prog_bribe_trigger( victim, ch, amount *100);
                    if (!ch.CheckQuest(victim, null, (amount * 100)))
                    {
                        victim.ReceiveGold(amount);
                    }
                    // Prevent money duping
                    CharData.SavePlayer(ch);
                    CharData.SavePlayer(victim);
                    return;
                }
                if (!MUDString.IsPrefixOf(arg2, "platinum"))
                {
                    if (ch.GetPlatinum() < amount)
                    {
                        ch.SendText("You haven't got that many &+Wplatinum&n coins.\r\n");
                        return;
                    }
                    ch.SpendPlatinum(amount);
                    SocketConnection.Act("You give $N&n some &+Wplatinum&n.", ch, null, victim, SocketConnection.MessageTarget.character);
                    buf = String.Format("$n&n gives you {0} &+Wplatinum&n.", amount);
                    SocketConnection.Act(buf, ch, null, victim, SocketConnection.MessageTarget.victim);
                    SocketConnection.Act("$n&n gives $N&n some &+Wplatinum&n.", ch, null, victim, SocketConnection.MessageTarget.everyone_but_victim);
                    //            prog_bribe_trigger( victim, ch, amount* 1000 );
                    if (!ch.CheckQuest(victim, null, (amount * 1000)))
                    {
                        victim.ReceivePlatinum(amount);
                    }
                    // Prevent money duping
                    CharData.SavePlayer(ch);
                    CharData.SavePlayer(victim);
                    return;
                }
                ch.SendText("You don't have any of _that_ type of coin yet.\r\n");
                return;
            }

            Object obj = ch.GetObjCarrying(arg1);
            if (!obj)
            {
                ch.SendText("You do not have that item.\r\n");
                return;
            }

            if (obj.WearLocation != ObjTemplate.WearLocation.none)
            {
                ch.SendText("You must remove it first.\r\n");
                return;
            }

            victim = ch.GetCharRoom(arg2);
            if (victim == null)
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (!ch.CanDropObject(obj))
            {
                ch.SendText("You couldn't possibly part with it.\r\n");
                return;
            }

            /*
            * How silly of shopkeepers to refuse blessed items... previously vampires would
            * refuse blessed items... now all undead types refuse blessed items.
            */
            if (obj.HasFlag(ObjTemplate.ITEM_BLESS) && victim.IsUndead())
            {
                SocketConnection.Act("$N&n refuses to touch the blessed $p&n.", ch, obj, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n tries to give $N&n a $p&n but $E refuses.", ch, obj, victim, SocketConnection.MessageTarget.room);
                SocketConnection.Act("You refuse to accept the blessed $p&n from $n&n.", ch, obj, victim, SocketConnection.MessageTarget.victim);
                return;
            }

            if (victim._carryNumber + 1 > Limits.MAX_CARRY)
            {
                SocketConnection.Act("$N&n has $S hands full.", ch, null, victim, SocketConnection.MessageTarget.character);
                return;
            }

            if (victim._carryWeight + obj.GetWeight() > victim.MaxCarryWeight())
            {
                SocketConnection.Act("$N&n can't carry that much weight.", ch, null, victim, SocketConnection.MessageTarget.character);
                return;
            }

            if (!CharData.CanSeeObj(victim, obj))
            {
                SocketConnection.Act("$N&n can't see it.", ch, null, victim, SocketConnection.MessageTarget.character);
                return;
            }

            obj.RemoveFromChar();
            obj.ObjToChar(victim);

            // Prevent item duplication.
            CharData.SavePlayer(ch);
            CharData.SavePlayer(victim);

            SocketConnection.Act("You give $p&n to $N&n.", ch, obj, victim, SocketConnection.MessageTarget.character);
            SocketConnection.Act("$n&n gives you $p&n.", ch, obj, victim, SocketConnection.MessageTarget.victim);
            SocketConnection.Act("$n&n gives $p&n to $N&n.", ch, obj, victim, SocketConnection.MessageTarget.everyone_but_victim);

            //    prog_give_trigger( victim, ch, obj );

            if (Database.IsArtifact(obj.ObjIndexData.IndexNumber))
            {
                string buf = String.Format("{0} has given artifact {1} to {2}", ch._name, obj.ObjIndexData.IndexNumber, victim._name);
                Log.Trace(buf);
            }

            if (!victim.IsNPC())
            {
                return;
            }

            // Destroy the item so they can't kill the mob for the item.
            if (ch.CheckQuest(victim, obj, 0))
            {
                obj.RemoveFromWorld();
            }
            return;
        }

        public static void Brew(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object potion;
            Spell spell;

            if (str.Length == 0)
            {
                ch.SendText("Which spell do you want to brew into a &+Lpotion&n?\r\n");
                return;
            }

            if (!(potion = Object.GetEquipmentOnCharacter(ch, ObjTemplate.WearLocation.hand_one)))
            {
                ch.SendText("You hold nothing in your hand.\r\n");
                return;
            }

            if (potion.ItemType != ObjTemplate.ObjectType.potion)
            {
                ch.SendText("You are not holding a vial.\r\n");
                return;
            }

            if ((spell = StringLookup.SpellLookup(str[0])) == null)
            {
                ch.SendText("You don't know any spells by that _name.\r\n");
                return;
            }

            if (spell.ValidTargets != TargetType.singleCharacterDefensive
                    && spell.ValidTargets != TargetType.self)
            {
                ch.SendText("You cannot brew that spell.\r\n");
                return;
            }

            SocketConnection.Act("$n begins preparing a &+Lpotion&n.", ch, potion, null, SocketConnection.MessageTarget.room);
            ch.WaitState(Skill.SkillList["brew"].Delay);

            ch.PracticeSkill("brew");

            if (!ch.IsNPC() && (MUDMath.NumberPercent() > ((PC)ch).SkillAptitude["brew"] ||
                MUDMath.NumberPercent() > ((ch.GetCurrInt() - 13) * 5 + (ch.GetCurrWis() - 13) * 3)))
            {
                SocketConnection.Act("$p&n explodes violently!", ch, potion, null, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$p&n explodes violently!", ch, potion, null, SocketConnection.MessageTarget.room);
                potion.RemoveFromWorld();
                Combat.InflictDamage(ch, ch, ch.GetMaxHit() / 16, "brew", ObjTemplate.WearLocation.none, AttackType.DamageType.energy);
                return;
            }

            potion.Level = ch._level / 2;
            potion.Values[0] = ch._level / 4;
            ch.ImprintSpell(spell, ch._level, potion);
            return;
        }

        public static void ScribeScroll(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object scroll;
            Spell spell;

            if (String.IsNullOrEmpty(str[0]))
            {
                ch.SendText("Scribe what spell?\r\n");
                return;
            }

            if (!(scroll = Object.GetEquipmentOnCharacter(ch, ObjTemplate.WearLocation.hand_one)))
            {
                ch.SendText("You hold nothing in your hand.\r\n");
                return;
            }

            if (scroll.ItemType != ObjTemplate.ObjectType.scroll)
            {
                ch.SendText("You are not holding a &+Wparchment&n.\r\n");
                return;
            }

            if ((spell = StringLookup.SpellLookup(str[0])) == null)
            {
                ch.SendText("You don't know any spells by that _name.\r\n");
                return;
            }

            SocketConnection.Act("$n begins writing a &+Wscroll&n.", ch, scroll, null, SocketConnection.MessageTarget.room);
            ch.WaitState(Skill.SkillList["Scribe"].Delay);

            ch.PracticeSkill("Scribe");

            if (!ch.IsNPC()
                    && (MUDMath.NumberPercent() > ((PC)ch).SkillAptitude["brew"] ||
                         MUDMath.NumberPercent() > ((ch.GetCurrInt() - 13) * 5 +
                                               (ch.GetCurrWis() - 13) * 3)))
            {
                SocketConnection.Act("$p&n bursts in &n&+rflames&n!", ch, scroll, null, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$p&n bursts in &+Rflames&n!", ch, scroll, null, SocketConnection.MessageTarget.room);
                scroll.RemoveFromWorld();
                Combat.InflictDamage(ch, ch, ch.GetMaxHit(), "Scribe", ObjTemplate.WearLocation.none, AttackType.DamageType.fire);
                return;
            }

            scroll.Level = ch._level * 2 / 3;
            scroll.Values[0] = ch._level / 3;
            ch.ImprintSpell(spell, ch._level, scroll);
            return;
        }

        public static void Deposit(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int coinage;
            bool success = false;
            Coins coin = new Coins();

            if (ch.IsNPC())
            {
                ch.SendText("NPCs do not have bank accounts!\r\n");
                return;
            }

            if (!ch._inRoom || !ch._inRoom.HasFlag(RoomTemplate.ROOM_BANK))
            {
                ch.SendText("You're not in a bank!\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Deposit what?\r\n");
                return;
            }
            if (!coin.FillFromString(str, ch))
            {
                ch.SendText("&+LSyntax:  &+RDeposit &n&+r<&+L# of coins&n&+r> <&+Lcoin type&n&+r>&n\r\n");
                return;
            }
            if (coin.Copper == 0 && coin.Silver == 0 && coin.Gold == 0 && coin.Platinum == 0)
            {
                ch.SendText("You have none of that type of &+Lcoin&n yet.\r\n");
                return;
            }
            for (coinage = 0; coinage < 4; coinage++)
            {
                switch (coinage)
                {
                    case 0: //copper
                        if (coin.Copper < 0)
                        {
                            ch.SendText("You can't deposit a debt!\r\n");
                            continue;
                        }
                        if (coin.Copper > ch.GetCopper())
                        {
                            ch.SendText("You don't have that much &+ycopper&n coin!\r\n");
                            continue;
                        }
                        if (coin.Copper == 0)
                            continue;
                        ch.SpendCopper(coin.Copper);
                        ((PC)ch).Bank.Copper += coin.Copper;
                        success = true;
                        break;
                    case 1: //silver
                        if (coin.Silver < 0)
                        {
                            ch.SendText("You can't deposit a debt!\r\n");
                            continue;
                        }
                        if (coin.Silver > ch.GetSilver())
                        {
                            ch.SendText("You don't have that much &+wsilver&n coin!\r\n");
                            continue;
                        }
                        if (coin.Silver == 0)
                            continue;
                        ch.SpendSilver(coin.Silver);
                        ((PC)ch).Bank.Silver += coin.Silver;
                        success = true;
                        break;
                    case 2: //gold
                        if (coin.Gold < 0)
                        {
                            ch.SendText("You can't deposit a debt!\r\n");
                            continue;
                        }
                        if (coin.Gold > ch.GetGold())
                        {
                            ch.SendText("You don't have that much &+Ygold&n coin!\r\n");
                            continue;
                        }
                        if (coin.Gold == 0)
                            continue;
                        ch.SpendGold(coin.Gold);
                        ((PC)ch).Bank.Gold += coin.Gold;
                        success = true;
                        break;
                    case 3: //platinum
                        if (coin.Platinum < 0)
                        {
                            ch.SendText("You can't deposit a debt!\r\n");
                            continue;
                        }
                        if (coin.Platinum > ch.GetPlatinum())
                        {
                            ch.SendText("You don't have that much &+Wplatinum&n coin!\r\n");
                            continue;
                        }
                        if (coin.Platinum == 0)
                            continue;
                        ch.SpendPlatinum(coin.Platinum);
                        ((PC)ch).Bank.Platinum += coin.Platinum;
                        success = true;
                        break;
                } //end switch
            } //end for
            if (success)
            {
                ch.SendText("You make your deposit.\r\n");
                SocketConnection.Act("$n&n makes a transaction.", ch, null, null, SocketConnection.MessageTarget.room);
            }
            else
            {
                ch.SendText("&+LSyntax:  &+RDeposit &n&+r<&+L# of coins&n&+r> <&+Lcoin type&n&+r>&n\r\n");
            }
            return;
        }

        /// <summary>
        /// Take money out of your bank account.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Withdraw(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int coinage;
            bool success = false;
            Coins coin = new Coins();

            if (ch.IsNPC())
            {
                return;
            }

            if (!ch._inRoom || !ch._inRoom.HasFlag(RoomTemplate.ROOM_BANK))
            {
                ch.SendText("You're not in a bank!\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Withdraw what?\r\n");
                return;
            }
            if (!coin.FillFromString(str, ch))
            {
                ch.SendText("&+LSyntax:  &+RWithdraw &n&+r<&+L# of coins&n&+r> <&+Lcoin type&n&+r>&n\r\n");
                return;
            }
            if (coin.Copper == 0 && coin.Silver == 0 && coin.Gold == 0 && coin.Platinum == 0)
            {
                ch.SendText("The bank has none of that type of &+Lcoin&n yet.\r\n");
                return;
            }
            for (coinage = 0; coinage < 4; coinage++)
            {
                switch (coinage)
                {
                    case 0: //copper
                        if (coin.Copper < 0)
                        {
                            ch.SendText("You can't liquidate a debt!\r\n");
                            continue;
                        }
                        if (coin.Copper > ((PC)ch).Bank.Copper)
                        {
                            ch.SendText("You haven't saved that much &+ycopper&n coin!\r\n");
                            continue;
                        }
                        if (coin.Copper == 0)
                            continue;
                        ch.ReceiveCopper(coin.Copper);
                        ((PC)ch).Bank.Copper -= coin.Copper;
                        success = true;
                        break;
                    case 1: //silver
                        if (coin.Silver < 0)
                        {
                            ch.SendText("You can't liquidate a debt!\r\n");
                            continue;
                        }
                        if (coin.Silver > ((PC)ch).Bank.Silver)
                        {
                            ch.SendText("You haven't saved that much &+wsilver&n coin!\r\n");
                            continue;
                        }
                        if (coin.Silver == 0)
                            continue;
                        ch.ReceiveSilver(coin.Silver);
                        ((PC)ch).Bank.Silver -= coin.Silver;
                        success = true;
                        break;
                    case 2: //gold
                        if (coin.Gold < 0)
                        {
                            ch.SendText("You can't liquidate a debt!\r\n");
                            continue;
                        }
                        if (coin.Gold > ((PC)ch).Bank.Gold)
                        {
                            ch.SendText("You haven't saved that much &+Ygold&n coin!\r\n");
                            continue;
                        }
                        if (coin.Gold == 0)
                            continue;
                        ch.ReceiveGold(coin.Gold);
                        ((PC)ch).Bank.Gold -= coin.Gold;
                        success = true;
                        break;
                    case 3: //platinum
                        if (coin.Platinum < 0)
                        {
                            ch.SendText("You can't liquidate a debt!\r\n");
                            continue;
                        }
                        if (coin.Platinum > ((PC)ch).Bank.Platinum)
                        {
                            ch.SendText("You haven't saved that much &+Wplatinum&n coin!\r\n");
                            continue;
                        }
                        if (coin.Platinum == 0)
                            continue;
                        ch.ReceivePlatinum(coin.Platinum);
                        ((PC)ch).Bank.Platinum -= coin.Platinum;
                        success = true;
                        break;
                } //end switch
            } //end for
            if (success)
            {
                ch.SendText("You make a withdrawal.\r\n");
                SocketConnection.Act("$n&n makes a transaction.", ch, null, null, SocketConnection.MessageTarget.room);
            }
            else
            {
                ch.SendText("&+LSyntax:  &+RDeposit &n&+r<&+L# of coins&n&+r> <&+Lcoin type&n&+r>&n\r\n");
            }
            return;
        }

        // Rewritten by Xangis 5-30-00
        // now calls equip_hand to resolve eq placement
        public static void Hold(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object obj;

            if (ch.IsAffected( Affect.AFFECT_HOLD) ||
                    ch.IsAffected( Affect.AFFECT_MINOR_PARA))
            {
                ch.SendText("You can't move!\r\n");
                return;
            }

            if (!ch.IsNPC() && ch.IsAffected( Affect.AFFECT_WRAITHFORM))
            {
                ch.SendText("You may not wear, wield, or hold anything in &+Wghoul&n form.\r\n");
                return;
            }

            if (str.Length == 0 || (obj = ch.GetObjCarrying(str[0])) == null)
            {
                ch.SendText("Hold what now?\r\n");
                return;
            }

            // Light items are automatically holdable.
            if (!obj.HasWearFlag(ObjTemplate.WEARABLE_HOLD) && obj.ItemType != ObjTemplate.ObjectType.light)
            {
                ch.SendText("You can't hold that!\r\n");
                return;
            }

            if (obj.ItemType == ObjTemplate.ObjectType.weapon || obj.ItemType == ObjTemplate.ObjectType.ranged_weapon)
            {
                ch.SendText("You WIELD weapons, they're useless if you hold them.\r\n");
                return;
            }

            if (!obj.IsWearableBy(ch))
                return;

            if (Object.EquipInHand(ch, obj, Object.EQUIP_HOLD))
            {
                SocketConnection.Act("You hold $p&n.", ch, obj, null, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n holds $p&n.", ch, obj, null, SocketConnection.MessageTarget.room);
            }

            return;
        }

        /// <summary>
        /// Used for dragging corpses into another room.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Drag(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object obj;
            Object obj2;

            if (ch.IsAffected( Affect.AFFECT_HOLD) ||
                    ch.IsAffected(Affect.AFFECT_MINOR_PARA))
            {
                ch.SendText("You can't move!\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Drag which what where?\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("You need to specify a direction.\r\n");
                return;
            }

            if (!ch.IsNPC() && ch.HasActBit(PC.PLAYER_MEMORIZING))
            {
                ch.RemoveActBit(PC.PLAYER_MEMORIZING);
                ch.SendText("You abandon your studies.\r\n");
            }

            if (!(obj = ch.GetObjHere(str[0])))
            {
                ch.SendText("You do not see that here.\r\n");
                return;
            }

            if (obj.ItemType != ObjTemplate.ObjectType.npc_corpse && obj.ItemType != ObjTemplate.ObjectType.pc_corpse)
            {
                ch.SendText("You can only drag corpses.\r\n");
                return;
            }

            if (str.Length > 2 && str[1] == "enter")
            {
                if ((obj2 = ch.GetObjHere(str[3])))
                {
                    switch (obj2.ItemType)
                    {
                        case ObjTemplate.ObjectType.teleport:
                        case ObjTemplate.ObjectType.portal:
                            if (obj2.ItemType == ObjTemplate.ObjectType.teleport && !CommandType.CheckCommandTrigger("enter", obj2.Values[1]))
                            {
                                ch.SendText("Nothing happens.\r\n");
                                return;
                            };
                            Room location;
                            if (Macros.IsSet(obj2.Values[3], ObjTemplate.PORTAL_RANDOM))
                            {
                                location = Movement.GetRandomRoom();
                            }
                            else
                            {
                                location = Room.GetRoom(obj2.Values[0]);
                            }
                            if (!location)
                            {
                                ch.SendText("That portal doesn't seem to go anywhere.\r\n");
                                return;
                            }
                            SocketConnection.Act("You drag the $p&n into $P&n.", ch, obj, obj2, SocketConnection.MessageTarget.character);
                            SocketConnection.Act("$n&n drags the $p&n into $P&n.", ch, obj, obj2, SocketConnection.MessageTarget.room);
                            if (obj2.Values[2] >= 0)
                            {
                                obj2.Values[2] -= 2;
                                if (obj2.Values[2] <= 0)
                                {
                                    SocketConnection.Act("$p&n fades into nothingness.", ch, obj2, null, SocketConnection.MessageTarget.room);
                                    obj2.RemoveFromRoom();
                                }
                            }
                            obj.RemoveFromRoom();
                            ch.RemoveFromRoom();
                            ch.AddToRoom(location);
                            obj.AddToRoom(location);
                            if (obj2.ItemType == ObjTemplate.ObjectType.portal)
                            {
                                SocketConnection.Act("$n&n steps out of $P&n dragging the $p&n.", ch, obj, obj2, SocketConnection.MessageTarget.room);
                            }
                            else
                            {
                                SocketConnection.Act("$n&n appears from elsewhere, dragging the $p&n.", ch, obj, null, SocketConnection.MessageTarget.room);
                            }
                            CommandType.Interpret(ch, "look auto");
                            return;
                        case ObjTemplate.ObjectType.vehicle:
                        case ObjTemplate.ObjectType.ship:
                            break;
                        case ObjTemplate.ObjectType.other:
                            break;
                        default:
                            ch.SendText("That cannot be entered.\r\n");
                            return;
                    }
                }
            }

            int door = Movement.FindExit(ch, str[1]);

            if (door < 0)
            {
                ch.SendText("You can't drag anything that way.\r\n");
                return;
            }
            if (ch._currentMoves < 5 && !ch.IsImmortal())
            {
                ch.SendText("You are too exhausted to drag that anywhere.\r\n");
                return;
            }

            string text = String.Format("You drag $p&n {0}.", Exit.DirectionName[door]);
            SocketConnection.Act(text, ch, obj, null, SocketConnection.MessageTarget.character);
            text = String.Format("$n&n drags $p&n {0}.", Exit.DirectionName[door]);
            SocketConnection.Act(text, ch, obj, null, SocketConnection.MessageTarget.room);

            obj.RemoveFromRoom();
            ch._currentMoves -= 5;

            ch.Move(door);
            ch.WaitState(MUDMath.NumberRange(3, 12));

            obj.AddToRoom(ch._inRoom);
            SocketConnection.Act("$n&n drags $p&n along behind $m.", ch, obj, null, SocketConnection.MessageTarget.room);
        }

        /// <summary>
        /// Auction command.  The game does not support auctions.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Auction(CharData ch, string[] str)
        {
            if( ch == null ) return;

            ch.SendText("There is no such thing as auction.\r\n");
            return;
        }

        public static void Pour(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object obj;
            string arg1 = String.Empty;
            string arg2 = String.Empty;

            if (ch.IsBlind())
                return;

            if (!(obj = ch.GetObjCarrying(arg1)))
            {
                ch.SendText("You do not have that item.\r\n");
                return;
            }

            if (obj.ItemType != ObjTemplate.ObjectType.drink_container)
            {
                ch.SendText("You can't fill that.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual("out", arg2))
            {
                ch.SendText("You pour it out.\r\n");
                obj.Values[1] = 0;
                return;
            }

            Object otherobj = ch.GetObjHere(arg2);
            if (!otherobj)
            {
                ch.SendText("Pour it where?\r\n");
                return;
            }

            if (otherobj.Values[2] != obj.Values[2] && otherobj.Values[1] != 0)
            {
                ch.SendText("It's got another liquid in it.\r\n");
                return;
            }

            SocketConnection.Act("You fill $p&n.", ch, otherobj, null, SocketConnection.MessageTarget.character);
            otherobj.Values[2] = obj.Values[2];
            otherobj.Values[1] += obj.Values[1];
            obj.Values[1] = 0;
            // Over pour in code => just pour it back in the first container.
            if (otherobj.Values[1] > otherobj.Values[0])
            {
                obj.Values[1] = otherobj.Values[1] - otherobj.Values[0];
                otherobj.Values[1] = otherobj.Values[0];
            }
            return;
        }

        /// <summary>
        /// Put on a piece of equipment.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Wear(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object obj;

            if (ch.IsAffected(Affect.AFFECT_HOLD) || ch.IsAffected(Affect.AFFECT_MINOR_PARA))
            {
                ch.SendText("Your body refuses the call to movement.\r\n");
                return;
            }

            if (!ch.IsNPC() && ch.IsAffected( Affect.AFFECT_WRAITHFORM))
            {
                ch.SendText("You try, but your &n&+wghoul&n form resists your attempts.\r\n");
                return;
            }

            if (ch._fighting || ch._position == Position.fighting)
            {
                ch.SendText("You can't wear stuff while you're fighting!\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Wear, wield, or hold what?\r\n");
                return;
            }

            if (str[0] == "all")
            {
                foreach (Object iobj in ch._carrying)
                {
                    if (iobj.WearLocation != ObjTemplate.WearLocation.none || !CharData.CanSeeObj(ch, iobj))
                    {
                        continue;
                    }

                    if (iobj.HasWearFlag(ObjTemplate.WEARABLE_WIELD)
                            && !ch.HasInnate(Race.RACE_WEAPON_WIELD))
                    {
                        continue;
                    }

                    Object.WearObject(ch, iobj, false);
                    if (iobj.Trap != null && iobj.Trap.CheckTrigger( Trap.TriggerType.wear))
                    {
                        ch.SetOffTrap(iobj);
                        if (ch._position == Position.dead)
                        {
                            return;
                        }
                    }
                }
                return;
            }
            if (!(obj = ch.GetObjCarrying(str[0])))
            {
                ch.SendText("You do not have that item.\r\n");
                return;
            }

            if (obj.HasWearFlag(ObjTemplate.WEARABLE_WIELD)
                && !ch.HasInnate(Race.RACE_WEAPON_WIELD))
            {
                ch.SendText("You are not able to wield a weapon.\r\n");
                return;
            }

            Object.WearObject(ch, obj, true);
            if (obj.Trap != null && obj.Trap.CheckTrigger( Trap.TriggerType.wear))
            {
                ch.SetOffTrap(obj);
                if (ch._position == Position.dead)
                {
                    return;
                }
            }

            return;
        }

        /// <summary>
        /// Equip a weapon.  Now calls equip_hand to resolve the actual equipping 
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Wield(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object obj;

            if (ch.IsAffected(Affect.AFFECT_HOLD) || ch.IsAffected( Affect.AFFECT_MINOR_PARA))
            {
                ch.SendText("Your body refuses the call to movement.\r\n");
                return;
            }

            if (!ch.IsNPC() && ch.IsAffected( Affect.AFFECT_WRAITHFORM))
            {
                ch.SendText("You try, but your &n&+wghoul&n form resists your  attempts.\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Wield what?\r\n");
                return;
            }

            if (!(obj = ch.GetObjCarrying(str[0])))
            {
                ch.SendText("You do not have that item.\r\n");
                return;
            }

            if (!obj.HasWearFlag(ObjTemplate.WEARABLE_WIELD))
            {
                if (obj.ItemType == ObjTemplate.ObjectType.weapon)
                {
                    ch.SendText("That object is not usable as a weapon.\r\n");
                    return;
                }
                if (obj.ItemType == ObjTemplate.ObjectType.ranged_weapon && !obj.HasWearFlag(ObjTemplate.WEARABLE_HOLD))
                {
                    ch.SendText("That object is not usable as a missile weapon.\r\n");
                    return;
                }
                if (obj.ItemType == ObjTemplate.ObjectType.ranged_weapon)
                {
                    // Ranged weapons flagged wither wield or hold are fine to use -- Xangis
                }
                else
                {
                    ch.SendText("That object is not a weapon.\r\n");
                    return;
                }
            }

            if (!ch.HasInnate(Race.RACE_WEAPON_WIELD))
            {
                ch.SendText("You are not able to wield a weapon.\r\n");
                return;
            }

            if (!obj.IsWearableBy(ch))
                return;

            Object.EquipInHand(ch, obj, Object.EQUIP_WIELD);

            return;
        }

        public static void Remove(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object obj;

            if (ch.IsAffected(Affect.AFFECT_HOLD) || ch.IsAffected(Affect.AFFECT_MINOR_PARA))
            {
                ch.SendText("You no longer have control of your body!\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Remove what?\r\n");
                return;
            }

            if (str[0] != "all" && MUDString.IsPrefixOf("all.", str[0]))
            {
                /* 'remove obj' */
                if (!(obj = ch.GetObjWear(str[0])))
                {
                    ch.SendText("You do not have that item.\r\n");
                    return;
                }

                if (ch._carryNumber + 1 > Limits.MAX_CARRY)
                {
                    ch.SendText("You have your hands full.\r\n");
                    return;
                }

                ch.RemoveObject(obj.WearLocation, true);
                if (obj.Trap != null && obj.Trap.CheckTrigger( Trap.TriggerType.unequip))
                {
                    ch.SetOffTrap(obj);
                    if (ch._position == Position.dead)
                        return;
                }
            }
            else
            {
                /* 'remove all' or 'remove all.obj' */
                bool found = false;
                foreach (Object iobj in ch._carrying)
                {
                    if (str.Length < 2 || (MUDString.NameContainedIn(str[0].Substring(4), iobj.Name)
                            && iobj.WearLocation != ObjTemplate.WearLocation.none))
                    {
                        found = true;
                        if (ch._carryNumber + 1 > Limits.MAX_CARRY)
                        {
                            ch.SendText("You have your hands full.\r\n");
                            return;
                        }
                        ch.RemoveObject(iobj.WearLocation, true);
                        if (iobj.Trap != null && iobj.Trap.CheckTrigger(Trap.TriggerType.unequip))
                        {
                            ch.SetOffTrap(iobj);
                            if (ch._position == Position.dead)
                            {
                                return;
                            }
                        }
                    }
                }

                if (!found)
                {
                    if (str.Length == 0 || str[0].Length < 4)
                    {
                        ch.SendText("You can't find anything to remove.\r\n");
                    }
                    else
                    {
                        SocketConnection.Act("You can't find any $T&n to remove.",
                             ch, null, str[0].Substring(4), SocketConnection.MessageTarget.character);
                    }
                }
            }

            return;
        }

        /// <summary>
        /// Quaff: Drink a potion.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Quaff(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object obj;

            if (str.Length == 0)
            {
                ch.SendText("Quaff what?\r\n");
                return;
            }

            if (!(obj = ch.GetObjCarrying(str[0])))
            {
                ch.SendText("You do not have that potion.\r\n");
                return;
            }

            if (obj.ItemType != ObjTemplate.ObjectType.potion)
            {
                ch.SendText("You can quaff only potions.\r\n");
                return;
            }

            SocketConnection.Act("You quaff $p&n.", ch, obj, null, SocketConnection.MessageTarget.character);
            SocketConnection.Act("$n&n drains $p&n.", ch, obj, null, SocketConnection.MessageTarget.room);

            ch.WaitState(3);

            if (obj.ObjIndexData.IndexNumber == StaticObjects.OBJECT_NUMBER_51_POTION)
            {
                obj.RemoveFromWorld();
                ;
                if (ch._level != 50 || ch._experiencePoints < ExperienceTable.Table[ch._level].LevelExperience)
                {
                    ch.SendText("Nothing happens.\r\n");
                    return;
                }
                ch.AdvanceLevel(true);
            }
            if (obj.ObjIndexData.IndexNumber == StaticObjects.OBJECT_NUMBER_52_POTION)
            {
                obj.RemoveFromWorld();
                if (ch._level != 51 || ch._experiencePoints < ExperienceTable.Table[ch._level].LevelExperience)
                {
                    ch.SendText("Nothing happens.\r\n");
                    return;
                }
                ch.AdvanceLevel(true);
            }
            if (obj.ObjIndexData.IndexNumber == StaticObjects.OBJECT_NUMBER_53_POTION)
            {
                obj.RemoveFromWorld();
                if (ch._level != 52 || ch._experiencePoints < ExperienceTable.Table[ch._level].LevelExperience)
                {
                    ch.SendText("Nothing happens.\r\n");
                    return;
                }
                ch.AdvanceLevel(true);
            }
            if (obj.ObjIndexData.IndexNumber == StaticObjects.OBJECT_NUMBER_54_POTION)
            {
                obj.RemoveFromWorld();
                if (ch._level != 53 || ch._experiencePoints < ExperienceTable.Table[ch._level].LevelExperience)
                {
                    ch.SendText("Nothing happens.\r\n");
                    return;
                }
                ch.AdvanceLevel(true);
            }
            if (obj.ObjIndexData.IndexNumber == StaticObjects.OBJECT_NUMBER_55_POTION)
            {
                obj.RemoveFromWorld();
                if (ch._level != 54 || ch._experiencePoints < ExperienceTable.Table[ch._level].LevelExperience)
                {
                    ch.SendText("Nothing happens.\r\n");
                    return;
                }
                ch.AdvanceLevel(true);
            }

            // obj.Values[0] is not used for potions.
            for (int i = 1; i <= 4; i++)
            {
                String spellName = SpellNumberToTextMap.GetSpellNameFromNumber(obj.Values[i]);
                if (String.IsNullOrEmpty(spellName))
                {
                    Log.Error("Quaff: Spell number " + obj.Values[i] + " not found for object " + obj.ObjIndexNumber + ". Make sure it's in the SpellNumberToTextMap.");
                }
                Spell spell = StringLookup.SpellLookup(spellName);
                if (!spell)
                {
                    Log.Error("Quaff: Spell '" + spellName + "' not found for object " + obj.ObjIndexNumber + ". Make sure it's in the spells file.");
                }
                else
                {
                    spell.Invoke(ch, obj.Level, ch);
                }
            }

            obj.RemoveFromWorld();
            return;
        }

        /// <summary>
        /// Smoke - consume a magical herb.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Smoke(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object herb;
            Object pipe;
            string arg1 = String.Empty;
            string arg2 = String.Empty;

            if (String.IsNullOrEmpty(arg1))
            {
                SocketConnection.Act("You whip out a cigarette and puff away.", ch, null, null, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n lights up a cigarette and inhales deeply.", ch, null, null, SocketConnection.MessageTarget.room);
                return;
            }

            if (String.IsNullOrEmpty(arg2))
            {
                ch.SendText("What do you want to smoke through?\r\n");
                return;
            }

            if (!(herb = ch.GetObjCarrying(arg1)))
            {
                ch.SendText("You do not have $p&n.\r\n");
                return;
            }

            if (herb.ItemType != ObjTemplate.ObjectType.herb)
            {
                ch.SendText("Its unsafe to smoke anything but &n&+gherbs&n.\r\n");
                return;
            }

            if (!(pipe = ch.GetObjCarrying(arg2)))
            {
                ch.SendText("You do not have $P&n.\r\n");
                return;
            }

            if (pipe.ItemType != ObjTemplate.ObjectType.pipe)
            {
                ch.SendText("You need a &+Lpipe&n of some sort, $P just won't do.\r\n");
                return;
            }

            if ((Database.SystemData.WeatherData.Sky == Sysdata.SkyType.rain) && ((ch._inRoom.TerrainType != TerrainType.inside)
                    || (ch._inRoom.TerrainType == TerrainType.swamp) || (ch._inRoom.TerrainType == TerrainType.forest)))
            {
                ch.SendText("There is no way you can smoke in these wet conditions.\r\n");
                return;
            }

            if (ch._inRoom.IsWater())
            {
                ch.SendText("The &n&+cwa&+Ct&n&+ce&+Cr&m makes that an impossiblity.\r\n");
                return;
            }

            SocketConnection.Act("You pack $p&n into your $P.", ch, herb, pipe, SocketConnection.MessageTarget.character);
            SocketConnection.Act("You &n&+rlight&n $P&n and inhale deep $p&+W smoke&n.", ch, pipe, herb, SocketConnection.MessageTarget.character);
            SocketConnection.Act("You finish smoking $p&n.", ch, herb, null, SocketConnection.MessageTarget.character);
            SocketConnection.Act("$n&n smokes $p&n through $s $P&n.", ch, herb, pipe, SocketConnection.MessageTarget.room);

            // herb.Values[0] is not used for Herbs.
            for (int i = 1; i <= 4; i++)
            {
                String spellName = SpellNumberToTextMap.GetSpellNameFromNumber(herb.Values[i]);
                if (String.IsNullOrEmpty(spellName))
                {
                    Log.Error("Smoke: Spell number " + herb.Values[i] + " not found for object " + herb.ObjIndexNumber + ". Make sure it's in the SpellNumberToTextMap.");
                }
                Spell spell = StringLookup.SpellLookup(spellName);
                if (!spell)
                {
                    Log.Error("Smoke: Spell '" + spellName + "' not found for object " + herb.ObjIndexNumber + ". Make sure it's in the spells file.");
                }
                else
                {
                    spell.Invoke(ch, herb.Level, ch);
                }
            }

            // pipe.value[1] would be refering to de percent chance burnout of
            // pipe value set when creating item.
            int pipebreak = MUDMath.NumberRange(1, 100);

            if (pipebreak <= pipe.Values[1])
            {
                SocketConnection.Act("Your $p&n cracks and becomes useless from too much &n&+rheat&n.", ch, pipe, null, SocketConnection.MessageTarget.character);
                SocketConnection.Act("You toss $p&n violently into the distance.", ch, pipe, null, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n throws away $p, as cracks have made it useless.", ch, pipe, null, SocketConnection.MessageTarget.room);
                pipe.RemoveFromWorld();
                ;
            }

            if (!ch.IsNPC() || (ch.IsNPC() && ch.IsAffected(Affect.AFFECT_CHARM)))
            {
                herb.RemoveFromWorld();
            }
            return;
        }

        /// <summary>
        /// Use a scroll to invoke its magical spells.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Recite(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object scroll;
            Object obj = null;
            CharData victim;
            string arg1 = String.Empty;
            string arg2 = String.Empty;

            if (!(scroll = ch.GetObjCarrying(arg1)))
            {
                ch.SendText("You do not have that &+Wscroll&n.\r\n");
                return;
            }

            if (scroll.ItemType != ObjTemplate.ObjectType.scroll)
            {
                ch.SendText("You can recite only &+Wscrolls&n.\r\n");
                return;
            }

            if (String.IsNullOrEmpty(arg2))
            {
                victim = ch;
                if (ch._fighting != null)
                {
                    victim = ch._fighting;
                }
            }
            else
            {
                if (((victim = ch.GetCharRoom(arg2)) == null) && !(obj = ch.GetObjHere(arg2)))
                {
                    ch.SendText("You can't find it.\r\n");
                    return;
                }
            }

            if (!ch.CanSpeak())
            {
                ch.SendText("Your lips move but no sound comes out.\r\n");
                return;
            }

            if (ch.IsNPC() && !ch.IsFreewilled())
            {
                SocketConnection.Act("You try to recite $p&n, but you have no free will.", ch, scroll, null, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n tries to recite $p&n, but has no free will.", ch, scroll, null, SocketConnection.MessageTarget.room);
                return;
            }

            ch.WaitState(2 * Event.TICK_COMBAT);

            SocketConnection.Act("You recite $p&n.", ch, scroll, null, SocketConnection.MessageTarget.character);
            SocketConnection.Act("$n&n recites $p&n.", ch, scroll, null, SocketConnection.MessageTarget.room);

            if (ch.CheckSkill("scrolls"))
            {
                switch (MUDMath.NumberBits(3))
                {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        SocketConnection.Act("You can't understand $p&n at all.",
                             ch, scroll, null, SocketConnection.MessageTarget.character);
                        SocketConnection.Act("$n&n can't understand $p&n at all.",
                             ch, scroll, null, SocketConnection.MessageTarget.room);
                        return;
                    case 4:
                    case 5:
                    case 6:
                        ch.SendText("You must have said something incorrectly.\r\n");
                        SocketConnection.Act("$n&n must have said something incorrectly.", ch, null, null, SocketConnection.MessageTarget.room);
                        SocketConnection.Act("$p&n blazes brightly, then is gone.",
                             ch, scroll, null, SocketConnection.MessageTarget.character);
                        SocketConnection.Act("$p&n blazes brightly and disappears.",
                             ch, scroll, null, SocketConnection.MessageTarget.room);
                        scroll.RemoveFromWorld();
                        ;
                        return;
                    case 7:
                        SocketConnection.Act(
                            "You completely botch the recitation, and $p&n bursts into &+Rflames&n!!",
                            ch, scroll, null, SocketConnection.MessageTarget.character);
                        SocketConnection.Act("$p&n &+rglows&n and then bursts into &+Rflame&n!",
                             ch, scroll, null, SocketConnection.MessageTarget.room);
                        /*
                        * Command.damage( ) call after Object.extract_obj in case the damage would
                        * have extracted ch.  This is okay because we merely mark
                        * obj.deleted; it still retains all values until list_update.
                        * Sloppy?  Okay, create another integer variable.
                        */
                        scroll.RemoveFromWorld();
                        Combat.InflictDamage(ch, ch, scroll.Level, "scrolls", ObjTemplate.WearLocation.none, AttackType.DamageType.fire);
                        return;
                }
            }

            if (scroll.Level > ch._level)
            {
                SocketConnection.Act("$p&n is too high level for you.", ch, scroll, null, SocketConnection.MessageTarget.character);
            }
            else
            {
                /* scroll.Values[0] is not used for scrolls */
                for (int i = 1; i <= 4; i++)
                {
                    String spellName = SpellNumberToTextMap.GetSpellNameFromNumber(scroll.Values[i]);
                    if (String.IsNullOrEmpty(spellName))
                    {
                        Log.Error("Recite: Spell number " + obj.Values[i] + " not found for object " + scroll.ObjIndexNumber + ". Make sure it's in the SpellNumberToTextMap.");
                    }
                    Spell spell = StringLookup.SpellLookup(spellName);
                    if (!spell)
                    {
                        Log.Error("Recite: Spell '" + spellName + "' not found for object " + scroll.ObjIndexNumber + ". Make sure it's in the spells file.");
                    }
                    else
                    {
                        spell.Invoke(ch, scroll.Level, ch);
                    }
                }
            }

            if (!ch.IsNPC() || (ch.IsNPC() && ch.IsAffected(Affect.AFFECT_CHARM)))
            {
                scroll.RemoveFromWorld();
            }
            return;
        }

        /// <summary>
        /// Command to use a magical staff.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Brandish(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object staff;

            if (!(staff = Object.GetEquipmentOnCharacter(ch, ObjTemplate.WearLocation.hand_one)))
            {
                ch.SendText("You hold nothing in your hand.\r\n");
                return;
            }

            if (staff.ItemType != ObjTemplate.ObjectType.staff)
            {
                ch.SendText("You can brandish only with a &n&+ystaff&n.\r\n");
                return;
            }

            if (ch.IsNPC() && !ch.IsFreewilled())
            {
                SocketConnection.Act("You try to brandish $p&n, but you have no free will.", ch, staff, null, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n tries to brandish $p&n, but has no free will.", ch, staff, null, SocketConnection.MessageTarget.room);
                return;
            }

            String spellName = SpellNumberToTextMap.GetSpellNameFromNumber(staff.Values[3]);
            if (String.IsNullOrEmpty(spellName))
            {
                ch.SendText("You try to zap, but your wand fizzles.\r\n");
                Log.Error("Brandish: Spell number " + staff.Values[3] + " not found in SpellNumberToTextMap for object " + staff.ObjIndexNumber + ".");
                return;
            }

            Spell spell = StringLookup.SpellLookup(spellName);
            if (!spell)
            {
                ch.SendText("You try to zap, but your wand fizzles.\r\n");
                Log.Error("Brandish: Spell '" + spellName + "' not found for object " + staff.ObjIndexNumber + ". Check that it exists in the spells file.");
                return;
            }            
            
            ch.WaitState(2 * Event.TICK_COMBAT);

            if (staff.Values[2] > 0)
            {
                SocketConnection.Act("You brandish $p&n.", ch, staff, null, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n brandishes $p&n.", ch, staff, null, SocketConnection.MessageTarget.room);

                ch.PracticeSkill("staves");

                if (!ch.IsNPC() && (MUDMath.NumberPercent() > ((PC)ch).SkillAptitude["staves"]))
                {
                    switch (MUDMath.NumberBits(3))
                    {
                        default:
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            SocketConnection.Act("You are unable to invoke the power of $p&n.",
                                 ch, staff, null, SocketConnection.MessageTarget.character);
                            SocketConnection.Act("$n&n is unable to invoke the power of $p&n.",
                                 ch, staff, null, SocketConnection.MessageTarget.room);
                            return;
                        case 4:
                        case 5:
                        case 6:
                            SocketConnection.Act("You summon the power of $p&n, but it fizzles away.",
                                 ch, staff, null, SocketConnection.MessageTarget.character);
                            SocketConnection.Act("$n&n summons the power of $p&n, but it fizzles away.",
                                 ch, staff, null, SocketConnection.MessageTarget.room);
                            if (--staff.Values[2] <= 0)
                            {
                                SocketConnection.Act("$p&n blazes brightly and is gone.",
                                     ch, staff, null, SocketConnection.MessageTarget.character);
                                SocketConnection.Act("$p&n blazes brightly and is gone.",
                                     ch, staff, null, SocketConnection.MessageTarget.room);
                                staff.RemoveFromWorld();
                                ;
                            }
                            return;
                        case 7:
                            SocketConnection.Act("You can't control the power of $p&n, and it shatters!",
                                 ch, staff, null, SocketConnection.MessageTarget.character);
                            SocketConnection.Act("$p&n shatters into tiny pieces!",
                                 ch, staff, null, SocketConnection.MessageTarget.room);
                            staff.RemoveFromWorld();
                            Combat.InflictDamage(ch, ch, staff.Level, "staves", ObjTemplate.WearLocation.none, AttackType.DamageType.energy);
                            return;
                    }
                }
            }

            foreach (CharData roomChar in ch._inRoom.People)
            {
                if( ch == null ) return;

                switch (spell.ValidTargets)
                {
                    default:
                        Log.Error("Brandish: Bad TargetType for spell {0}.", spell.Name);
                        return;

                    case TargetType.none:
                        if (roomChar != ch)
                            continue;
                        break;

                    case TargetType.singleCharacterOffensive:
                        if (ch.IsNPC() ? roomChar.IsNPC() : !roomChar.IsNPC())
                            continue;
                        break;

                    case TargetType.singleCharacterDefensive:
                        if (ch.IsNPC() ? !roomChar.IsNPC() : roomChar.IsNPC())
                            continue;
                        break;

                    case TargetType.self:
                        if (roomChar != ch)
                            continue;
                        break;
                }

                Magic.ObjectCastSpell(ch, spell, staff.Level, roomChar, null);
            }

            if (!ch.IsNPC() || (ch.IsNPC() && ch.IsAffected(Affect.AFFECT_CHARM)))
            {
                if (--staff.Values[2] <= 0)
                {
                    SocketConnection.Act("$p&n blazes brightly and is gone.", ch, staff, null, SocketConnection.MessageTarget.character);
                    SocketConnection.Act("$p&n blazes brightly and is gone.", ch, staff, null, SocketConnection.MessageTarget.room);
                    staff.RemoveFromWorld();
                }
            }
            return;
        }

        /// <summary>
        /// Use an object. Forwards to the "zap" or "brandish" command for wands
        /// and staves, otherwise does nothing.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Use(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object item;

            if (str.Length == 0)
            {
                ch.SendText("Use what?\r\n");
                return;
            }

            if (!(item = ch.GetObjWear(str[0])))
            {
                ch.SendText("You can't find it!\r\n");
                return;
            }

            if (item.ItemType == ObjTemplate.ObjectType.wand)
            {
                Zap(ch, str);
                return;
            }
            if (item.ItemType == ObjTemplate.ObjectType.staff)
            {
                Brandish(ch, str);
                return;
            }
            ch.SendText("You can only use staves or wands.\r\n");
            return;
        }

        /// <summary>
        /// Zap a wand, using its spell power.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Zap(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object wand = null;
            Object obj = null;
            CharData victim;
            int level;

            if (str.Length == 0 && ch._fighting == null)
            {
                ch.SendText("Zap whom or what?\r\n");
                return;
            }

            if (!String.IsNullOrEmpty(str[0]) && !(wand = ch.GetObjWear(str[0])))
            {
                if (!(wand = Object.GetEquipmentOnCharacter(ch, ObjTemplate.WearLocation.hand_one)))
                {
                    ch.SendText("You hold nothing in your hand.\r\n");
                    return;
                }
            }
            else /* Wand was first argument.. arg is now second argument. */
            if (wand.ItemType != ObjTemplate.ObjectType.wand)
            {
                ch.SendText("You can zap only with a wand.\r\n");
                return;
            }

            level = wand.Level;
            if (String.IsNullOrEmpty(str[0]))
            {
                if (ch._fighting != null)
                {
                    victim = ch._fighting;
                }
                else
                {
                    ch.SendText("Zap whom or what?\r\n");
                    return;
                }
            }
            else
            {
                if (((victim = ch.GetCharRoom(str[0])) == null)
                        && (obj = ch.GetObjHere(str[0])) == null)
                {
                    ch.SendText("You can't find your _targetType.\r\n");
                    return;
                }
            }

            if (ch.IsNPC() && !ch.IsFreewilled())
            {
                SocketConnection.Act("You try to zap $p&n, but you have no free will.",
                     ch, wand, null, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n tries to zap $p&n, but has no free will.",
                     ch, wand, null, SocketConnection.MessageTarget.room);
                return;
            }

            String spellName = SpellNumberToTextMap.GetSpellNameFromNumber(wand.Values[3]);
            if (String.IsNullOrEmpty(spellName))
            {
                ch.SendText("You try to zap, but your wand fizzles.\r\n");
                Log.Error("Zap: Spell number " + wand.Values[3] + " not found in SpellNumberToTextMap for object " + wand.ObjIndexNumber + ".");
                return;
            }

            Spell spell = StringLookup.SpellLookup(spellName);
            if (!spell)
            {
                ch.SendText("You try to zap, but your wand fizzles.\r\n");
                Log.Error("Zap: Spell '" + spellName + "' not found for object " + wand.ObjIndexNumber + ". Check that it exists in the spells file.");
                return;
            }

            ch.PracticeSkill("wands");

            if (wand.Values[2] > 0)
            {
                if (victim != null)
                {
                    if (victim == ch)
                    {
                        SocketConnection.Act("You zap yourself with $p&n.", ch, wand, null, SocketConnection.MessageTarget.character);
                        SocketConnection.Act("$n&n zaps $mself with $p&n.", ch, wand, null, SocketConnection.MessageTarget.room);
                    }
                    else
                    {
                        SocketConnection.Act("You zap $N&n with $p&n.", ch, wand, victim, SocketConnection.MessageTarget.character);
                        SocketConnection.Act("$n&n zaps $N&n with $p&n.", ch, wand, victim, SocketConnection.MessageTarget.room);
                    }
                }
                else
                {
                    SocketConnection.Act("You zap $P&n with $p&n.", ch, wand, obj, SocketConnection.MessageTarget.character);
                    SocketConnection.Act("$n&n zaps $P&n with $p&n.", ch, wand, obj, SocketConnection.MessageTarget.room);
                }

                if (!ch.IsNPC() && (MUDMath.NumberPercent() > ((PC)ch).SkillAptitude["wands"]))
                {
                    switch (MUDMath.NumberBits(3))
                    {
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            SocketConnection.Act("You are unable to invoke the power of $p&n.",
                                 ch, wand, null, SocketConnection.MessageTarget.character);
                            SocketConnection.Act("$n&n is unable to invoke the power of $p&N.",
                                 ch, wand, null, SocketConnection.MessageTarget.room);
                            break;
                        case 4:
                        case 5:
                        case 6:
                            SocketConnection.Act("You summon the power of $p&n, but it fizzles away.",
                                 ch, wand, null, SocketConnection.MessageTarget.character);
                            SocketConnection.Act("$n&n summons the power of $p&n, but it fizzles away.",
                                 ch, wand, null, SocketConnection.MessageTarget.room);
                            break;
                        case 7:
                            SocketConnection.Act("You can't control the power of $p&n, and it &+Rexplodes&n!",
                                 ch, wand, null, SocketConnection.MessageTarget.character);
                            SocketConnection.Act("$p&n &n&+rexplodes&n into fragments!", ch, wand, null, SocketConnection.MessageTarget.room);
                            /*
                            * Command.damage( ) call after Object.extract_obj in case the damage would
                            * have extracted ch.  This is okay because we merely mark
                            * obj.deleted; it still retains all values until list_update.
                            * Sloppy?  Okay, create another integer variable.
                            * I hate sloppy...
                            */
                            wand.RemoveFromWorld();
                            Combat.InflictDamage(ch, ch, level, "wands", ObjTemplate.WearLocation.none, AttackType.DamageType.energy);
                            break;
                    }
                    return;
                } 
                Magic.ObjectCastSpell(ch, spell, level, victim, obj);
            }

            if (--(wand.Values[2]) <= 0)
            {
                if (!ch.IsNPC() && MUDMath.NumberPercent() > ((PC)ch).SkillAptitude["wands"])
                {
                    SocketConnection.Act("$p&n &n&+rexplodes&n into fragments.", ch, wand, null, SocketConnection.MessageTarget.character);
                    SocketConnection.Act("$p&n &+Rexplodes&n into fragments.", ch, wand, null, SocketConnection.MessageTarget.room);
                    wand.RemoveFromWorld();
                    Combat.InflictDamage(ch, ch, level, "wands", ObjTemplate.WearLocation.none, AttackType.DamageType.energy);
                }
                else
                {
                    SocketConnection.Act("$p&n blazes bright and is gone.",
                         ch, wand, null, SocketConnection.MessageTarget.character);
                    SocketConnection.Act("$p&n blazes bright and is gone.",
                         ch, wand, null, SocketConnection.MessageTarget.room);
                    wand.RemoveFromWorld();
                }
            }

            return;
        }

        public static void Steal(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object obj = null;
            CharData victim;
            bool sleeping = false;
            string arg1 = String.Empty;
            string arg2 = String.Empty;
            string arg = String.Empty;
            int percent;

            if (!ch.HasSkill("steal") && !ch.IsAffected(Affect.AFFECT_CHARM))
            {
                ch.SendText("Who are you trying to kid?  You couldn't steal shoes from a &n&+mbl&+Mo&n&+ma&+Mte&n&+md&n corpse.\r\n");
                return;
            }

            if (ch._riding != null)
            {
                ch.SendText("You can't do that while mounted.\r\n");
                return;
            }

            if (String.IsNullOrEmpty(arg1) || String.IsNullOrEmpty(arg2))
            {
                ch.SendText("Steal what from whom?\r\n");
                return;
            }

            if ((victim = ch.GetCharRoom(arg2)) == null)
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (victim == ch)
            {
                ch.SendText("That's pointless.\r\n");
                return;
            }

            if (Combat.IsSafe(ch, victim))
                return;

            if (!ch.IsImmortal())
            {
                ch.WaitState(Skill.SkillList["steal"].Delay);
            }

            // Justice stuff
            Crime.CheckThief(ch, victim);

            if (ch.IsNPC())
            {
                percent = ch._level * 2;
            }
            else
            {
                percent = ((PC)ch).SkillAptitude["steal"];
            }

            percent += ch.GetCurrLuck() / 20; /* Luck */

            percent -= victim._level; /* Character level vs victim's */

            if (ch.GetRace() == Race.RACE_HALFLING)
            {
                // Halflings get a racial bonus
                percent += 10;
            }

            if (victim.IsAffected(Affect.AFFECT_CURSE))
                percent += 15;

            if (ch.IsAffected(Affect.AFFECT_CURSE))
                percent -= 15;

            if (!victim.IsAwake())
                percent += 25; /* Sleeping characters are easier */

            if (ch.CheckSneak())
                percent += 10; /* Quiet characters steal better */

            if (!CharData.CanSee(ch, victim))
                percent += 10; /* Unseen characters steal better */

            if (!MUDString.IsPrefixOf(arg1, "coins"))
            {
                percent = (int)(percent * 1.2); /* Cash is fairly easy to steal */
            }
            else
            {
                int number = MUDString.NumberArgument(arg1, ref arg);
                int count = 0;
                foreach (Object iobj in victim._carrying)
                {
                    if (CharData.CanSeeObj(ch, iobj) && MUDString.NameContainedIn(arg, iobj.Name))
                    {
                        if (++count == number)
                        {
                            obj = iobj;
                            break;
                        }
                    }
                }

                if (!obj)
                {
                    ch.SendText("You can't find it.\r\n");
                    return;
                }

                if (ch._level < victim._level)
                {
                    // stealing from higher level is possible, but harder
                    percent -= 5 * (victim._level - ch._level);
                }
                else
                {
                    // slight bonus for mobs lower level
                    percent += (ch._level - victim._level);
                }
                if (obj.WearLocation == ObjTemplate.WearLocation.none)
                    /* Items worn are harder */
                    percent = (int)(percent * .8);
                else
                    percent = (int)(percent * .4);
            }

            ch.PracticeSkill("steal");

            if (percent > 85)
                percent = 85;

            if (percent < 2)
                percent = 2;
            if (percent < MUDMath.NumberPercent())
            {
                /*
                * Failure.
                */
                //strip sneak
                ch.RemoveAffect(Affect.AFFECT_SNEAK);
                // chance of removing invis
                if (ch.IsAffected(Affect.AFFECT_INVISIBLE) && MUDMath.NumberPercent() > percent)
                {
                    ch.SendText("You really bungled that attempt.\r\n");
                    ch.RemoveAffect(Affect.AFFECT_INVISIBLE);
                }
                else
                {
                    ch.SendText("Oops.\r\n");
                }
                SocketConnection.Act("$n&n tried to steal from $N&n.", ch, null, victim, SocketConnection.MessageTarget.everyone_but_victim);
                if (victim.IsAwake())
                {
                    SocketConnection.Act("$n&n tried to steal from you!", ch, null, victim, SocketConnection.MessageTarget.victim);
                }
                else
                {
                    sleeping = true;
                }
                // Thief flag for justice.
                // Added so blind mobs dont hit who ever failed steal from em.
                if (victim.IsNPC())
                {
                    if (!sleeping && !victim.IsBlind())
                    {
                        CommandType.Interpret(victim, "kill " + ch._name);
                    }
                }
                else
                {
                    if (!victim.IsBlind() && !sleeping && victim.IsAffected(Affect.AFFECT_BERZERK))
                    {
                        victim.SendText("In your &+Rblood rage&n, you lash out in anger!\r\n");
                        CommandType.Interpret(victim, "kill " + ch._name);
                    }
                }
                /*
                if ( !Macros.IS_SET( ch.actflags, PC.PLAYER_THIEF ) )
                {
                Macros.SET_BIT( ref ch.actflags, PC.PLAYER_THIEF );
                buf = String.Format(  "{0} became a THIEF by stealing from {1}",
                ch._name, victim._name );
                Immtalk.Immtalk( ch, Immtalk.IMMTALK_CRIME, ch.GetTrust(), buf );
                CharData.SavePlayer( ch );
                }
                */
                //    }
                if (sleeping)
                {
                    if (MUDMath.NumberPercent() < victim.GetCurrLuck())
                    {
                        CommandType.Interpret(victim, "wake");
                    }
                }
                return;
            } //end failure

            if (!MUDString.IsPrefixOf(arg1, "coins"))
            {
                int amount = victim.GetGold() * MUDMath.NumberRange(1, 20) / 100;
                int amount2 = victim.GetSilver() * MUDMath.NumberRange(1, 20) / 100;
                int amount3 = victim.GetCopper() * MUDMath.NumberRange(1, 20) / 100;
                int amount4 = victim.GetPlatinum() * MUDMath.NumberRange(1, 20) / 100;

                if ((amount + amount2 + amount3 + amount4) <= 0)
                {
                    ch.SendText("You couldn't get any &n&+wcoins&n.\r\n");
                    return;
                }

                ch.ReceiveGold(amount);
                ch.ReceiveSilver(amount2);
                ch.ReceiveCopper(amount3);
                ch.ReceivePlatinum(amount4);

                victim.SpendGold(amount);
                victim.SpendSilver(amount2);
                victim.SpendCopper(amount3);
                victim.SpendPlatinum(amount4);

                string text = String.Format("Success!  You got {0} &+Wplatinum&n, {1} &+Ygold&n, {2} silver, and {3} &+ycopper&n.\r\n",
                                            amount2, amount3, amount, amount4);
                ch.SendText(text);
                return;
            }

            if (!ch.CanDropObject(obj) || obj.HasFlag(ObjTemplate.ITEM_INVENTORY))
            {
                ch.SendText("You can't pry it away.\r\n");
                return;
            }

            if (ch._carryNumber + 1 > Limits.MAX_CARRY)
            {
                ch.SendText("You have your hands full.\r\n");
                return;
            }

            if (ch._carryWeight + obj.GetWeight() > ch.MaxCarryWeight())
            {
                ch.SendText("You can't carry that much weight.\r\n");
                return;
            }

            if (obj.WearLocation != ObjTemplate.WearLocation.none)
            {
                ch.SendText("Very daring, and you got it!\r\n");
                victim.UnequipObject(obj);
            }

            obj.RemoveFromChar();
            obj.ObjToChar(ch);
            ch.SendText("Nice work.\r\n");
            if (obj.Trap != null && obj.Trap.CheckTrigger( Trap.TriggerType.steal))
            {
                ch.SetOffTrap(obj);
                if (ch._position == Position.dead)
                {
                    return;
                }
            }
            return;
        }

        public static void Buy(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string arg2 = String.Empty;
            string arg3 = String.Empty;
            string text;
            bool fPerm = false;

            if (str.Length == 0)
            {
                ch.SendText("Buy what?\r\n");
                return;
            }

            if (ch._inRoom.HasFlag(RoomTemplate.ROOM_PET_SHOP))
            {
                if (ch.IsNPC())
                    return;

                Room pRoomIndexNext = Room.GetRoom(ch._inRoom.IndexNumber + 1);
                if (pRoomIndexNext == null)
                {
                    Log.Error("Buy: bad pet shop at index number {0}.", ch._inRoom.IndexNumber);
                    ch.SendText("Sorry, you can't buy that here.\r\n");
                    return;
                }

                Room inRoom = ch._inRoom;
                ch._inRoom = pRoomIndexNext;
                CharData pet = ch.GetCharRoom(str[0]);
                ch._inRoom = inRoom;

                if (pet && ch.MaxPets())
                {
                    ch.SendText("Sorry, you can't keep track of that many pets.\r\n");
                    return;
                }

                if (pet == null || !pet.HasActBit(MobTemplate.ACT_PET))
                {
                    ch.SendText("Sorry, you can't buy that here.\r\n");
                    return;
                }
                //  Altered Pricing to match the ones that were given in the list
                //  command below... original was set to 500 * pet.level * pet.level
                //  Xangis tweaked it to 100 * pet level squared

                if (ch.GetCash() < ((100 * pet._level) * pet._level))
                {
                    ch.SendText("You can't afford it.\r\n");
                    return;
                }

                ch.SpendCash(((100 * pet._level) * pet._level));
                pet = Database.CreateMobile(pet._mobIndexData);
                pet.SetActBit(MobTemplate.ACT_PET);
                pet.SetActBit(MobTemplate.ACT_NOEXP);
                pet.SetAffBit(Affect.AFFECT_CHARM);

                if (!String.IsNullOrEmpty(str[0]))
                {
                    text = String.Format("{0} {1}", pet._name, str[0]);
                    pet._name = text;
                }

                text = String.Format("{0}&+LA neck tag says '&+RI belong to {1}&+L'.&n\r\n",
                          pet._description, ch._name);
                pet._description = text;
                pet.AddToRoom(ch._inRoom);
                CharData.AddFollower(pet, ch);
                ch.SendText("Enjoy your pet.\r\n");
                SocketConnection.Act("$n&n just purchased $N&n.", ch, null, pet, SocketConnection.MessageTarget.room);
                return;
            }
            ObjTemplate pObj;
            Object obj = null;
            CharData keeper;
            int itemCount = 1; /* buy only one by default */

            if (MUDString.IsNumber(str[0]))
            {
                Int32.TryParse(str[0], out itemCount);
                str[0] = arg2;
                arg2 = arg3;
            }

            if (!(keeper = ch.FindShopkeeper(arg2)))
            {
                return;
            }

            if (!ch.IsNPC())
            {
                // Won't sell to bottom 25% of faction range.
                if (((PC)ch).GetFaction(keeper) < (Limits.MIN_FACTION / 2))
                {
                    SocketConnection.Act("$n&+W tells you 'I won't do business with scum like you.'&n", keeper, null, ch, SocketConnection.MessageTarget.victim);
                    ch._replyTo = keeper;
                    return;
                }
            }

            if (keeper._mobIndexData.ShopData.ItemsForSale.Count != 0)
            {
                foreach (int item in keeper._mobIndexData.ShopData.ItemsForSale)
                {
                    pObj = Database.GetObjTemplate(item);
                    if (!pObj)
                    {
                        continue;
                    }
                    if (MUDString.NameContainedIn(str[0], pObj.Name))
                    {
                        obj = Database.CreateObject(pObj, pObj.Level);
                        fPerm = true;
                        break;
                    }
                }
            }

            if (!obj)
            {
                obj = keeper.GetObjCarrying(str[0]);
            }

            if (!obj || !CharData.CanSeeObj(ch, obj))
            {
                SocketConnection.Act("$n&+W tells you 'I don't sell that -- try 'list'.'&n", keeper, null, ch, SocketConnection.MessageTarget.victim);
                ch._replyTo = keeper;
                return;
            }

            int cost = Object.GetCost(ch, keeper, obj, true);

            if (cost < obj.Cost)
            {
                Log.Error("Shopkeeper with index number {0} sells for less than 100 percent of value.\r\n",
                          keeper._mobIndexData.IndexNumber);
                cost = obj.Cost;
            }

            if (itemCount < 1)
            {
                ch.SendText("Buy how many?  Quantity must be greater than zero.\r\n");
                return;
            }

            if (ch.GetCash() < (cost * itemCount))
            {
                if (itemCount == 1)
                {
                    SocketConnection.Act("$n&+W tells you 'You can't afford to buy $p&+W.'&n", keeper, obj, ch, SocketConnection.MessageTarget.victim);
                    ch._replyTo = keeper;
                    return;
                }
                else
                {
                    string buf4;

                    if ((ch.GetCash() / cost) > 0)
                    {
                        buf4 = String.Format("$n&+W tells you, 'You can only afford {0} of those!'&n",
                                             (ch.GetCash() / cost));
                    }
                    else
                    {
                        buf4 = String.Format("$n&+W tells you, 'You can't even afford one!'&n");
                    }

                    SocketConnection.Act(buf4, keeper, obj, ch, SocketConnection.MessageTarget.victim);
                    ch._replyTo = keeper;
                    return;
                }
            }

            if (ch._carryNumber + itemCount > Limits.MAX_CARRY)
            {
                ch.SendText("You can't carry that many items.\r\n");
                return;
            }

            if (ch._carryWeight + (itemCount * obj.GetWeight()) > ch.MaxCarryWeight())
            {
                ch.SendText("You can't carry that much weight.\r\n");
                return;
            }

            if ((itemCount > 1)
                && !obj.HasFlag(ObjTemplate.ITEM_INVENTORY))
            {
                SocketConnection.Act("$n&+W tells you, 'Sorry, $p&+W is something I have only one of.'&n",
                                     keeper, obj, ch, SocketConnection.MessageTarget.character);
                ch._replyTo = keeper;
                return;
            }

            if (cost < 1)
                cost = 1;

            if (itemCount == 1)
            {
                text = String.Format("You buy $p&n for {0}.", StringConversion.CoinString(cost * itemCount));
                SocketConnection.Act(text, ch, obj, null, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n buys $p&n.", ch, obj, null, SocketConnection.MessageTarget.room);
            }
            else
            {
                text = String.Format("$n&n buys {0} * $p&n.", itemCount);
                SocketConnection.Act(text, ch, obj, null, SocketConnection.MessageTarget.room);
                text = String.Format("You buy {0} * $p&n.", itemCount);
                SocketConnection.Act(text, ch, obj, null, SocketConnection.MessageTarget.character);
            }

            ch.SpendCash(cost * itemCount);

            if (fPerm)
            {
                obj.ObjToChar(ch);
            }
            else if (obj.HasFlag(ObjTemplate.ITEM_INVENTORY))
            {
                for (; itemCount > 0; itemCount--)
                {
                    obj = Database.CreateObject(obj.ObjIndexData, obj.Level);
                    obj.ObjToChar(ch);
                }
            }
            else
            {
                obj.RemoveFromChar();
                obj.ObjToChar(ch);
            }
            obj.Timer = -1;
            // Selling an object decreases its scarcity.
            --obj.ObjIndexData.Scarcity;

            return;
        }

        public static void ListCommand(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string text;
            string buf1 = String.Empty;

            if (ch._inRoom.HasFlag(RoomTemplate.ROOM_PET_SHOP))
            {
                if (!ch._inRoom)
                {
                    ch.SendText("Nothing to list here.\r\n");
                    return;
                }

                Room pRoomIndexNext = Room.GetRoom(ch._inRoom.IndexNumber + 1);
                if (!pRoomIndexNext)
                {
                    Log.Error("ListCommand: bad pet shop at index number {0}.", ch._inRoom.IndexNumber);
                    ch.SendText("You can't do that here.\r\n");
                    return;
                }

                bool found = false;
                foreach (CharData pet in pRoomIndexNext.People)
                {
                    if (pet.HasActBit(MobTemplate.ACT_PET))
                    {
                        // I set this here so as to list a nicer and more comprehensive
                        // pet shop  stock/price list.  I *think* I got it right.

                        int cost = ((100 * pet._level) * pet._level);
                        if (cost <= 0)
                        {
                            cost = 1;
                        }
                        if (!found)
                        {
                            found = true;
                            buf1 += "&+LPets for sale&n&+r:&n\r\n";
                        }

                        text = String.Format("{0}&n for {1}.\r\n", pet._shortDescription, StringConversion.CoinString(cost));
                        buf1 += text;
                    }
                }
                if (!found)
                {
                    ch.SendText("Sorry, we're out of pets right now.\r\n");
                }
                ch.SendText(buf1);
                return;
            }
            else
            {
                ObjTemplate pObj;
                CharData keeper;
                string arg2 = String.Empty;
                int cost;

                if (!(keeper = ch.FindShopkeeper(arg2)))
                {
                    return;
                }

                if (ch.IsImmortal())
                {
                    buf1 = String.Format("Shop sell profit: {0} percent    Shop buy profit: {1} percent\r\n",
                              keeper._mobIndexData.ShopData.PercentSell,
                              keeper._mobIndexData.ShopData.PercentBuy);
                }

                bool found = false;
                foreach (Object obj in keeper._carrying)
                {
                    if (obj.WearLocation != ObjTemplate.WearLocation.none)
                        continue;

                    cost = Object.GetCost(ch, keeper, obj, true);
                    if (cost <= 0)
                        cost = 1;

                    if (CharData.CanSeeObj(ch, obj) && (str.Length == 0 || str[0] == "all"
                                   || MUDString.NameContainedIn(str[0], obj.Name)))
                    {
                        if (!found)
                        {
                            found = true;
                            buf1 += "&+LYou can buy&n&+r:&n\r\n";
                        }

                        text = String.Format("{0}&n for {1}.\r\n",
                                  obj.ShortDescription, StringConversion.CoinString(cost));
                        buf1 += text;
                    }
                }

                if (keeper._mobIndexData.ShopData.ItemsForSale.Count != 0)
                {
                    bool fListed = false;
                    int count = 0;
                    foreach (int item in keeper._mobIndexData.ShopData.ItemsForSale)
                    {
                        pObj = Database.GetObjTemplate(item);
                        if (!pObj)
                        {
                            continue;
                        }
                        ++count;
                        foreach (Object obj2 in keeper._carrying)
                        {
                            if (obj2.ObjIndexData == pObj && obj2.WearLocation == ObjTemplate.WearLocation.none)
                            {
                                fListed = true;
                                break;
                            }
                        }
                        if (fListed)
                            continue;
                        cost = pObj.Cost;
                        text = String.Format("{0}&n for {1}.\r\n", pObj.ShortDescription, StringConversion.CoinString(cost));
                        buf1 += text;
                    }
                }

                if (!found)
                {
                    if (str.Length == 0)
                        ch.SendText("You can't buy anything here.\r\n");
                    else
                        ch.SendText("You can't buy that here.\r\n");
                    return;
                }

                ch.SendText(buf1);
                return;
            }
        }

        /// <summary>
        /// Sell an item.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Sell(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object obj;
            CharData keeper;
            string arg2 = String.Empty;
            int cost;

            if (str.Length == 0)
            {
                ch.SendText("Sell what?\r\n");
                return;
            }

            if (!(keeper = ch.FindShopkeeper(arg2)))
            {
                return;
            }

            if (!ch.IsNPC())
            {
                // Won't buy from bottom 25% of faction range.
                if (((PC)ch).GetFaction(keeper) < (Limits.MIN_FACTION / 2))
                {
                    SocketConnection.Act("$n&+W tells you 'I won't do business with scum like you.'&n", keeper, null, ch, SocketConnection.MessageTarget.victim);
                    ch._replyTo = keeper;
                    return;
                }
            }

            if (!(obj = ch.GetObjCarrying(str[0])))
            {
                SocketConnection.Act("$n&+W tells you 'You don't have that item.'&n",
                     keeper, null, ch, SocketConnection.MessageTarget.victim);
                ch._replyTo = keeper;
                return;
            }

            if (!ch.CanDropObject(obj))
            {
                ch.SendText("You couldn't possibly part with that.\r\n");
                return;
            }

            if (!CharData.CanSeeObj(keeper, obj))
            {
                SocketConnection.Act("$n&+W tells you 'I can't see that item.'&n",
                     keeper, null, ch, SocketConnection.MessageTarget.victim);
                ch._replyTo = keeper;
                return;
            }

            if ((cost = Object.GetCost(ch, keeper, obj, false)) <= 0 || obj.HasFlag(ObjTemplate.ITEM_NOSELL))
            {
                SocketConnection.Act("$n&n looks uninterested in $p&n.", keeper, obj, ch, SocketConnection.MessageTarget.victim);
                return;
            }

            if (cost > obj.Cost)
            {
                Log.Error("Shopkeeper with index number {0} buys for more than 100 percent of value.\r\n",
                     keeper._mobIndexData.IndexNumber);
                cost = obj.Cost;
            }

            if (cost < 1)
                cost = 1;

            if (obj.HasFlag(ObjTemplate.ITEM_POISONED))
            {
                SocketConnection.Act("$n&+W tells you 'I won't buy that!  It's poisoned!'&n",
                     keeper, null, ch, SocketConnection.MessageTarget.victim);
                ch._replyTo = keeper;
                return;
            }

            string buf = String.Format("You sell $p&n for {0}.", StringConversion.CoinString(cost));
            SocketConnection.Act(buf, ch, obj, null, SocketConnection.MessageTarget.character);
            SocketConnection.Act("$n&n sells $p&n.", ch, obj, null, SocketConnection.MessageTarget.room);
            ch.ReceiveCash(cost);

            if (obj.ItemType == ObjTemplate.ObjectType.trash)
            {
                obj.RemoveFromWorld();
            }
            else
            {
                obj.RemoveFromChar();
                obj.ObjToChar(keeper);
                // Selling an object decreases its scarcity.
                --obj.ObjIndexData.Scarcity;
            }

            return;
        }

        /// <summary>
        /// Value: Find out how much a shopkeeper will pay for an item.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Value(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object obj;
            CharData keeper;
            int cost;

            if (str.Length == 0)
            {
                ch.SendText("Value what?\r\n");
                return;
            }

            if (!(keeper = ch.FindShopkeeper("")))
                return;

            if (!(obj = ch.GetObjCarrying(str[0])))
            {
                SocketConnection.Act("$n&n tells you 'You don't have that item'.",
                     keeper, null, ch, SocketConnection.MessageTarget.victim);
                ch._replyTo = keeper;
                return;
            }

            if (!ch.CanDropObject(obj))
            {
                ch.SendText("That's not something you can sell.\r\n");
                return;
            }

            if (!CharData.CanSeeObj(keeper, obj))
            {
                SocketConnection.Act("$n&+W tells you 'You are offering me an imaginary object!?!?'&n",
                     keeper, null, ch, SocketConnection.MessageTarget.victim);
                ch._replyTo = keeper;
                return;
            }

            if ((cost = Object.GetCost(ch, keeper, obj, false)) <= 0)
            {
                SocketConnection.Act("$n&n looks uninterested in $p&n.", keeper, obj, ch, SocketConnection.MessageTarget.victim);
                return;
            }

            if (obj.HasFlag(ObjTemplate.ITEM_POISONED))
            {
                SocketConnection.Act("$n&+W tells you 'I won't buy that!  It's poisoned!'&n",
                     keeper, null, ch, SocketConnection.MessageTarget.victim);
                ch._replyTo = keeper;
                return;
            }

            string buf = String.Format("$n&+W tells you 'I'll give you {0} &n&+ycopper&+W coins for $p&n.'", cost);
            SocketConnection.Act(buf, keeper, obj, ch, SocketConnection.MessageTarget.victim);
            ch._replyTo = keeper;

            return;
        }

        /// <summary>
        /// Apply poison to a weapon.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void PoisonWeapon(CharData ch, string[] str)
        {
            if (ch == null)
            {
                return;
            }

            Object obj;
            Object pobj = null;
            Affect af = new Affect();

            /* Don't allow mobs or unskilled pcs to do this */
            if (ch.IsNPC() || (!ch.IsNPC() && !ch.HasSkill("poison weapon")))
            {
                ch.SendText("What do you think you are, a thief?\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("What are you trying to poison?\r\n");
                return;
            }
            if (ch._fighting != null)
            {
                ch.SendText("While you're fighting?  Nice try.\r\n");
                return;
            }
            if (!(obj = ch.GetObjCarrying(str[0])))
            {
                ch.SendText("You do not have that weapon.\r\n");
                return;
            }
            if (obj.ItemType != ObjTemplate.ObjectType.weapon)
            {
                ch.SendText("That item is not a weapon.\r\n");
                return;
            }
            if (obj.HasFlag(ObjTemplate.ITEM_POISONED))
            {
                ch.SendText("That weapon is already poisoned.\r\n");
                return;
            }
            if (obj.Values[0] != 2)
            {
                ch.SendText("You don't have enough poison to cover that!\r\n");
                return;
            }

            /* Now we have a valid weapon...check to see if we have the poison. */
            foreach (Object iobj in ch._carrying)
            {
                // here is where we should check to see if they have poison
                if (iobj.ItemType == ObjTemplate.ObjectType.drink_container
                        && iobj.Values[2] == 27)
                {
                    pobj = iobj;
                    break;
                }
            }
            if (!pobj)
            {
                ch.SendText("You do not have any poison.\r\n");
                return;
            }

            if (pobj.Values[1] <= 0 && pobj.Values[1] != -1)
            {
                SocketConnection.Act("Sorry, $p&n seems to be empty.", ch, pobj, null, SocketConnection.MessageTarget.character);
                return;
            }

            ch.WaitState(Skill.SkillList["poison weapon"].Delay);

            /* Check the skill percentage */
            if (!ch.CheckSkill("poison weapon"))
            {
                ch.SendText("You failed and spill some on yourself.  &+ROuch!&n\r\n");
                Combat.InflictDamage(ch, ch, ch._level, "poison weapon", ObjTemplate.WearLocation.none, AttackType.DamageType.poison);
                SocketConnection.Act("$n spills the &+Gpoison&n all over!", ch, null, null, SocketConnection.MessageTarget.room);
                pobj.Values[1] -= 2;
                return;
            }

            /* Can't have people smearing gunk on artifacts */
            if (obj.InsultArtifact(ch))
            {
                pobj.Values[1]--;
                return;
            }

            SocketConnection.Act("You apply the &+Gpoison&n to $p&n, which glistens wickedly!",
                 ch, obj, null, SocketConnection.MessageTarget.character);
            SocketConnection.Act("$n&n pours the &+Gli&n&+gq&+Gu&n&+gid&n over $p&n, which glistens wickedly!",
                 ch, obj, null, SocketConnection.MessageTarget.room);

            af.Value = "poison weapon";
            af.Type = Affect.AffectType.skill;
            af.Duration = ch._level + MUDMath.Dice(4, ch._level / 2);
            af.AddModifier(Affect.Apply.none, pobj.Values[3]);
            af.Level = ch._level;
            af.SetBitvector(Affect.AFFECT_POISON);
            obj.AddAffect(af);
            // Consume one unit of the poison source.
            pobj.Values[1]--;
            return;
        }

        public static void Fill(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object fountain = null;

            if (ch.IsBlind())
            {
                ch.SendText("You can't see what you're trying to fill.\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Fill what?\r\n");
                return;
            }

            Object obj = ch.GetObjCarrying(str[0]);
            if (!obj)
            {
                ch.SendText("You do not have that item.\r\n");
                return;
            }

            bool found = false;
            foreach (Object fount in ch._inRoom.Contents)
            {
                if (fount.FlyLevel != ch._flyLevel)
                    continue;
                if (fount.ItemType == ObjTemplate.ObjectType.drink_container)
                {
                    fountain = fount;
                    found = true;
                    break;
                }
            }

            if (!found)
            {
                ch.SendText("There is nothing to fill from here!\r\n");
                return;
            }

            if (obj.ItemType != ObjTemplate.ObjectType.drink_container)
            {
                ch.SendText("You can't fill that.\r\n");
                return;
            }

            if (obj.Values[1] != 0 && obj.Values[2] != fountain.Values[2])
            {
                ch.SendText("There is already another liquid in it.\r\n");
                return;
            }

            if (obj.Values[1] >= obj.Values[0])
            {
                ch.SendText("Your container is full.\r\n");
                return;
            }

            SocketConnection.Act("You fill $p&n.", ch, obj, null, SocketConnection.MessageTarget.character);
            obj.Values[2] = fountain.Values[2];
            obj.Values[1] = obj.Values[0];
            return;
        }

        /// <summary>
        /// Ingest a liquid.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Drink(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object obj = null;

            if (ch.IsBlind())
            {
                return;
            }

            if (ch._fighting || ch._position == Position.fighting)
            {
                ch.SendText("You can't drink while you're fighting!\r\n");
                return;
            }

            if (str.Length == 0 && ch._inRoom != null)
            {
                foreach (Object iobj in ch._inRoom.Contents)
                {
                    if (iobj.ItemType == ObjTemplate.ObjectType.drink_container)
                    {
                        obj = iobj;
                        break;
                    }
                }

                if (!obj)
                {
                    ch.SendText("Drink what?\r\n");
                    return;
                }
            }
            else
            {
                if (!(obj = ch.GetObjHere(str[0])))
                {
                    ch.SendText("You can't find it.\r\n");
                    return;
                }
            }

            // Allow bards to get twice as drunk as other classes - Xangis
            if (!ch.IsNPC() && !ch.IsImmortal()
                    && ((PC)ch).Drunk > 15 && ch.IsClass(CharClass.Names.bard)
                    && MUDMath.NumberPercent() < ch.GetCurrAgi() - ((PC)ch).Drunk)
            {
                ch.SendText("You fail to reach your mouth.  *Hic*\r\n");
                return;
            }
            if (!ch.IsNPC() && !ch.IsImmortal()
                && ((PC)ch).Drunk > 25 && ch.IsClass(CharClass.Names.bard)
                && MUDMath.NumberPercent() < ch.GetCurrAgi() - ((PC)ch).Drunk)
            {
                ch.SendText("You fail to reach your mouth.  *Hic*\r\n");
                return;

            }

            switch (obj.ItemType)
            {
                default:
                    ch.SendText("You can't drink from that.\r\n");
                    break;

                case ObjTemplate.ObjectType.drink_container:
                    // -1 Means a container never goes empty.
                    if (obj.Values[1] <= 0 && obj.Values[1] != -1)
                    {
                        ch.SendText("It is already &+Lempty&n.\r\n");
                        return;
                    }

                    /* No drinking if you're full */
                    if ((!ch.IsImmortal()) && (
                                (!ch.IsNPC() && ((PC)ch).Thirst > 40) ||
                                (!ch.IsNPC() && ((PC)ch).Hunger > 50)))
                    {
                        ch.SendText("You couldn't possibly drink any more.\r\n");
                        return;
                    }

                    int liquid;
                    if ((liquid = obj.Values[2]) >= Liquid.Table.Length)
                    {
                        Log.Error("Drink: bad liquid number {0}.", liquid);
                        liquid = obj.Values[2] = 0;
                    }

                    SocketConnection.Act("You drink $T from $p&n.",
                         ch, obj, Liquid.Table[liquid].Name, SocketConnection.MessageTarget.character);
                    SocketConnection.Act("$n&n drinks $T from $p&n.",
                         ch, obj, Liquid.Table[liquid].Name, SocketConnection.MessageTarget.room);

                    int amount = MUDMath.NumberRange(3, 10);
                    if (obj.Values[0] != -1)
                    {
                        amount = Math.Min(amount, obj.Values[1]);
                    }

                    ch.AdjustDrunk(amount * Liquid.Table[liquid].DrunkValue);

                    if (!ch.IsUndead())
                    {
                        ch.AdjustHunger(amount * Liquid.Table[liquid].HungerValue);
                        if (ch.IsAffected(Affect.AFFECT_THIRST))
                        {
                            ch.AdjustThirst((amount * Liquid.Table[liquid].ThirstValue) / 12);
                            ch.SendText("That doesn't taste as &+bwet&n as it used to.\r\n");
                        }
                        else
                        {
                            ch.AdjustThirst(amount * Liquid.Table[liquid].ThirstValue);
                        }
                    }
                    else
                    {
                        /* If blood */
                        if (Liquid.Table[liquid].Name == "blood")
                        {
                            ch.AdjustHunger(amount * 2);
                            ch.AdjustThirst(amount);
                        }
                    }

                    if (!ch.IsNPC() && ((PC)ch).Drunk > 10)
                    {
                        ch.SendText("You feel &n&+gdrunk&n.\r\n");
                    }
                    if (!ch.IsNPC() && ((PC)ch).Hunger > 20)
                    {
                        ch.SendText("You are &n&+yfull&n.\r\n");
                    }
                    if (!ch.IsNPC() && ((PC)ch).Thirst > 20)
                    {
                        ch.SendText("You do not feel &n&+cth&+Ci&n&+cr&+Cst&n&+cy&n.\r\n");
                    }

                    if (obj.Values[3] != 0 && !CharData.CheckImmune(ch, Race.DamageType.poison))
                    {
                        /* The shit was poisoned ! */
                        Affect af = new Affect();

                        ch.SendText("You choke and gag.\r\n");
                        SocketConnection.Act("$n chokes and gags.", ch, null, null, SocketConnection.MessageTarget.room);
                        af.Type = Affect.AffectType.spell;
                        af.Value = "poison";
                        af.Duration = 3 * amount;
                        af.AddModifier(Affect.Apply.strength, -(obj.Level / 7 + 1));
                        af.SetBitvector(Affect.AFFECT_POISON);
                        ch.CombineAffect(af);
                    }

                    /* HOLY_WATER and UNHOLY_WATER effects */
                    if ((ch.IsGood() && obj.Values[2] == 27) || 
                            (ch.IsEvil() && obj.Values[2] == 28))
                    {
                        int heal = MUDMath.Dice(1, 8);
                        if (ch._hitpoints < ch.GetMaxHit())
                        {
                            ch._hitpoints = Math.Min(ch._hitpoints + heal, ch.GetMaxHit());
                            ch.UpdatePosition();
                            ch.SendText("You feel a little better!\r\n");
                        }
                    }
                    if ((ch.IsEvil() && obj.Values[2] == 27) ||
                            (ch.IsGood() && obj.Values[2] == 28))
                    {
                        int harm = MUDMath.Dice(1, 10);
                        ch._hitpoints = Math.Max(ch._hitpoints - harm, -10);
                        ch.SendText("You choke and feel as if you'd swallowed boiling oil!\r\n");
                        ch.UpdatePosition();
                    }
                    /* End (UN)HOLY_WATER effects */

                    // -1 Means a container never goes empty.
                    if (obj.Values[1] != -1)
                    {
                        obj.Values[1] -= amount;
                        if (obj.Values[1] <= 0)
                        {
                            ch.SendText("The container is now &+Lempty&n.\r\n");
                            obj.Values[1] = 0;
                        }
                    }
                    break;
            }

            return;
        }

        public static void Eat(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object obj;

            if (ch.IsBlind())
                return;

            if (ch._fighting || ch._position == Position.fighting)
            {
                ch.SendText("You can't eat while you're fighting!\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Eat what?\r\n");
                return;
            }

            if (!(obj = ch.GetObjCarrying(str[0])))
            {
                ch.SendText("You do not have that item.\r\n");
                return;
            }

            if (!ch.IsImmortal())
            {
                if (obj.ItemType != ObjTemplate.ObjectType.food && obj.ItemType != ObjTemplate.ObjectType.pill)
                {
                    ch.SendText("That's not edible.\r\n");
                    return;
                }

                if (!ch.IsNPC() && ((PC)ch).Hunger > 40)
                {
                    ch.SendText("You are too full to eat more.\r\n");
                    return;
                }
            }

            SocketConnection.Act("You consume $p&n.", ch, obj, null, SocketConnection.MessageTarget.character);
            SocketConnection.Act("$n&n inhales $p&n.", ch, obj, null, SocketConnection.MessageTarget.room);

            switch (obj.ItemType)
            {

                case ObjTemplate.ObjectType.food:
                    if (!ch.IsNPC())
                    {
                        int condition = ((PC)ch).Hunger;
                        if (!ch.IsUndead())
                        {
                            ch.AdjustHunger(obj.Values[0]);
                        }
                        if (((PC)ch).Hunger > 40)
                        {
                            ch.SendText("You are full.\r\n");
                        }
                        else if (condition == 0 && ((PC)ch).Hunger > 0)
                        {
                            ch.SendText("You are no longer hungry.\r\n");
                        }
                    }

                    if (obj.Values[3] != 0 && !CharData.CheckImmune(ch, Race.DamageType.poison))
                    {
                        /* The shit was poisoned! */
                        Affect af = new Affect();

                        SocketConnection.Act("$n chokes and gags.", ch, null, null, SocketConnection.MessageTarget.room);
                        ch.SendText("You choke and gag.\r\n");

                        af.Type = Affect.AffectType.spell;
                        af.Value = "poison";
                        af.Duration = 2 * obj.Values[0];
                        af.AddModifier(Affect.Apply.strength, -(obj.Level / 7 + 2));
                        af.SetBitvector(Affect.AFFECT_POISON);
                        ch.CombineAffect(af);
                    }
                    break;

                case ObjTemplate.ObjectType.pill:
                    {
                        for (int i = 1; i <= 4; i++)
                        {
                            String spellName = SpellNumberToTextMap.GetSpellNameFromNumber(obj.Values[i]);
                            if (String.IsNullOrEmpty(spellName))
                            {
                                Log.Error("Eat: Spell number " + obj.Values[i] + " not found for pill object " + obj.ObjIndexNumber + ". Make sure it's in the SpellNumberToTextMap.");
                            }
                            Spell spell = StringLookup.SpellLookup(spellName);
                            if (!spell)
                            {
                                Log.Error("Eat: Spell '" + spellName + "' not found for pill object " + obj.ObjIndexNumber + ". Make sure it's in the spells file.");
                            }
                            else
                            {
                                spell.Invoke(ch, obj.Values[0], ch);
                            }
                        }
                    }
                    break;
            }

            if (!ch.IsNPC() || (ch.IsNPC() && ch.IsAffected(Affect.AFFECT_CHARM)))
            {
                obj.RemoveFromWorld();
            }
            return;
        }

        public static void Invoke(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (str.Length == 0)
            {
                ch.SendText("Invoke what?\r\n");
                return;
            }

            Object obj = ch.GetObjWear(str[0]);
            if (!obj)
            {
                ch.SendText("You do not have that item equipped.\r\n");
                return;
            }

            Object.Invoke(ch, obj);
            return;
        }

        public static void HideItem(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (str.Length == 0)
            {
                ch.SendText("Hide what?\r\n");
                return;
            }

            Object obj = Object.GetObjectInRoom(ch, str[0]);
            if (!obj)
            {
                ch.SendText("You do not see that here.\r\n");
                return;
            }

            if (!obj.HasWearFlag(ObjTemplate.WEARABLE_CARRY))
            {
                SocketConnection.Act("You attempt to hide $p&n.", ch, obj, null, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n stands in front of $p&n with arms outstretched.",
                    ch, obj, null, SocketConnection.MessageTarget.room);
                ch.WaitState(12);
                return;
            }
            if (obj.ItemType == ObjTemplate.ObjectType.pc_corpse || obj.ItemType == ObjTemplate.ObjectType.npc_corpse)
            {
                ch.SendText("You can't hide corpses.\r\n");
                return;
            }
            SocketConnection.Act("You hide $p&n.", ch, obj, null, SocketConnection.MessageTarget.character);
            SocketConnection.Act("$n&n hides $p&n.", ch, obj, null, SocketConnection.MessageTarget.room);
            obj.AddFlag(ObjTemplate.ITEM_SECRET);

            ch.WaitState(24);

            return;
        }

        /// <summary>
        /// Immortal command to add a news entry to the game news.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void NewsEntry(CharData ch, string[] str)
        {
            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("newsentry"))
            {
                return;
            }

            String content = String.Join(" ", str);
            String color = String.Empty;
            if (!ch.IsNPC() && ((PC)ch).ImmortalData != null)
            {
                color = ((PC)ch).ImmortalData.ImmortalColor;
            }
            Database.SystemData.AddNewsEntry(ch._name, DateTime.Now.ToShortDateString(), content, color);
            Sysdata.Save();
            ch.SendText("Ok.\r\n");
        }

        /// <summary>
        /// Allows an immortal to set his or her signature color.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void SetImmortalColor(CharData ch, string[] str)
        {
            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("immcolor"))
            {
                return;
            }

            if (ch.IsNPC() || ((PC)ch).ImmortalData == null)
            {
                return;
            }

            if (str.Length == 0 || string.IsNullOrEmpty(str[0]))
            {
                ch.SendText("Your immortal color is currently: " + ((PC)ch).ImmortalData.ImmortalColor + "THIS&n.\r\n" );
                return;
            }

            ((PC)ch).ImmortalData.ImmortalColor = str[0];
            ch.SendText("Your immortal color is now: " + ((PC)ch).ImmortalData.ImmortalColor + "THIS&n.\r\n");
            return;
        }

        /// <summary>
        /// Immortal command to kill a character in cold blood.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Slay(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("slay"))
            {
                return;
            }

            if (str.Length < 1 || String.IsNullOrEmpty(str[0]))
            {
                ch.SendText("Slay whom?\r\n");
                return;
            }

            CharData victim = ch.GetCharRoom(str[0]);
            if (!victim)
            {
                ch.SendText("They aren't even here.\r\n");
                return;
            }

            if (ch == victim)
            {
                ch.SendText("You aren't powerful enough to kill yourself.\r\n");
                return;
            }

            if (!victim.IsNPC() && victim._level >= ch._level)
            {
                ch.SendText("You failed.\r\n");
                return;
            }

            if (str.Length > 1 && "immolate".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                SocketConnection.Act("Your &n&+rfi&+Rr&n&+re&+Rba&n&+rll&n turns $N into a blazing &n&+rinf&+Rer&+Yn&+Wo&n.",
                     ch, null, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n releases a searing &n&+rfi&+Rr&n&+re&+Rba&n&+rll&n in your direction.",
                     ch, null, victim, SocketConnection.MessageTarget.victim);
                SocketConnection.Act("$n points at $N, who bursts into a flaming &n&+rinf&+Rer&+Yn&+Wo&n.",
                     ch, null, victim, SocketConnection.MessageTarget.room_vict);
            }
            else if (str.Length > 1 && "pounce".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase) && ch.GetTrust() >= Limits.LEVEL_OVERLORD)
            {
                SocketConnection.Act("Leaping upon $N with bared &+Wfangs&n, you tear open $S throat and toss the &+Lcorpse&n to the &n&+yground&n...",
                     ch, null, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("In a heartbeat, $n rips $s &+Wfangs&n through your throat!  Your &+Rbl&n&+ro&+Ro&n&+rd&n sprays and pours to the &n&+yground&n as your life ends...",
                     ch, null, victim, SocketConnection.MessageTarget.victim);
                SocketConnection.Act("Leaping suddenly, $n sinks $s &+Wfangs&n into $N's throat.  As &+Rbl&n&+ro&+Ro&n&+rd&n sprays and gushes to the &n&+yground&n, $n tosses $N's dying body away.",
                     ch, null, victim, SocketConnection.MessageTarget.room_vict);
            }
            else if (str.Length > 1 && "shatter".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                SocketConnection.Act("You freeze $N with a glance and shatter the frozen &+Lcorpse&n into tiny &+Wsh&+Ca&+Wr&+Cds&n.",
                     ch, null, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n freezes you with a glance and shatters your frozen body into tiny &+Wsh&+Ca&+Wr&+Cds&n.",
                     ch, null, victim, SocketConnection.MessageTarget.victim);
                SocketConnection.Act("$n freezes $N with a simple look and shatters the frozen body into tiny &+Wsh&+Ca&+Wr&+Cds&n.",
                     ch, null, victim, SocketConnection.MessageTarget.room_vict);
            }
            else if (str.Length > 1 && "slit".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase) && ch.GetTrust() >= Limits.LEVEL_OVERLORD)
            {
                SocketConnection.Act("You calmly &+Lslit&n $N's throat.",
                     ch, null, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n reaches out with a clawwed finger and calmly &+Lslits&n your throat.",
                     ch, null, victim, SocketConnection.MessageTarget.victim);
                SocketConnection.Act("$n calmly &+Lslits&n $N's throat.",
                     ch, null, victim, SocketConnection.MessageTarget.room_vict);
            }
            else if (str.Length > 1 && "squeeze".StartsWith(str[1], StringComparison.CurrentCultureIgnoreCase))
            {
                SocketConnection.Act("You grasp $S head and squeeze it until it explodes in a bubble of &+Rbl&n&+ro&+Ro&n&+r&n!",
                     ch, null, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n grasps your head and squeezes until your &+Wskull&n colapses!",
                     ch, null, victim, SocketConnection.MessageTarget.victim);
                SocketConnection.Act("$n grasps $N's head and squeezes until it implodes!",
                     ch, null, victim, SocketConnection.MessageTarget.room_vict);
            }
            else
            {
                SocketConnection.Act("You &+Lslay&n $M in cold &+Rbl&n&+ro&+Ro&n&+rd&n!", ch, null, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n &+Lslays&n you in cold &+Rbl&n&+ro&+Ro&n&+rd&n!", ch, null, victim, SocketConnection.MessageTarget.victim);
                SocketConnection.Act("$n &+Lslays&n $N in cold &+Rbl&n&+ro&+Ro&n&+rd&n!", ch, null, victim, SocketConnection.MessageTarget.room_vict);
            }

            Combat.KillingBlow(ch, victim);

            return;
        }

        public static void Finger(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;
            SocketConnection victDD;
            bool loggedIn;

            if (ch.IsNPC())
                return;

            if (str.Length == 0)
            {
                ch.SendText("Finger whom?\r\n");
                return;
            }

            /* Look for the character logged in. */
            if ((victim = ch.GetCharWorld(str[0])))
            {
                if (victim.IsNPC())
                {
                    ch.SendText("Don't finger mobs.\r\n");
                    return;
                }
                if (!victim._socket)
                {
                    ch.SendText("Character is linkdead.\r\n");
                    if (!CharData.LoadPlayer((victDD = new SocketConnection()), str[0]))
                    {
                        /* If not in save files, they don't exist. */
                        ch.SendText("This character does not exist.\r\n");
                        return;
                    }
                    loggedIn = false;
                }
                else
                {
                    loggedIn = true;
                    ch.SendText("This character is logged in.\r\n");
                    victDD = victim._socket;
                }
            }   /* If not, then load from save files. */
            else
            {
                loggedIn = false;

                if (!(CharData.LoadPlayer((victDD = new SocketConnection()), str[0].ToUpper())))
                {
                    /* If not in save files, they don't exist. */
                    ch.SendText("This character does not exist.\r\n");
                    return;
                }
                else
                    ch.SendText("This character is not logged in.\r\n");
                victim = victDD.Original ? victDD.Original : victDD.Character;
            }

            /* Display general character info. */
            string buf = String.Format("Name: {0}. Title: {1}&n.\r\n",
                                       victDD.Original ? victDD.Original._name :
                                                                                     victDD.Character ? victDD.Character._name : "(none)",
                                       (!victim.IsNPC() && ((PC)victim).Title.Length != 0)
                                           ? ((PC)victim).Title : "(none)");
            ch.SendText(buf);
            buf = String.Format("Clan: {0}&n. Level: {1}&n.\r\n",
                    (!victim.IsNPC() && ((PC)victim).Clan != null)
                    ? ((PC)victim).Clan.Name : "(none)",
                    victim._level);
            ch.SendText(buf);
            buf = String.Format("Class: {0}&n. Room: {1}&n.  Race: {2}&n.\r\n",
                    (victim._charClass != null ?
                    victim._charClass.WholistName : "(Undefined)"),
                    victim._inRoom ? victim._inRoom.IndexNumber : -1,
                    (victim.GetRace() < Race.RaceList.Length && victim.GetRace() >= 0) ?
                    Race.RaceList[victim.GetRace()].ColorName : "(Undefined)");
            ch.SendText(buf);

            /* Messages specific to whether a player is logged in. */
            if (loggedIn)
            {
                if (victim._inRoom)
                {
                    buf = String.Format("In room: {0}&n ({1}).\r\n",
                            victim._inRoom.Title.Length != 0 ? victim._inRoom.Title : "(none)",
                            victim._inRoom.IndexNumber);
                    ch.SendText(buf);
                }
                buf = String.Format("On since: {0}", victim._logon);
            }
            else
                buf = String.Format("Created: {0}  Birthdate: {1}", ((PC)victim).Created, ((PC)victim).Birthdate);
            ch.SendText(buf);

            if (loggedIn)
            {
                buf = String.Format("Last save: {0}", victim._saveTime);
                ch.SendText(buf);
            }
            else
            {
                buf = String.Format("Last logged in: {0}", victim._saveTime);
                ch.SendText(buf);
            }

            /* Close rented chars pfile (w/out saving!). */
            if (!loggedIn)
                victDD = null;

            return;
        }

        public static void ZoneReset(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Area pArea;
            string buf = String.Empty;

            if (String.IsNullOrEmpty(str[0]))
            {
                pArea = ch._inRoom.Area;
                Database.ResetArea(pArea);
                ch.SendText("This zone has been &+Wreset&n.\r\n");
                buf += "&+WZone&n " + pArea.Filename + " &+Wreset&n by " + ch._name + ".";
                ImmortalChat.SendImmortalChat(null, ImmortalChat.IMMTALK_RESETS, Limits.LEVEL_OVERLORD, buf);
                return;
            }
            Room location = Room.FindLocation(ch, str[0]);
            if (!location)
            {
                ch.SendText("No such location.\r\n");
                return;
            }
            Database.ResetArea(location.Area);
            buf += "&+WZone&n " + location.Area.Filename + " &+Wreset.&n\r\n";
            ch.SendText(buf);
            buf += " by " + ch._name + ".";
            ImmortalChat.SendImmortalChat(null, ImmortalChat.IMMTALK_RESETS, Limits.LEVEL_OVERLORD, buf);

            return;
        }

        /// <summary>
        /// God command bitvector calculator.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void BitFlag(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int number;

            if (str.Length == 0 || !MUDString.IsNumber(str[0]))
            {
                ch.SendText("You can't do math without a number.\r\n");
                return;
            }

            Int32.TryParse(str[0], out number);

            string text = "The bitvector value for that number is:";

            if (Macros.IsSet(number, Bitvector.BV00))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV01))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV02))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV03))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV04))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV05))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV06))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV07))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV08))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV09))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV10))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV11))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV12))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV13))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV14))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV15))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV16))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV17))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV18))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV19))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV20))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV21))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV22))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV23))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV24))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV25))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV26))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV27))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV28))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV29))
                text += "1";
            else
                text += "0";
            if (Macros.IsSet(number, Bitvector.BV30))
                text += "1";
            else
                text += "0";

            text += "\r\n";
            ch.SendText(text);
            return;
        }

        public static void KillProcess(CharData ch, string[] str)
        {
            if( ch == null ) return;

            //CharData rch;

            //rch = ch.GetChar();

            //if( rch.GetTrust() < 60 )
            //    return;

            //if( !ch.IsNPC() )
            //{
            //    system( "kill -9 `ps aux | grep magma | grep 4502 | cut -c 10-14`" );
            //    ch.SendText( "Mud Terminated with extreme prejudice!\r\n" );
            //}
            Log.Error("Killproc command has been disabled.");
            return;

        }

        public static void RandomSentence(CharData ch, string[] str)
        {
            if( ch == null ) return;

            ch.SendText("Random sentence: '");
            ch.SendText(NounType.RandomSentence());
            ch.SendText("'\r\n");
        }

        public static void ResetLanguages(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;

            if (str.Length == 0)
            {
                ch.SendText("Try supplying more information with your command.\r\n");
                return;
            }

            if (!(victim = ch.GetCharWorld(str[0])))
            {
                ch.SendText("You don't see that person.\r\n");
            }
            else
            {
                if (victim.IsNPC())
                {
                    ch.SendText("Not on NPCS!\r\n");
                    return;
                }

                victim.InitializeLanguages();
                string buf = String.Format("{0} has had their languages Reset.\r\n", victim._name);
                ch.SendText(buf);

            }
        }

        public static void SetLanguage(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string buf = String.Empty;
            int num;

            if (str.Length == 0)
            {
                ch.SendText("Syntax: set language <char> <language> <number>.\r\n");
                return;
            }

            if (!(ch.GetCharWorld(buf)))
                ch.SendText("You don't see that person.\r\n");

            Race.Language lang = IntLanguage(ch, buf);
            if (lang == 0)
            {
                ch.SendText("Syntax: set language <char> &+r<language>&n <number>.\r\n");
                return;
            }

            Int32.TryParse(buf, out num);
            if (num == 0)
            {
                ch.SendText("Syntax: set language <char> <language> &+r<number>&n\r\n");
                return;
            }

        }

        public static void AreaList(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Area area;

            string buf = String.Format("[{0}] [{1}/{2}] [{3}] {4} [{5}]\r\n",
                                       "Area Name", "lindex", "uindex", "Filename", "Sec", "Builders");
            ch.SendText(buf);

            foreach (Area it in Database.AreaList)
            {
                area = it;
                buf = String.Format("{0} {1} &n[{2}/{3}] {4} [{5}] [{6}]&n\r\n",
                        area.Author,
                        area.Name,
                        area.LowIndexNumber,
                        area.HighIndexNumber,
                        area.Filename,
                        area.Security,
                        area.Builders);
                ch.SendText(buf);
            }

            return;
        }

        public static void Monkstat(CharData ch, string[] str)
        {
            if( ch == null ) return;
            int count;

            for (count = 0; count < MonkSkill.Table.Length; ++count)
            {
                string buf = String.Format("Skill:  {0}  Point Costs:  {1}\r\n",
                                            MUDString.PadStr(MonkSkill.Table[count].Name, 30), MonkSkill.Table[count].Points[0]);
                ch.SendText(buf);
            }

            return;
        }

        // TODO: FIXME: BUG: Not modified to work with new code yet.
        public static void SetMonkSkill(CharData ch, string[] str)
        {
            if( ch == null ) return;

            //CharData victim;
            //string arg1 = String.Empty;
            //string arg2 = String.Empty;
            //string arg3 = String.Empty;
            //int value;
            //int sn;
            //bool fAll;

            //argument = MUDString.OneArgument(argument, ref arg1);
            //argument = MUDString.OneArgument(argument, ref arg2);
            //MUDString.OneArgument(argument, ref arg3);

            //if (String.IsNullOrEmpty(arg1) || String.IsNullOrEmpty(arg2) || String.IsNullOrEmpty(arg3))
            //{
            //    ch.SendText("Syntax: set monkskill <victim> <skill> <value>\r\n");
            //    ch.SendText("or:     set monkskill <victim> all     <value>\r\n");
            //    ch.SendText("Skill being any monk skill.\r\n");
            //    return;
            //}

            //if (!(victim = ch.GetCharWorld(arg1)))
            //{
            //    ch.SendText("They aren't here.\r\n");
            //    return;
            //}

            //if (victim.IsNPC())
            //{
            //    ch.SendText("Not on NPC's.\r\n");
            //    return;
            //}

            //if (ch._level <= victim._level && ch != victim && MUDString.StringsNotEqual(ch._name, "Xangis"))
            //{
            //    ch.SendText("You may not set your peer nor your superior.\r\n");
            //    return;
            //}

            //fAll = !MUDString.StringsNotEqual(arg2, "all");
            //sn = 0;
            //if (!fAll && (sn = StringLookup.MonkSkillLookup(arg2)) < 0)
            //{
            //    ch.SendText("No such monk skill.\r\n");
            //    return;
            //}

            ///*
            //* Snarf the value.
            //*/
            //if (!MUDString.IsNumber(arg3))
            //{
            //    ch.SendText("Value must be numeric.\r\n");
            //    return;
            //}

            //Int32.TryParse(arg3, out value);
            //if (value < 0 || value > Limits.MAX_SKILL_ADEPT)
            //{
            //    ch.SendText("Value range is 0 to 95.\r\n");
            //    return;
            //}

            //if (fAll)
            //{
            //    if (ch.GetTrust() < Limits.L_DIR)
            //    {
            //        ch.SendText("Only Directors may set all.\r\n");
            //        return;
            //    }
            //    for (sn = 0; sn < MonkSkill.Table.Length; sn++)
            //    {
            //        ((PC)victim).MonkAptitude[sn] = value;
            //    }
            //}
            //else
            //{
            //    ((PC)victim).MonkAptitude[sn] = value;
            //}

            //return;
        }

        public static void StatDump(CharData ch, string[] str)
        {
            if( ch == null ) return;

            ObjTemplate pObjIndex;
            Object obj;
            int indexNumber;

            FileStream fp = File.OpenWrite("objects.txt");
            StreamWriter sw = new StreamWriter(fp);

            for (indexNumber = 100; indexNumber < 100000; indexNumber++)
            {
                pObjIndex = Database.GetObjTemplate(indexNumber);
                if (!pObjIndex)
                    continue;

                obj = Database.CreateObject(pObjIndex, 0);

                string buf = String.Format("{0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}",
                                            pObjIndex.IndexNumber, pObjIndex.ShortDescription,
                                            pObjIndex.ItemType, obj.Cost,
                                            obj.Values[0],
                                            obj.Values[1],
                                            obj.Values[2],
                                            obj.Values[3]);

                sw.WriteLine(buf);
            }

            sw.Flush();
            sw.Close();

            return;
        }

        public static void NameSucks(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (!ch.Authorized("namesucks"))
            {
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Whose name sucks?\r\n");
                return;
            }

            if (MUDString.NameContainedIn(str[0], Database.SystemData.BannedNames))
            {
                ch.SendText("That name is already banned.\r\n");
                return;
            }

            Database.SystemData.BannedNames += str[0];
            Database.SystemData.BannedNames += " ";

            string buf = String.Format("{0} is now considered an illegal name.", str[0]);
            SocketConnection.Act(buf, ch, null, null, SocketConnection.MessageTarget.character);
            Log.Trace(ch._name + ": " + buf);

            Sysdata.Save();
        }

        /// <summary>
        /// Immortal command to display info about a reace.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void StatRace(CharData ch, string[] str)
        {
            int num;
            CharData realChar = ch.GetChar();

            if (str.Length == 0)
            {
                num = (int)realChar._charClass.ClassNumber;
            }
            else if (MUDString.IsNumber(str[0]))
            {
                Int32.TryParse(str[0], out num);
            }
            else
            {
                num = Race.RaceLookup(str[0]);
            }

            if (num < 0 || num >= Race.RaceList.Length)
            {
                ch.SendText("Invalid race number!\r\n");
                return;
            }

            string buf1 = String.Format("&+WRacial stats for race {0}&n\r\n\r\n", num);

            string text = String.Format("Name:  {0}  ANSI Name: {1}\r\n",
                                       Race.RaceList[num].Name,
                                       Race.RaceList[num].ColorName);
            buf1 += text;

            text = String.Format("Key:  {0}  Size:  {1}\r\n",
                    Race.RaceList[num].Key,
                    Race.RaceList[num].DefaultSize);
            buf1 += text;

            text = String.Format("Height:  {0} inches.  Weight:  {1} pounds.  Base Alignment:  {2} ({3})\r\n",
                    Race.RaceList[num].Height,
                    Race.RaceList[num].Weight,
                    Race.RaceList[num].BaseAlignment,
                    StringConversion.AlignmentString(Race.RaceList[num].BaseAlignment));
            buf1 += text;

            text = String.Format("&+WStat modifiers: (Max. stats):&n\r\n");
            buf1 += text;

            text = String.Format("Str: {0}  Int: {1}  Wis: {2}  Dex: {3}  Con: {4}\r\nAgi: {5}  Cha: {6}  Pow: {7}  Luk: {8}\r\n",
                    Race.RaceList[num].StrModifier,
                    Race.RaceList[num].IntModifier,
                    Race.RaceList[num].WisModifier,
                    Race.RaceList[num].DexModifier,
                    Race.RaceList[num].ConModifier,
                    Race.RaceList[num].AgiModifier,
                    Race.RaceList[num].ChaModifier,
                    Race.RaceList[num].PowModifier,
                    Race.RaceList[num].LukModifier);
            buf1 += text;

            text = String.Format("HP Gain (unused):  {0}  Mana Gain: {1}  Move Gain (unused): {2}\r\n",
                    Race.RaceList[num].HpGain,
                    Race.RaceList[num].ManaGain,
                    Race.RaceList[num].MoveGain);
            buf1 += text;

            text = String.Format("Thirst Mod (unused):  {0}  Hunger Mod (unused): {1}\r\nDamage Message: {2}  Walk Message: {3}\r\n",
                    Race.RaceList[num].ThirstModifier,
                    Race.RaceList[num].HungerModifier,
                    Race.RaceList[num].DamageMessage,
                    Race.RaceList[num].WalkMessage);
            buf1 += text;

            text = String.Format("Hatred:  {0}.\r\nParts:  {1}.\r\nResist:  {2}.  Immune:  {3}.\r\nSusceptible: {4}.  Vulnerable: {5}.\r\n",
                    Race.RaceList[num].Hate,
                    Race.RaceList[num].BodyParts,
                    Race.RaceList[num].Resistant,
                    Race.RaceList[num].Immune,
                    Race.RaceList[num].Susceptible,
                    Race.RaceList[num].Vulnerable);
            buf1 += text;

            text = String.Format("Racewar Side: {0}  Language:  {1}  Base Age: {2}  Max Age: {3}\r\n",
                    Race.RaceList[num].WarSide,
                    Race.RaceList[num].PrimaryLanguage,
                    Race.RaceList[num].BaseAge,
                    Race.RaceList[num].MaxAge);
            buf1 += text;

            realChar.SendText(buf1);
            return;
        }

        public static void ResetCommand(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("Reset"))
                return;

            if (str.Length == 0)
            {
                ch.SendText("Reset what or whom?\r\n");
                return;
            }

            CharData victim = realChar.GetCharWorld(str[0]);
            if (!victim)
            {
                ch.SendText("To Reset a char's stats type RESET CHARNAME.\r\n");
                return;
            }
            victim.ResetStats();
            return;
        }

        /// <summary>
        /// Shows all of the mobiles in the current area.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void ShowMobiles(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int count = 0;

            if (ch._inRoom == null)
            {
                ch.SendText("You're not in an room?!\r\n");
                return;
            }
            if (ch._inRoom.Area == null)
            {
                ch.SendText("You are not in an area?!\r\n");
                return;
            }
            if (ch._inRoom.Area.Mobs == null)
            {
                ch.SendText("The area you are in has no mobs?!\r\n");
                return;
            }

            foreach (MobTemplate mobi in ch._inRoom.Area.Mobs)
            {
                ++count;
                string buf = String.Format("{0}) [{1}] '{2}'&n\r\n",
                                            MUDString.PadInt(count, 3),
                                            MUDString.PadInt(mobi.IndexNumber, 7),
                                            mobi.ShortDescription);
                ch.SendText(buf);
            }
            if (count == 0)
            {
                ch.SendText("No mobiles associated with this area.\r\n");
            }
        }

        /// <summary>
        /// Lists all objects in the current area.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void ShowObjects(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int count = 0;

            if (ch._inRoom == null)
            {
                ch.SendText("You're not in an room?!\r\n");
                return;
            }
            if (ch._inRoom.Area == null)
            {
                ch.SendText("You are not in an area?!\r\n");
                return;
            }
            if (ch._inRoom.Area.Objects == null)
            {
                ch.SendText("The area you are in has no objects?!\r\n");
                return;
            }

            foreach (ObjTemplate obji in ch._inRoom.Area.Objects)
            {
                ++count;
                string buf = String.Format("{0}) [{1}] '{2}'&n\r\n",
                                            MUDString.PadInt(count, 3),
                                            MUDString.PadInt(obji.IndexNumber, 7),
                                            obji.ShortDescription);
                ch.SendText(buf);
            }
            if (count == 0)
            {
                ch.SendText("No objects associated with this area.\r\n");
            }
        }

        /// <summary>
        /// Shows all of the rooms in the current area.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void ShowRooms(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int count = 0;

            if (ch._inRoom == null)
            {
                ch.SendText("You're not in an room?!\r\n");
                return;
            }
            if (ch._inRoom.Area == null)
            {
                ch.SendText("You are not in an area?!\r\n");
                return;
            }
            if (ch._inRoom.Area.Rooms == null)
            {
                ch.SendText("The area you are in has no rooms?!\r\n");
                return;
            }

            foreach (Room roomi in ch._inRoom.Area.Rooms)
            {
                ++count;
                string buf = String.Format("{0}) [{1}] '{2}'&n\r\n",
                                            MUDString.PadInt(count, 3),
                                            MUDString.PadInt(roomi.IndexNumber, 7),
                                            roomi.Title);
                ch.SendText(buf);
            }
            if (count == 0)
            {
                ch.SendText("No rooms associated with this area.\r\n");
            }
        }

        /// <summary>
        /// Show: Lists rooms, objects, or mobiles.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Show(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("show"))
                return;

            if (str.Length == 0)
            {
                ch.SendText("Try listing MOBILES, ROOMS, or OBJECTS.\r\n");
                return;
            }

            if (!MUDString.IsPrefixOf(str[0], "rooms"))
            {
                ShowRooms(ch, str);
            }
            else if (!MUDString.IsPrefixOf(str[0], "objects"))
            {
                ShowObjects(ch, str);
            }
            else if (!MUDString.IsPrefixOf(str[0], "mobiles") || !MUDString.StringsNotEqual(str[0], "mobs"))
            {
                ShowMobiles(ch, str);
            }
            else
            {
                ch.SendText("Try listing MOBILES, ROOMS, or OBJECTS.\r\n");
            }

            return;
        }

        /// <summary>
        /// Finds a mob or list of mobiles in the area or in the world.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void FindMobile(CharData ch, string[] str)
        {
            if( ch == null ) return;

            MobTemplate pMobIndex;
            int indexNumber;
            int bottom;
            int top;
            bool fRace = false;
            bool fTeacher = false;
            bool fClass = false;
            int race = 0;
            ModernMUD.CharClass.Names charclass = 0;

            ch.GetChar();

            if (str.Length < 2 || (MUDString.StringsNotEqual(str[0], "world") && MUDString.StringsNotEqual(str[0], "area")
                                    && MUDString.StringsNotEqual(str[0], "race") && MUDString.StringsNotEqual(str[0], "teacher")))
            {
                ch.SendText("Syntax: find m world <mobile>|all\r\n");
                ch.SendText("or:     find m area  <mobile>|all\r\n");
                ch.SendText("        find m race  <racename> <class>\r\n");
                ch.SendText("        find m teacher race|class|all <race|class>\r\n");
                return;
            }

            if (String.IsNullOrEmpty(str[1]))
            {
                ch.SendText("Find what mob?\r\n");
                return;
            }

            bool fAll = !MUDString.StringsNotEqual(str[1], "all");
            bool found = false;
            Area area = ch._inRoom.Area;
            bool fWorld = !MUDString.StringsNotEqual(str[0], "world");
            if (!MUDString.StringsNotEqual(str[0], "race"))
            {
                int value;
                fRace = true;
                fWorld = true;
                bool result = Int32.TryParse(str[1], out value);
                if (result != false)
                {
                    race = Race.RaceLookup(str[1]);
                }
                if (race == -1)
                {
                    ch.SendText("Lookup mobs of what race?\r\n");
                    return;
                }
                if (!MUDString.StringsNotEqual(str[1], "class") && str.Length > 2)
                {
                    fClass = true;
                    charclass = CharClass.ClassLookup(str[2]);
                }
            }
            if (fWorld)
            {
                bottom = 0;
                top = Database.HighestMobIndexNumber;
            }
            else
            {
                bottom = area.LowMobIndexNumber;
                top = area.HighMobIndexNumber + 1;
            }

            /*
            * Yeah, so iterating over all index numbers takes one loop for each index.
            */
            for (indexNumber = bottom; indexNumber < top; indexNumber++)
            {
                pMobIndex = Database.GetMobTemplate(indexNumber);
                if (!pMobIndex)
                    continue;

                if (!fWorld && area != pMobIndex.Area)
                    continue;

                if (fAll || MUDString.NameContainedIn(str[1], pMobIndex.PlayerName))
                {
                    if (fAll || MUDString.NameContainedIn(str[1], pMobIndex.PlayerName)
                            || (fRace && pMobIndex.Race == race) ||
                            (fClass && pMobIndex.CharacterClass.ClassNumber == charclass))
                    {
                        if (fTeacher && !pMobIndex.HasActBit(MobTemplate.ACT_TEACHER))
                            continue;

                        found = true;
                        string buf = String.Format("[{0}] {1}&n\r\n", MUDString.PadInt(pMobIndex.IndexNumber, 5), pMobIndex.ShortDescription.ToUpper());
                        ch.SendText(buf);
                    }
                }
            }

            if (!found)
            {
                ch.SendText("Nothing like that in &+rhell&n, &+gea&+brth&n, or &+Yhea&+Wven&n.\r\n");
                return;
            }

            return;
        }

        public static void ShowSockets(CharData ch, string[] str)
        {
            if (ch == null)
            {
                return;
            }
            int count = 0;
            CharData chr;

            foreach (SocketConnection socket in Database.SocketList)
            {
                ++count;
                string buf = String.Format("Descriptor {0} connected state {1} character {2}",
                                            count, socket._connectionState, socket.Character ? socket.Character._name : "None");
                if (socket.Character != null)
                {
                    foreach (CharData cit in Database.CharList)
                    {
                        chr = cit;
                        if (socket.Character == chr)
                        {
                            buf += " found in CharList by pointer";
                        }
                        if (!MUDString.StringsNotEqual(socket.Character._name, chr._name))
                        {
                            buf += " found in CharList by _name";
                        }
                    }
                }
                buf += "\r\n";
                ch.SendText(buf);
            }

            return;
        }

        /// <summary>
        /// Command to view and manipulate entries in the issue system.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void IssueCommand(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (!ch.IsImmortal())
            {
                ch.SendText("Yes, you do have issues.\r\n");
                return;
            }

            if ((str.Length == 0) || "list".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
            {
                ch.SendText(Issue.ShowIssues());
                return;
            }
            if ("show".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
            {
                if (str.Length < 2)
                {
                    ch.SendText("Show which issue number?\r\n");
                    return;
                }
                int val;
                bool ok = Int32.TryParse(str[1], out val);
                if (ok)
                {
                    ch.SendText(Issue.Format(val));
                    return;
                }
                ch.SendText("That's not a valid issue number.\r\n");
                return;
            }
            if ("add".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase) || "create".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
            {
                String text = String.Join(" ", str, 1, (str.Length - 1));
                Issue issue = new Issue();
                issue.IssueDetail = new IssueEntry(ch._name, text);
                issue.OpenedByImmortal = ch.IsImmortal();
                issue.IssueType = Issue.Type.bug;
                issue.IssuePriority = Issue.Priority.medium;
                if (ch._inRoom != null)
                {
                    issue.RoomIndexNumber = ch._inRoom.IndexNumber;
                }
                Database.IssueList.Add(issue);
                string output = String.Format("New issue # {0}: {1} (created by {2}).\n", issue.IssueNumber, text, ch._name);
                ImmortalChat.SendImmortalChat(null, ImmortalChat.IMMTALK_DEBUG, 0, output);
                Issue.Save();
                ch.SendText(output);
                return;
            }
            if ("close".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
            {
                if (str.Length < 2)
                {
                    ch.SendText("Close which issue number?\r\n");
                    return;
                }
                if (str.Length < 3)
                {
                    ch.SendText("Syntax: issue close <number> <resolution text>\r\n");
                    return;
                }
                int val;
                bool ok = Int32.TryParse(str[1], out val);
                if (ok)
                {
                    foreach (Issue iss in Database.IssueList)
                    {
                        if (iss.IssueNumber == val)
                        {
                            iss.Closed = true;
                            iss.Closure = new IssueEntry();
                            iss.Closure.Name = ch._name;
                            string text = String.Empty;
                            for (int i = 2; i < str.Length; i++)
                            {
                                text += str[i] + " ";
                            }
                            iss.Closure.Text = text;
                            iss.Closure.UpdateTime = DateTime.Now;
                            Issue.Save();
                            ch.SendText("Issue " + val + " closed with resolution " + text + "\r\n");
                            return;
                        }
                    }
                }
                ch.SendText("That's not a valid issue number.\r\n");
            }
            else if ("update".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
            {
                if (str.Length < 2)
                {
                    ch.SendText("Update which issue number?\r\n");
                    return;
                }
                if (str.Length < 3)
                {
                    ch.SendText("Syntax: issue update <number> <text>\r\n");
                    return;
                }
                int val;
                bool ok = Int32.TryParse(str[1], out val);
                if (ok)
                {
                    foreach (Issue iss in Database.IssueList)
                    {
                        if (iss.IssueNumber == val)
                        {
                            IssueEntry ie = new IssueEntry();
                            ie.Name = ch._name;
                            string text = String.Empty;
                            for( int i = 2; i < str.Length; i++ )
                            {
                                text += str[i] + " ";
                            }
                            ie.Text = text;
                            ie.UpdateTime = DateTime.Now;
                            iss.Updates.Add(ie);
                            Issue.Save();
                            ch.SendText("Issue " + val + " updated with text " + text + "\r\n");
                            return;
                        }
                    }
                }
            }
            else if ("priority".StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
            {
                if (str.Length < 2)
                {
                    ch.SendText("Set priority on which issue number?\r\n");
                    return;
                }
                if (str.Length < 3)
                {
                    ch.SendText("Syntax: issue priority <number> <lowest|low|medium|high|highest>\r\n");
                    return;
                }
                int val;
                bool ok = Int32.TryParse(str[1], out val);
                if (ok)
                {
                    foreach (Issue iss in Database.IssueList)
                    {
                        if (iss.IssueNumber == val)
                        {
                            try
                            {
                                iss.IssuePriority = (Issue.Priority)Enum.Parse(typeof(Issue.Priority), str[2], true);
                                Issue.Save();
                                ch.SendText("Issue " + val + " priority set to " + iss.IssuePriority + ".\r\n");
                            }
                            catch (Exception)
                            {
                                ch.SendText("That's not a valid priority value.  Valid values are lowest, low, medium, high, and highest.");
                                return;
                            }
                            return;
                        }
                    }
                }
                ch.SendText("That's not a valid issue number.\r\n");
            }
            else
            {
                ch.SendText(Issue.ShowIssues());
            }

            return;
        }

        /// <summary>
        /// Puts the MUD into an endless loop.  Very dangerous because it's essentially a
        /// "halt" instruction.  Used for testing the heartbeat-restart script.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void LoopMUD(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (!ch.IsImmortal())
            {
                ch.SendText("Howzat?\r\n");
                return;
            }

            if (str.Length == 0 || str[0] != "confirm")
            {
                ch.SendText("Usage: loopmud confirm\r\n");
                return;
            }

            ch.SendText("As you wish.  The mud is now in an endless loop.  I hope you know what you're doing.\r\n");
            Log.Trace(ch._name + " has just intentionally placed the MUD into an endless loop via the 'loopmud' command.");
            for (; ; )
            {
                int i = 1;
            }
        }

        public static void Apply(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch._level < 25)
            {
                ch.SendText("You don't have enough experience to join a guild.\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Where do you want to apply?\r\n");
                return;
            }

            PC leader = (PC)ch.GetCharRoom(str[0]);
            if (leader == null)
            {
                ch.SendText("You do not see that person here.\r\n");
                return;
            }

            if (leader.IsNPC() || leader.Clan == null)
            {
                ch.SendText("Apply to whom?!\r\n");
                return;
            }

            if (leader.Clan.Applicant != null)
            {
                ch.SendText("That guild is currently reviewing another applicant.  Try again later.\r\n");
                return;
            }

            leader.Clan.Applicant = ch;

            SocketConnection.Act("$n&n submits an application to join your guild.", ch, null, leader, SocketConnection.MessageTarget.victim);
            ch.SendText("You turn in your application.\r\n");

            return;
        }

        public static void Decline(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch.IsNPC() || ((PC)ch).Clan == null || ((PC)ch).ClanRank < Guild.Rank.officer)
            {
                ch.SendText("You do not have the power to initiate anyone into a guild.\r\n");
                return;
            }

            if (!((PC)ch).Clan.Applicant)
            {
                ch.SendText("Nobody wants to join your silly little guild.\r\n");
                return;
            }

            if (((PC)ch).Clan.Applicant.IsNPC())
            {
                ch.SendText("How in the heck did a mob apply to your guild!?\r\n");
                ((PC)ch).Clan.Applicant = null;
                return;
            }

            ((PC)ch).Clan.Applicant.SendText("&+RYour guild application has been declined.&n\r\n");
            ch.SendText("You decline the current guild applicant.\r\n");

            ((PC)ch).Clan.Applicant = null;

            return;
        }

        // cloned from withdraw code
        public static void GuildWithdraw(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string arg = String.Empty;

            if (ch.IsNPC())
                return;

            Guild clan = ((PC)ch).Clan;
            if (clan == null)
            {
                ch.SendText("You're not in a guild!\r\n");
                return;
            }

            if (((PC)ch).ClanRank < Guild.Rank.deputy)
            {
                ch.SendText("You'll have to be promoted before you can withdraw from the guild.\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Withdraw what?\r\n");
                return;
            }

            if (MUDString.IsNumber(str[0]))
            {
                int amount;

                Int32.TryParse(str[0], out amount);

                if (amount <= 0)
                {
                    ch.SendText("Sorry, you can't do that.\r\n");
                    return;
                }

                if ("copper".StartsWith(arg, StringComparison.CurrentCultureIgnoreCase))
                {
                    if (clan.GuildBankAccount.Copper < amount)
                    {
                        ch.SendText("The guild doesen't have that many &n&+ycopper&n coins.\r\n");
                        return;
                    }
                    ch.ReceiveCopper(amount);
                    clan.GuildBankAccount.Copper -= amount;
                }
                else if ("silver".StartsWith(arg, StringComparison.CurrentCultureIgnoreCase))
                {
                    if (clan.GuildBankAccount.Silver < amount)
                    {
                        ch.SendText("The guild doesen't have that many &n&+wsilver&n coins.\r\n");
                        return;
                    }
                    ch.ReceiveSilver(amount);
                    clan.GuildBankAccount.Silver -= amount;
                }
                else if ("gold".StartsWith(arg, StringComparison.CurrentCultureIgnoreCase))
                {
                    if (clan.GuildBankAccount.Gold < amount)
                    {
                        ch.SendText("The guild doesen't have that many &+Ygold&n coins.\r\n");
                        return;
                    }
                    ch.ReceiveGold(amount);
                    clan.GuildBankAccount.Gold -= amount;
                }
                else if ("platinum".StartsWith(arg, StringComparison.CurrentCultureIgnoreCase))
                {
                    if (clan.GuildBankAccount.Platinum < amount)
                    {
                        ch.SendText("The guild doesen't have that many &+Wplatinum&n coins.\r\n");
                        return;
                    }
                    ch.ReceivePlatinum(amount);
                    clan.GuildBankAccount.Platinum -= amount;
                }
                else
                {
                    ch.SendText("You don't have any idea what you are trying to do, do you?\r\n");
                    return;
                }

                clan.Save();
                CharData.SavePlayer(ch);

                ch.SendText("You make a withdrawal.\r\n");
            }
            else
            {
                ch.SendText("&+LSyntax:  &+RWithdraw &n&+r<&+L# of coins&n&+r> <&+Lcoin type&n&+r>&n\r\n");
            }

            return;
        }

        public static void Fine(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string arg = String.Empty;
            int amount;
            int count;

            if (arg.Length == 0)
            {
                ch.SendText("Fine whom?\r\n");
                return;
            }

            if (!ch.IsGuild() || ((PC)ch).ClanRank < Guild.Rank.deputy)
            {
                ch.SendText("You don't have the power to do this.\r\n");
                return;
            }

            Guild clan = ((PC)ch).Clan;

            Int32.TryParse(str[0], out amount);

            if (amount <= 0)
            {
                ch.SendText("Fine them how much?\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(arg, "all"))
            {
                for (count = 0; count < Limits.MAX_CLAN_MEMBERS; ++count)
                {
                    if (clan.Members[count].Filled == true &&
                            clan.Members[count].Rank < ((PC)ch).ClanRank)
                    {
                        clan.Members[count].Fine += amount;
                    }
                }
            }
            else
            {
                bool found = false;
                for (count = 0; count < Limits.MAX_CLAN_MEMBERS; ++count)
                {
                    if (MUDString.StringsNotEqual(clan.Members[count].Name, arg))
                        continue;
                    if (clan.Members[count].Filled == true &&
                            clan.Members[count].Rank < ((PC)ch).ClanRank)
                    {
                        clan.Members[count].Fine += amount;
                        found = true;
                    }
                }
                if (!found)
                {
                    ch.SendText("You were not able to fine them.\r\n");
                    return;
                }
            }

            ch.SendText("Done.\r\n");

            clan.Save();

            return;
        }

        public static void Socname(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string arg = String.Empty;
            Guild.Rank rank;

            if (!ch.IsGuild() || ((PC)ch).ClanRank < Guild.Rank.leader)
            {
                ch.SendText("You don't have the power to do this.\r\n");
                return;
            }

            if (arg.Length == 0)
            {
                ch.SendText("Reset the title on which rank?\r\n");
                return;
            }

            Guild clan = ((PC)ch).Clan;

            try
            {
                rank = (Guild.Rank)Enum.Parse(typeof(Guild.Rank), arg, false);
            }
            catch (Exception)
            {
                ch.SendText("That's not a valid rank.\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Set the rank title to what?\r\n");
                return;
            }

            clan.RankNames[(int)rank] = str[0];

            ch.SendText("Done.\r\n");

            clan.Save();

            return;
        }

        public static void Ostracize(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string arg = String.Empty;

            if (!ch.IsGuild() || ((PC)ch).ClanRank < Guild.Rank.deputy)
            {
                ch.SendText("You don't have the power to do this.\r\n");
                return;
            }

            if (arg.Length == 0)
            {
                ch.SendText("Who do you want to ostracize?\r\n");
                return;
            }

            Guild clan = ((PC)ch).Clan;

            if (MUDString.NameContainedIn(arg, clan.Ostracized))
            {
                ch.SendText("They've already been ostracized.\r\n");
                return;
            }

            string buf = String.Format("{0} {1}", clan.Ostracized, arg);

            if (!MUDString.StringsNotEqual(arg, "clear"))
            {
                buf = String.Empty;
            }

            clan.Ostracized = buf;

            ch.SendText("Done.\r\n");

            clan.Save();

            return;
        }

        public static void Hometown(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch == null)
            {
                Log.Error("Command.Hometown: No ch!", 0);
                return;
            }

            if (!ch.IsGuild() && !ch.IsImmortal())
            {
                ch.SendText("You don't have the power to do this.\r\n");
                return;
            }

            if (ch.IsNPC())
                return;

            if (!ch._inRoom.HasFlag(RoomTemplate.ROOM_GUILDROOM))
            {
                ch.SendText("You can't set your hometown here!\r\n");
                return;
            }

            if (ch._position == Position.fighting || ch._fighting)
            {
                ch.SendText("No way! You are fighting.\r\n");
                return;
            }

            if (ch._position < Position.stunned)
            {
                ch.SendText("You're not &+RD&n&+rE&+RA&n&+rD&n yet.\r\n");
                return;
            }

            string logBuf = String.Format("{0} is resetting their hometown to {1}.", ch._name, ch._inRoom.IndexNumber);
            Log.Trace(logBuf);

            ImmortalChat.SendImmortalChat(ch, ImmortalChat.IMMTALK_LOGINS, ch.GetTrust(), logBuf);

            // I can't see any reason why ch would not have an .in_room, but that
            // may just be shortsighted of me - Xangis
            if (!ch._inRoom)
            {
                Log.Error("Commandhometown: ch not in a room!", 0);
                return;
            }

            // Put them in the correct body
            if (ch._socket && ch._socket.Original)
            {
                CommandType.Interpret(ch, "return");
            }

            ch.SendText("You Reset your hometown.\r\n");
            ((PC)ch).CurrentHome = ch._inRoom.IndexNumber;

            CharData.SavePlayer(ch);

            return;
        }

        public static void Killclan(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData vch;
            //    int i;
            string arg1 = String.Empty;
            string arg2 = String.Empty;

            // get clan pointer
            Guild clan = Guild.GetClan(arg1);
            if (clan == null)
            {
                ch.SendText("That clan doesn't exist!\r\n");
                return;
            }
            // check if they really mean it
            if (MUDString.StringsNotEqual(arg2, "confirm"))
            {
                ch.SendText("Type 'killclan clanname confirm' to disband a clan.\r\n");
                return;
            }
            string buf = String.Format("You want to kill clan {0}.\r\n", clan.WhoName);
            ch.SendText(buf);

            //warn existing clan members
            foreach (CharData it in Database.CharList)
            {
                vch = it;
                if (vch.IsNPC())
                    continue;
                if (((PC)vch).Clan != null && ((PC)vch).Clan == clan)
                {
                    vch.SendText("&+RYour clan has been disbanded!&n\r\n");
                    ((PC)vch).Clan = null;
                    if (((PC)vch).Title.Length != 0)
                        ((PC)vch).Title = String.Empty;
                }
            }

            ch.SendText("Checking clan list.\r\n");
            foreach (Guild cit in Database.GuildList)
            {
                Guild vclan = cit;
                if (vclan == clan)
                {
                    ch.SendText("Clan found on list.\r\n");
                    Database.GuildList.Remove(cit);
                }
            }
            ch.SendText("Clan removed from list.\r\n");

            if (clan.Members != null)
            {
                clan.Members = null;
            }

            Guild.SaveGuildList();
            return;
        }

        public static void Songs(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string buf = String.Empty;
            int level;

            if (ch.IsNPC() || ch.IsClass(CharClass.Names.bard))
            {
                ch.SendText("&nYou do not need any stinking songs!\r\n");
                return;
            }

            buf += "&n&+rALL songs available for your class.&n\r\n";
            buf += "&+RLv      Song&n\r\n";

            for (level = 1; level < 56; level++)
            {
                bool pSong = true;

                foreach (KeyValuePair<String, Song> kvp in Database.SongList)
                {
                    if (kvp.Value._spellCircle[(int)ch._charClass.ClassNumber] != level)
                        continue;

                    if (pSong)
                    {
                        buf += "&+Y" + MUDString.PadInt(level, 2) + "&+y:&n";
                        pSong = false;
                    }
                    else
                    {
                        buf += "   ";
                    }
                    buf += "     ";
                    buf += "&n&+c" + MUDString.PadStr(kvp.Key, 21) + "  &+Y" + ((PC)ch).SongAptitude[kvp.Key] +
                        "&n (" + StringConversion.SpellSchoolString(kvp.Value._performanceType) + ")";
                    buf += "\r\n";
                }

            }

            ch.SendText(buf);
            return;
        }

        public static void Group(CharData ch, string[] str)
        {
            if( ch == null ) return;

            // Group with no arguments should show group staus.
            if (str.Length == 0)
            {
                ch.ShowGroup();
                return;
            }

            if (!MUDString.IsPrefixOf(str[0], "all"))
            {
                int added = 0; 
                foreach (CharData ivictim in ch._inRoom.People)
                {
                    if (ivictim == ch
                            || ivictim._flyLevel != ch._flyLevel
                            || ch.IsRacewar(ivictim))
                        continue;
                    if (((ivictim.IsNPC() && ivictim.HasActBit(MobTemplate.ACT_PET))
                            || (!ivictim.IsNPC() && ivictim.IsConsenting(ch)))
                            && ivictim._master == ch && !ivictim._groupLeader)
                    {
                        ch.AddGroupMember(ivictim);
                        ++added;
                    }
                }
                if (added < 1)
                {
                    ch.SendText("No new group members.\r\n");
                }
                return;
            }

            CharData victim = ch.GetCharRoom(str[0]);
            if (!victim)
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }
            if (ch == victim)
            {
                ch.RemoveFromGroup(victim);
                return;
            }
            if (ch.IsRacewar(victim) && !victim.IsNPC())
            {
                ch.SendText("You can't group with such slime!\r\n");
                return;
            }
            if (ch.IsSameGroup(victim))
            {
                if (ch._groupLeader == ch)
                {
                    ch.RemoveFromGroup(victim);
                }
                else
                {
                    ch.SendText("Only the leader of a group may kick someone out.\r\n");
                }
                return;
            }
            if (ch._groupLeader == null || ch._groupLeader == ch)
            {
                string buf;
                if (victim._groupLeader == null)
                {
                    if ((!victim.IsNPC() && !victim.IsConsenting(ch)) || (victim.IsNPC() && victim._master != ch))
                    {
                        buf = String.Format("{0} doesn't want to be in your group.\r\n", victim.ShowNameTo(ch, true));
                        ch.SendText(buf);
                    }
                    else
                    {
                        ch._groupLeader = ch;
                        ch.AddGroupMember(victim);
                    }
                }
                else
                {
                    buf = String.Format("{0} is in another group.\r\n", victim.ShowNameTo(ch, true));
                    ch.SendText(buf);
                }
            }
            else
            {
                ch.SendText("You must be the head of the group to add someone.\r\n");
            }
            return;
        }

        /// <summary>
        /// Command to disband yourself from a group, or to disband the whole group if you are the leader.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Disband(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData gch;
            CharData gchNext;

            if (ch != ch._groupLeader)
            {
                ch.SendText("You must be group leader to disband!\r\n");
                return;
            }
            for (gch = ch; gch; gch = gchNext)
            {
                gchNext = gch._nextInGroup;
                gch.SendText("&+GYour group has been disbanded.&n\r\n");
                gch._groupLeader = null;
                gch._nextInGroup = null;
            }
            return;
        }

        public static void Ungroup(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (str.Length == 0)
            {
                ch.SendText("Ungroup who?\r\n");
                return;
            }

            CharData victim = ch.GetCharWorld(str[0]);
            if (victim == null)
            {
                ch.SendText("They do not seem to exist!\r\n");
                return;
            }
            if (ch != victim._groupLeader && !ch.IsImmortal())
            {
                SocketConnection.Act("You are not $S group leader!", ch, null, victim, SocketConnection.MessageTarget.character);
                return;
            }
            if (!victim._groupLeader)
            {
                SocketConnection.Act("$N is not in a group!", ch, null, victim, SocketConnection.MessageTarget.character);
                victim._nextInGroup = null;
                return;
            }
            victim._groupLeader.RemoveFromGroup(victim);
            return;
        }

        /// <summary>
        /// Private communication between two characters.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Whisper(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (str.Length == 0)
            {
                ch.SendText("Whisper what to who?\r\n");
                return;
            }

            CharData victim = ch.GetCharRoom(str[0]);
            if (!victim)
            {
                ch.SendText("They're not here.\r\n");
                return;
            }

            if (str.Length < 2)
            {
                ch.SendText("Whisper what?\r\n");
                return;
            }

            if (!ch.CanSpeak())
            {
                return;
            }

            string text = String.Join(" ", str, 1, (str.Length - 1));
            text = DrunkSpeech.MakeDrunk(text, ch);

            SocketConnection.Act("$n&n whispers something to $N&n.", ch, null, victim, SocketConnection.MessageTarget.everyone_but_victim);
            string buf = "&n&+c$n&n&+c whispers '&+c" + text + "&n&+c'&n";
            SocketConnection.Act(buf, ch, null, victim, SocketConnection.MessageTarget.victim);
            buf = "&n&+cYou whisper &+c'" + text + "&n&+c' to $N&n";
            SocketConnection.Act(buf, ch, null, victim, SocketConnection.MessageTarget.character);

            // Chatterbot code.
            if (victim._chatterBot != null)
            {
                victim._chatterBot.CheckConversation(victim, ch, text);
            }

            return;
        }

        /// <summary>
        /// Sign language for Drow only.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Sign(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (str.Length == 0)
            {
                ch.SendText("Sign what to who?\r\n");
                return;
            }

            if (ch.GetRace() != Race.RACE_DROW && !ch.IsImmortal())
            {
                ch.SendText("You wiggle your fingers around.\r\n");
                SocketConnection.Act("$n wiggles $s fingers around, looking foolish.", ch, null, null, SocketConnection.MessageTarget.room);
                return;
            }

            string text = String.Join(" ", str, 1, (str.Length - 1));

            // We don't want to let them know they're drunk.
            SocketConnection.Act("You sign '&n$T&n'", ch, null, text, SocketConnection.MessageTarget.character);

            text = DrunkSpeech.MakeDrunk(text, ch);
            foreach (CharData och in ch._inRoom.People)
            {
                if (och == ch || och.IsNPC())
                    continue;

                string text2;
                if (och.IsImmortal() || och.GetOrigRace() == Race.RACE_DROW)
                {
                    text2 = String.Format("{0} signs '&n$T&n'", ch.ShowNameTo(och, true));
                }
                else
                {
                    text2 = String.Format("{0} wiggles {1} fingers around.", ch.ShowNameTo(och, true),
                              ch._sex == MobTemplate.Sex.male ? "his" :
                              ch._sex == MobTemplate.Sex.female ? "her" : "its");
                }

                SocketConnection.Act(text, och, null, text2, SocketConnection.MessageTarget.character);
            }

            //    ch.door_trigger( argument );

            return;

        }

        /// <summary>
        /// Cant language for thieves only.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Cant(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string buf;

            if (str.Length == 0)
            {
                ch.SendText("Cant what?\r\n");
                return;
            }

            if (!ch.IsClass(CharClass.Names.thief) && !ch.IsImmortal())
            {
                ch.SendText("You speak gibberish.\r\n");
                buf = String.Format("$n says, '{0}'\r\n", NounType.RandomSentence());
                SocketConnection.Act(buf, ch, null, null, SocketConnection.MessageTarget.room);
                return;
            }

            string text = String.Join(" ", str);

            // We don't want to let them know they're drunk.
            SocketConnection.Act("You cant '&n$T&n'", ch, null, text, SocketConnection.MessageTarget.character);

            text = DrunkSpeech.MakeDrunk(text, ch);
            string random = NounType.RandomSentence();

            foreach (CharData och in ch._inRoom.People)
            {
                if (och == ch || och.IsNPC())
                    continue;

                if (och.IsImmortal() || och.IsClass(CharClass.Names.thief))
                {
                    buf = String.Format("{0} cants '&n$T&n'", ch.ShowNameTo(och, true));
                }
                else
                {
                    buf = String.Format("{0} says, '{1}'\r\n", ch.ShowNameTo(och, true), random);
                }

                SocketConnection.Act(buf, och, null, SocketConnection.TranslateText(text, ch, och), SocketConnection.MessageTarget.character);
            }

            return;

        }

        /// <summary>
        /// Ask: Primarily used for quest files, but can be used in regular conversation too.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Ask(CharData ch, string[] str)
        {
            if( ch == null ) return;

            QuestTemplate quest;

            if (str.Length < 2)
            {
                ch.SendText("Ask who what?\r\n");
                return;
            }

            CharData victim = ch.GetCharRoom(str[0]);
            if (!victim)
            {
                ch.SendText("They're not here.\r\n");
                return;
            }

            if (ch.IsAffected( Affect.AFFECT_MUTE) || ch.HasInnate(Race.RACE_MUTE) || ch._inRoom.HasFlag(RoomTemplate.ROOM_SILENT))
            {
                ch.SendText("Your lips move but nothing escapes their bounds.\r\n");
                return;
            }

            string text = String.Join(" ", str, 1, (str.Length - 1));
            text = DrunkSpeech.MakeDrunk(text, ch);

            SocketConnection.Act("$n&n asks $N&n a question.", ch, null, victim, SocketConnection.MessageTarget.everyone_but_victim);
            string buf = String.Format("&n&+c$n&n&+c asks you '&+c{0}&n&+c'&n", text);
            SocketConnection.Act(buf, ch, null, victim, SocketConnection.MessageTarget.victim);
            buf = String.Format("&n&+cYou ask $N&n&+c '{0}&n&+c'&n", text);
            SocketConnection.Act(buf, ch, null, victim, SocketConnection.MessageTarget.character);

            // players can't have talk files -- go home!
            if (!victim.IsNPC())
                return;

            bool questfound = false;
            foreach (QuestTemplate it in QuestTemplate.QuestList)
            {
                quest = it;
                if (quest.Messages == null || (quest.IndexNumber != victim._mobIndexData.IndexNumber))
                    continue;
                foreach (TalkData message in quest.Messages)
                {
                    if (MUDString.NameContainedIn(text, message.Keywords))
                    {
                        ch.SendText("\r\n");
                        ch.SendText(message.Message);
                        questfound = true;
                    }
                }
            }

            // Only check chatterbot responses when there isn't a quest with the same keywords.
            if (!questfound && victim._chatterBot != null)
            {
                victim._chatterBot.CheckConversation(victim, ch, text);
            }
            return;
        }

        /// <summary>
        /// Command for players to talk to the gods.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Petition(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (str.Length == 0)
            {
                ch.SendText("Petition what?\r\n");
                return;
            }
            string text = String.Join(" ", str);
            string buf = String.Format("&+r{0} petitions '{1}'&n", ch._name, text);
            ImmortalChat.SendImmortalChat(ch, ImmortalChat.IMMTALK_PETITION, Limits.LEVEL_AVATAR, buf);
            buf = String.Format("&+rYou petition '{0}'&n\r\n", text);
            ch.SendText(buf);
            return;
        }

        /// <summary>
        /// Command for gods to respond to the players.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void PlayerTell(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (!ch.Authorized("ptell"))
            {
                ch.SendText("&+LYou cannot respond to &+Bpetitions&+L.&n\r\n");
                return;
            }

            if (str.Length < 2)
            {
                ch.SendText("Tell what to who?\r\n");
            }

            /*
            * Can tell to PC's anywhere, but NPC's only in same room.
            */
            CharData victim = ch.GetCharWorld(str[0]);
            if (!victim)
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (!victim._socket)
            {
                SocketConnection.Act("$N&n is &+Llinkdead&n.", ch, null, victim, SocketConnection.MessageTarget.character);
                return;
            }

            string text = String.Join(" ", str, 1, (str.Length - 1));
            text = DrunkSpeech.MakeDrunk(text, ch);

            SocketConnection.Act("&n&+rYou tell $N&n&+r '&+R$t&n&+r'&n", ch, text, victim, SocketConnection.MessageTarget.character);
            int position = victim._position;
            victim._position = Position.standing;
            SocketConnection.Act("&n&+r$n&n&+r responds to your petition with '&+R$t&n&+r'&n", ch, text, victim, SocketConnection.MessageTarget.victim);
            string buf = String.Format("&+r{0} responds to {1}'s petition with '&+R{2}&n&+r'&n", ch._name, victim._name, text);
            ImmortalChat.SendImmortalChat(ch, ImmortalChat.IMMTALK_PETITION, Limits.LEVEL_AVATAR, buf);
            victim._position = position;
            victim._replyTo = ch;

            if (victim.HasActBit(PC.PLAYER_AFK))
                SocketConnection.Act("Just so you know, $E is &+RAFK&n.", ch, null, victim, SocketConnection.MessageTarget.character);
            else if (victim.HasActBit(PC.PLAYER_BOTTING))
                SocketConnection.Act("Just so you know, $E is a &+YBOT&n", ch, null, victim, SocketConnection.MessageTarget.character);

            return;
        }

        public static void Consent(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData wch;

            if (ch.IsNPC())
            {
                ch.SendText("No consenting for mobs!");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Consent who?\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[0], "who"))
            {
                bool found = false;
                // Sadly inefficient code.
                foreach (CharData it in Database.CharList)
                {
                    if (ch.IsConsenting(it))
                    {
                        SocketConnection.Act("You continue consenting $N&n.", ch, null, it._name, SocketConnection.MessageTarget.character);
                        found = true;
                    }
                }
                if (!found)
                {
                    ch.SendText("You are not consenting anyone.\r\n");
                }
                foreach (CharData it in Database.CharList)
                {
                    wch = it;
                    if (wch.IsNPC())
                        continue;
                    if (wch.IsConsenting(ch))
                    {
                        SocketConnection.Act("$N&n is consenting you.", ch, null, wch, SocketConnection.MessageTarget.character);
                    }
                }
                return;
            }

            CharData victim = ch.GetCharWorld(str[0]);
            if (!victim || (ch.IsRacewar(victim)))
            {
                ch.SendText("That person doesn't exist.\r\n");
                return;
            }

            if (victim == ch)
            {
                ch.SendText("You no longer give consent to anyone.\r\n");
                foreach (CharData it in Database.CharList)
                {
                    if (ch.IsConsenting(it))
                    {
                        ch.StopConsenting(it);
                        SocketConnection.Act("$N&n stops consenting you.", it, null, ch, SocketConnection.MessageTarget.character);
                        SocketConnection.Act("You stop consenting $N&n.", ch, null, it, SocketConnection.MessageTarget.character);
                    }
                }
                return;
            }

            // Consenting a victim again turns off consenting.
            if (ch.IsConsenting(victim))
            {
                ch.StopConsenting(victim);
                SocketConnection.Act("$N&n stops consenting you.", victim, null, ch, SocketConnection.MessageTarget.character);
                SocketConnection.Act("You stop consenting $N&n.", ch, null, victim, SocketConnection.MessageTarget.character);
            }
            else
            {
                ch.StartConsenting(victim);
                SocketConnection.Act("You now give consent to $N&n.", ch, null, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n has given you $s consent.", ch, null, victim, SocketConnection.MessageTarget.victim);
            }
            return;
        }

        public static void Ignore(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch.IsNPC())
            {
                ch.SendText("No ignoring for mobs!");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Ignore who?\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[0], "who"))
            {
                bool found = false;
                // Sadly inefficient code.
                foreach (CharData it in Database.CharList)
                {
                    if (ch.IsIgnoring(it))
                    {
                        SocketConnection.Act("You are ignoring $N&n.", ch, null, it._name, SocketConnection.MessageTarget.character);
                        found = true;
                    }
                }
                if (!found)
                {
                    ch.SendText("You are not ignoring anyone.\r\n");
                }
                foreach (CharData it in Database.CharList)
                {
                    if (it.IsNPC())
                        continue;
                    if (it.IsIgnoring(ch))
                    {
                        SocketConnection.Act("$N&n is ignoring you.", ch, null, it, SocketConnection.MessageTarget.character);
                    }
                }
                return;
            }

            CharData victim = ch.GetCharWorld(str[0]);
            if (!victim || (ch.IsRacewar(victim)))
            {
                ch.SendText("That person doesn't exist.\r\n");
                return;
            }

            if (victim == ch)
            {
                ch.SendText("You no longer ignore anyone.\r\n");
                foreach (CharData it in Database.CharList)
                {
                    if (ch.IsIgnoring(it))
                    {
                        ch.StopIgnoring(it);
                        SocketConnection.Act("$N&n stops ignoring you.", it, null, ch, SocketConnection.MessageTarget.character);
                        SocketConnection.Act("You stop ignoring $N&n.", ch, null, it, SocketConnection.MessageTarget.character);
                    }
                }
                return;
            }

            // Ignoring someone you're already ignoring makes you stop ignoring them (toggle)
            if (ch.IsIgnoring(victim))
            {
                ch.StopIgnoring(victim);
                SocketConnection.Act("$N&n stops ignoring you.", victim, null, ch, SocketConnection.MessageTarget.character);
                SocketConnection.Act("You stop ignoring $N&n.", ch, null, victim, SocketConnection.MessageTarget.character);
            }
            else
            {
                ch.StartIgnoring(victim);
                SocketConnection.Act("You now ignore $N&n.", ch, null, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n is now ignoring you.", ch, null, victim, SocketConnection.MessageTarget.victim);
            }
            return;
        }

        public static void Guard(CharData ch, string[] str)
        {
            if( ch == null ) return;
            CharData wch;

            if (ch.IsNPC())
                return;

            if (!ch.HasSkill("guard"))
            {
                ch.SendText("Guard!? You can't even protect yourself!\r\n");
                return;
            }

            if (str.Length == 0)
            {
                if (!((PC)ch).Guarding)
                {
                    ch.SendText("Guard who?\r\n");
                    return;
                }
                if (!((PC)ch).Guarding)
                {
                    string buf = "You are guarding " + (((PC)ch).Guarding.IsNPC() ?
                                 ((PC)ch).Guarding._shortDescription : ((PC)ch).Guarding._name) + ".\r\n";
                    ch.SendText(buf);
                    return;
                }
            }

            if (!MUDString.StringsNotEqual(str[0], "who"))
            {
                if (!((PC)ch).Guarding)
                {
                    ch.SendText("You are not guarding anyone.\r\n");
                }
                else
                {
                    SocketConnection.Act("You are guarding $N&n.", ch, null, ((PC)ch).Guarding, SocketConnection.MessageTarget.character);
                }
                foreach (CharData it in Database.CharList)
                {
                    wch = it;
                    if (wch.IsNPC())
                    {
                        continue;
                    }
                    if (((PC)wch).Guarding && ((PC)wch).Guarding == ch)
                    {
                        SocketConnection.Act("$N&n is guarding you.", ch, null, wch, SocketConnection.MessageTarget.character);
                    }
                }
                return;
            }

            CharData victim = ch.GetCharRoom(str[0]);
            if (!victim)
            {
                ch.SendText("You don't see them here.\r\n");
                return;
            }

            if (victim == ch)
            {
                ch.SendText("You no longer guard anyone.\r\n");
                ((PC)ch).Guarding = null;
                return;
            }

            if (ch.IsClass(CharClass.Names.paladin) && victim.IsEvil())
            {
                ch.SendText("Their blackened soul is hardly worth the effort.\r\n");
                return;
            }

            if (((PC)ch).Guarding)
            {
                SocketConnection.Act("$N&n stops guarding you.", ((PC)ch).Guarding, null, ch, SocketConnection.MessageTarget.character);
                SocketConnection.Act("You stop guarding $N&n.", ch, null, ((PC)ch).Guarding, SocketConnection.MessageTarget.character);
            }

            ((PC)ch).Guarding = victim;
            SocketConnection.Act("You now guard $N&n.", ch, null, victim, SocketConnection.MessageTarget.character);
            SocketConnection.Act("$n&n is now guarding you.", ch, null, victim, SocketConnection.MessageTarget.victim);
            return;
        }

        public static void Shout(CharData ch, string[] str)
        {
            if( ch == null ) return;
            SocketConnection.SendToChannel(ch, String.Join(" ", str), TalkChannel.shout, "shout");
            ch.WaitState(12);
            return;
        }

        public static void Yell(CharData ch, string[] str)
        {
            if( ch == null ) return;
            SocketConnection.SendToChannel(ch, String.Join(" ", str), TalkChannel.shout, "shout");
            ch.WaitState(12);
            return;
        }

        public static void ImmortalTalk(CharData ch, string[] str)
        {
            if( ch == null ) return;
            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("imm"))
            {
                return;
            }

            SocketConnection.SendToChannel(ch, String.Join(" ", str), TalkChannel.immortal, "immtalk");
            return;
        }

        public static void ClanChat(CharData ch, string[] str)
        {
            if( ch == null ) return;
            CharData realChar = ch.GetChar();

            if (realChar.IsNPC() || !realChar.IsGuild())
            {
                ch.SendText("You aren't a &+Lclansman&n!\r\n");
                return;
            }

            SocketConnection.SendToChannel(ch, String.Join(" ", str), TalkChannel.guild, "clantalk");
            return;
        }

        public static void Say(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (str.Length == 0)
            {
                ch.SendText("Say what?\r\n");
                return;
            }

            if (!ch.CanSpeak())
            {
                ch.SendText("Your lips move but no sound comes out.\r\n");
                return;
            }

            string text = String.Join(" ", str);

            text = DrunkSpeech.MakeDrunk(text, ch);

            if (ch._inRoom != null)
            {
                foreach (CharData och in ch._inRoom.People)
                {
                    if (och == ch || och.IsNPC())
                        continue;

                    string buf;
                    if (ch.IsNPC() || (!ch.IsNPC() && (((PC)ch).Speaking == Race.Language.god ||
                        ((PC)ch).Speaking == Race.Language.unknown)))
                    {
                        buf = String.Format("{0} says '&n$T&n'", ch.ShowNameTo(och, true));
                    }
                    else
                    {
                        buf = String.Format("{0} says in {1} '&n$T&n'", ch.ShowNameTo(och, true),
                                  ch.IsNPC() ? Race.LanguageTable[(int)Race.RaceList[ch.GetOrigRace()].PrimaryLanguage]
                                  : Race.LanguageTable[(int)((PC)ch).Speaking]);
                    }
                    // Add foreign language filter.
                    SocketConnection.Act(buf, och, null, SocketConnection.TranslateText(text, ch, och), SocketConnection.MessageTarget.character);
                    // Chatterbot code.  May want to restrict chatterbots to tells, asks, and whispers.
                    if (och._chatterBot != null)
                    {
                        och._chatterBot.CheckConversation(och, ch, text);
                    }
                }
            }

            //    MOBtrigger = false;
            SocketConnection.Act("You say '&n$T&n'", ch, null, text, SocketConnection.MessageTarget.character);
            //    prog_speech_trigger( argument, ch );
            ch.DoorTrigger(text);
            return;
        }

        /// <summary>
        /// Direct telepathy-like communication with another individual.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Tell(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (!ch.CanSpeak())
            {
                ch.SendText("Your lips move but no sound comes out.\r\n");
                return;
            }

            if (str.Length < 2)
            {
                ch.SendText("Tell what to who?\r\n");
                return;
            }

            /*
            * PCs can receive a tell anywhere, but NPCs only can only hear them in the same room.
            *
            * get PC target first, if fails then get NPC
            */

            CharData victim = ch.GetCharWorld(str[0]);
            if (!victim || (victim.IsNPC() && victim._inRoom != ch._inRoom))
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (victim == ch)
            {
                ch.SendText("You listen to your own thoughts.  *cricket*  *cricket*\r\n");
                return;
            }

            if ((ch.IsRacewar(victim)) && (!ch.IsImmortal() && !victim.IsImmortal())
                    && (ch._inRoom != victim._inRoom))
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            /* Can tell to other side of racewar iff the opponent is in the same
            room or one of the people are Immortals. */
            if ((!ch.IsImmortal() && !victim.IsImmortal()) && (ch.IsRacewar(victim))
                    && (victim._inRoom != ch._inRoom))
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if ((!ch.IsNPC() && (ch.HasActBit(PC.PLAYER_SILENCE) || !ch.HasActBit(PC.PLAYER_TELL)
                || (!victim.IsNPC() && !victim.HasActBit(PC.PLAYER_TELL))))
                    || victim._inRoom.HasFlag(RoomTemplate.ROOM_SILENT))
            {
                ch.SendText("They can't hear you.\r\n");
                return;
            }

            if (!victim._socket && !victim.IsNPC())
            {
                SocketConnection.Act("$N&n is &+Llinkdead&n.", ch, null, victim, SocketConnection.MessageTarget.character);
                return;
            }

            if (!ch.IsImmortal() && !victim.IsAwake())
            {
                SocketConnection.Act("$E isn't paying attention.", ch, null, victim, SocketConnection.MessageTarget.character);
                return;
            }

            if (victim.IsIgnoring(ch))
            {
                SocketConnection.Act("$E is ignoring you.", ch, null, victim, SocketConnection.MessageTarget.character);
                return;
            }

            string text = String.Join(" ", str, 1, (str.Length - 1));
            text = DrunkSpeech.MakeDrunk(text, ch);

            int position = victim._position;
            victim._position = Position.standing;
            Race.Language lang = ch.IsNPC() ? Race.RaceList[ch.GetOrigRace()].PrimaryLanguage :
                                                                                       ((PC)ch).Speaking;
            if (lang == Race.Language.god || lang == Race.Language.unknown)
            {
                text = String.Format("&+WYou tell $N&+W '$t&+W'&n");
            }
            else
            {
                text = String.Format("&+WYou tell $N&+W in {0} '$t&+W'&n", Race.LanguageTable[(int)lang]);
            }

            SocketConnection.Act(text, ch, text, victim, SocketConnection.MessageTarget.character);
            if (lang == Race.Language.god || lang == Race.Language.unknown)
            {
                text = String.Format("&+W$n&+W tells you '$t&+W'&n");
            }
            else
            {
                text = String.Format("&+W$n&+W tells you in {0} '$t&+W'&n", Race.LanguageTable[(int)lang]);
            }
            SocketConnection.Act(text, ch, SocketConnection.TranslateText(text, ch, victim), victim, SocketConnection.MessageTarget.victim);
            victim._position = position;
            victim._replyTo = ch;

            if (victim.HasActBit(PC.PLAYER_AFK))
            {
                SocketConnection.Act("Just so you know, $E is &+RAFK&n.", ch, null, victim, SocketConnection.MessageTarget.character);
            }
            else if (victim.HasActBit(PC.PLAYER_BOTTING))
            {
                SocketConnection.Act("Just so you know, $E is a &+YBOT&n", ch, null, victim, SocketConnection.MessageTarget.character);
            }

            // players can't have talk files -- go home!  Quest stuff.
            if (!victim.IsNPC())
            {
                return;
            }

            bool questfound = false;
            foreach (QuestTemplate it in QuestTemplate.QuestList)
            {
                bool isquest = (ch.IsImmortal() && !MUDString.StringsNotEqual(text, "quest")) ? true : false;

                if (it.Messages == null || (it.IndexNumber != victim._mobIndexData.IndexNumber))
                    continue;
                foreach (TalkData message in it.Messages)
                {
                    if (MUDString.NameContainedIn(text, message.Keywords) || isquest)
                    {
                        ch.SendText("\r\n");
                        ch.SendText(message.Message);
                        questfound = true;
                    }
                }
            }
            // Chatterbot code.  Bots won't check if a quest matched (prevents multiple statements).
            if (!questfound && victim._chatterBot != null)
            {
                victim._chatterBot.CheckConversation(victim, ch, text);
            }

            return;
        }

        public static void Reply(CharData ch, string[] str)
        {
            if( ch == null ) return;
            if (!ch.CanSpeak())
            {
                ch.SendText("Your lips move but no sound comes out.\r\n");
                return;
            }

            CharData victim = ch._replyTo;
            if (!victim)
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if ((!ch.IsNPC() && (ch.HasActBit(PC.PLAYER_SILENCE)
                      || !ch.HasActBit(PC.PLAYER_TELL) || (!victim.IsNPC() &&
                     !victim.HasActBit(PC.PLAYER_TELL)))) || victim._inRoom.HasFlag(RoomTemplate.ROOM_SILENT))
            {
                ch.SendText("Your message didn't get through.\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Reply what?\r\n");
                return;
            }

            if (!victim._socket)
            {
                SocketConnection.Act("$N is &+Llinkdead&n.", ch, null, victim, SocketConnection.MessageTarget.character);
                return;
            }

            if (!ch.IsImmortal() && !victim.IsAwake())
            {
                SocketConnection.Act("$E can't hear you.", ch, null, victim, SocketConnection.MessageTarget.character);
                return;
            }

            if (victim.IsIgnoring(ch))
            {
                SocketConnection.Act("$E is ignoring you.", ch, null, victim, SocketConnection.MessageTarget.character);
                return;
            }

            string text = String.Join(" ", str);
            text = DrunkSpeech.MakeDrunk(text, ch);

            SocketConnection.Act("&+WYou tell $N&+W '$t&+W'&n", ch, text, victim, SocketConnection.MessageTarget.character);
            int position = victim._position;
            victim._position = Position.standing;
            SocketConnection.Act("&+W$n&+W tells you '$t&+W'&n", ch, SocketConnection.TranslateText(text, ch, victim), victim, SocketConnection.MessageTarget.victim);
            victim._position = position;
            victim._replyTo = ch;

            if (victim.HasActBit(PC.PLAYER_AFK))
            {
                SocketConnection.Act("Just so you know, $E is &+RAFK&n.", ch, null, victim, SocketConnection.MessageTarget.character);
            }
            else if (victim.HasActBit(PC.PLAYER_BOTTING))
            {
                SocketConnection.Act("Just so you know, $E is a &+YBOT&n", ch, null, victim, SocketConnection.MessageTarget.character);
            }

            return;
        }

        public static void Emote(CharData ch, string[] str)
        {
            if( ch == null ) return;
            if (!ch.IsNPC() && ch.HasActBit(PC.PLAYER_NO_EMOTE))
            {
                ch.SendText("You are unable to emote.\r\n");
                return;
            }

            if (ch._position == Position.fighting || ch._fighting)
            {
                ch.SendText("You can't emote in combat.\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Emote what?\r\n");
                return;
            }

            string text = String.Join(" ", str );
            if (text[(text.Length - 1)] != '.')
            {
                text += ".";
            }

            foreach (CharData och in ch._inRoom.People)
            {
                if (och == ch)
                    continue;

                SocketConnection.Act("$n $t", ch, SocketConnection.TranslateText(text, ch, och), och, SocketConnection.MessageTarget.victim);
            }
            //    MOBtrigger = false;
            SocketConnection.Act("$n $T", ch, null, text, SocketConnection.MessageTarget.character);
            return;
        }

        public static void CrashBug(CharData ch, string[] str)
        {
            if( ch == null ) return;
            if (str.Length == 0)
            {
                ch.SendText("Report what crash bug?\r\n");
                return;
            }

            string text = String.Join(" ", str);

            Issue issue = new Issue();
            issue.IssueDetail = new IssueEntry(ch._name, text);
            issue.OpenedByImmortal = ch.IsImmortal();
            issue.IssueType = Issue.Type.bug;
            issue.IssuePriority = Issue.Priority.highest;
            if (ch._inRoom != null)
            {
                issue.RoomIndexNumber = ch._inRoom.IndexNumber;
            }
            Database.IssueList.Add(issue);
            ImmortalChat.SendImmortalChat(null, ImmortalChat.IMMTALK_DEBUG, 0, String.Format("New CRASH BUG, issue # {0} created by {1}.  Text is:\n{2}",
                issue.IssueNumber, ch._name, text));
            Issue.Save();
            ch.SendText("Crash bug report recorded.  Thank you.\r\n");
            return;
        }

        /// <summary>
        /// Command to report a bug.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Bug(CharData ch, string[] str)
        {
            if( ch == null ) return;
            if (str.Length == 0)
            {
                ch.SendText("Report what bug?\r\n");
                return;
            }

            string text = String.Join(" ", str);

            Issue issue = new Issue();
            issue.IssueDetail = new IssueEntry(ch._name, text);
            issue.OpenedByImmortal = ch.IsImmortal();
            issue.IssueType = Issue.Type.bug;
            issue.IssuePriority = Issue.Priority.none;
            if (ch._inRoom != null)
            {
                issue.RoomIndexNumber = ch._inRoom.IndexNumber;
            }
            Database.IssueList.Add(issue);
            ImmortalChat.SendImmortalChat(null, ImmortalChat.IMMTALK_DEBUG, 0, String.Format("New bug, issue # {0} created by {1}.  Text is:\n{2}",
                issue.IssueNumber, ch._name, text));
            Issue.Save();
            ch.SendText("Bug report recorded.  Thank you.\r\n");
            return;
        }

        /// <summary>
        /// Command to suggest an idea.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Idea(CharData ch, string[] str)
        {
            if( ch == null ) return;
            if (str.Length == 0)
            {
                ch.SendText("What idea?  The Implementors look at you quizzically.\r\n");
                return;
            }

            string text = String.Join(" ", str);

            Issue issue = new Issue();
            issue.IssueDetail = new IssueEntry(ch._name, text);
            issue.OpenedByImmortal = ch.IsImmortal();
            issue.IssueType = Issue.Type.idea;
            issue.IssuePriority = Issue.Priority.lowest;
            if (ch._inRoom != null)
            {
                issue.RoomIndexNumber = ch._inRoom.IndexNumber;
            }
            Database.IssueList.Add(issue);
            ImmortalChat.SendImmortalChat(null, ImmortalChat.IMMTALK_DEBUG, 0, String.Format("New idea, issue # {0} created by {1}.  Text is:\n{2}",
                issue.IssueNumber, ch._name, text));
            Issue.Save();
            ch.SendText("Idea recorded.  Thank you.\r\n");
            return;
        }

        public static void RequestHelp(CharData ch, string[] str)
        {
            if( ch == null ) return;
            if (str.Length == 0)
            {
                ch.SendText("What would you like to request a help entry for?\r\n");
                return;
            }

            string text = String.Join(" ", str);

            Issue issue = new Issue();
            issue.IssueDetail = new IssueEntry(ch._name, "Help Request: " + text);
            issue.OpenedByImmortal = ch.IsImmortal();
            issue.IssueType = Issue.Type.helpentryrequest;
            issue.IssuePriority = Issue.Priority.lowest;
            if (ch._inRoom != null)
            {
                issue.RoomIndexNumber = ch._inRoom.IndexNumber;
            }
            Database.IssueList.Add(issue);
            ImmortalChat.SendImmortalChat(null, ImmortalChat.IMMTALK_DEBUG, 0, String.Format("New help entry request, issue # {0} created by {1}.  Text is:\n{2}",
                issue.IssueNumber, ch._name, text));
            Issue.Save();
            ch.SendText("Help entry request recorded.  Thank you.\r\n");
            return;
        }

        public static void Typo(CharData ch, string[] str)
        {
            if( ch == null ) return;
            if (str.Length == 0)
            {
                ch.SendText("There was a Typo in your Typo report.\r\n");
                return;
            }

            string text = String.Join(" ", str);

            Issue issue = new Issue();
            issue.IssueDetail = new IssueEntry(ch._name, text);
            issue.OpenedByImmortal = ch.IsImmortal();
            issue.IssueType = Issue.Type.typo;
            issue.IssuePriority = Issue.Priority.low;
            if (ch._inRoom != null)
            {
                issue.RoomIndexNumber = ch._inRoom.IndexNumber;
            }
            Database.IssueList.Add(issue);
            ImmortalChat.SendImmortalChat(null, ImmortalChat.IMMTALK_DEBUG, 0, String.Format("New Typo, issue # {0} created by {1}.  Text is:\n{2}",
                issue.IssueNumber, ch._name, text));
            Issue.Save();
            ch.SendText("Yore typo report haz been rekorded.  Thank yew.\r\n");
            return;
        }

        // This code is basically a hack, and I'm adding a boatload of log
        // messages until I am satisfied that this code works and is stable.
        // When messing with code like this, it is easy to have players that
        // don't enter or leave the game completely, causing ghost images,
        // player duplicates, weird dangling pointers, etc., so we have to
        // be especially careful.  If anyone happens upon this and has a
        // suggestion for how to handle anything better than I have it will
        // be greatly appreciated.
        public static void Rent(CharData ch, string[] str)
        {
            if( ch == null ) return;
            Room room = null;
            CharData wch;

            if (ch.IsNPC())
                return;

            if (!ch._inRoom || !ch._inRoom.HasFlag(Room.ROOM_INN))
            {
                ch.SendText("You must be within an inn to rent.\r\n");
                return;
            }

            if (ch._position == Position.fighting || ch._fighting)
            {
                ch.SendText("No way! You are fighting.\r\n");
                return;
            }

            if (ch._position < Position.stunned)
            {
                ch.SendText("You're not &+RD&n&+rE&+RA&n&+rD&n yet.\r\n");
                return;
            }

            ch.SendText("The innkeeper grabs a &+Lkey&n from the &n&+yrack&n, and shows you to your room.\r\n\r\n");
            SocketConnection.Act("$n&n has left the realm.", ch, null, null, SocketConnection.MessageTarget.room);
            Log.Trace(String.Format("{0} has rented.", ch._name));

            ImmortalChat.SendImmortalChat(ch, ImmortalChat.IMMTALK_LOGINS, ch.GetTrust(), String.Format("{0} has rented.", ch._name));

            /*
            * After CharData.ExtractChar the ch is no longer valid
            * that is why we aren't extracting the character but rather
            * sending them to our version of the "menu".
            */

            // I know we checked for position fighting, but I'm paranoid...
            if (ch._fighting != null)
            {
                Combat.StopFighting(ch, true);
            }

            ch.DieFollower(ch._name);

            // I can't see any reason why ch would not have an .in_room, but that
            // may just be shortsighted of me - Xangis
            if (ch._inRoom)
            {
                room = ch._inRoom;
            }

            ch.RemoveFromRoom();
            ;
            if (room)
                ch._inRoom = room;

            // Put them in the correct body
            if (ch._socket && ch._socket.Original)
            {
                CommandType.Interpret(ch, "return");
            }

            foreach (CharData it in Database.CharList)
            {
                wch = it;
                if (wch._replyTo == ch)
                {
                    wch._replyTo = null;
                }
            }

            ch.RemoveActBit(PC.PLAYER_CAMPING);
            ((PC)ch).LastRentLocation = ch._inRoom.IndexNumber;
            CharData.SavePlayer(ch);

            // Remove them from the character list.
            for( int i = Database.CharList.Count -1; i >= 0; --i )
            {
                if (Database.CharList[i] == ch)
                {
                    Database.CharList.RemoveAt(i);
                }
            }

            // ConnectionState.menu is when they enter
            // the game... this shows menu
            // before they enter the game
            ch._socket.ShowScreen(Screen.MainMenuScreen);
            ch._socket._connectionState = SocketConnection.ConnectionState.menu;

            return;
        }

        // This code is basically a hack, and I'm adding a boatload of log
        // messages until I am satisfied that this code works and is stable.
        // When messing with code like this, it is easy to have players that
        // don't enter or leave the game completely, causing ghost images,
        // player duplicates, weird dangling pointers, etc., so we have to
        // be especially careful.  If anyone happens upon this and has a
        // suggestion for how to handle anything better than I have it will
        // be greatly appreciated. - Xangis
        public static void Quit(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch.IsNPC())
                return;

            // If they're not an immortal, assume they want to rent or camp and be smart
            // enough to try renting first.
            if (!ch.IsImmortal())
            {
                if (ch._inRoom != null && ch._inRoom.HasFlag(RoomTemplate.ROOM_INN))
                {
                    Rent(ch, str);
                    return;
                }
                Camp(ch, str);
                return;
            }

            if (ch._position == Position.fighting || ch._fighting)
            {
                if (ch.HasActBit(PC.PLAYER_CAMPING))
                {
                    ch.SendText("You're not gifted enough to make camp and fight at the same time.\r\n");
                    ch.RemoveActBit(PC.PLAYER_CAMPING);
                    return;
                }
                ch.SendText("No way! You are fighting.\r\n");
                return;
            }

            if (ch._position < Position.stunned)
            {
                if (MUDMath.NumberRange(1, 2) == 1)
                {
                    ch.SendText("You're not &+RD&n&+rE&+RA&n&+rD&n yet.\r\n");
                    return;
                }
                ch.SendText("Just lie still and finish &+RBle&+reding&n!\r\n");
                return;
            }

            SocketConnection.Quit(ch);
        }

        public static void North(CharData ch, string[] str)
        {
            if (ch == null)
                return;

            ch.Move(Exit.DIRECTION_NORTH);
            return;
        }

        public static void NorthEast(CharData ch, string[] str)
        {
            if (ch == null)
                return;

            ch.Move(Exit.DIRECTION_NORTHEAST);
            return;
        }

        public static void NorthWest(CharData ch, string[] str)
        {
            if (ch == null)
                return;

            ch.Move(Exit.DIRECTION_NORTHWEST);
            return;
        }

        public static void East(CharData ch, string[] str)
        {
            if (ch == null)
                return;

            ch.Move(Exit.DIRECTION_EAST);
            return;
        }

        public static void South(CharData ch, string[] str)
        {
            if (ch == null)
                return;

            ch.Move(Exit.DIRECTION_SOUTH);
            return;
        }

        public static void SouthEast(CharData ch, string[] str)
        {
            if (ch == null)
                return;

            ch.Move(Exit.DIRECTION_SOUTHEAST);
            return;
        }

        public static void SouthWest(CharData ch, string[] str)
        {
            if (ch == null)
                return;

            ch.Move(Exit.DIRECTION_SOUTHWEST);
            return;
        }

        public static void West(CharData ch, string[] str)
        {
            if (ch == null)
                return;

            ch.Move(Exit.DIRECTION_WEST);
            return;
        }

        public static void Up(CharData ch, string[] str)
        {
            if (ch == null)
                return;

            ch.Move(Exit.DIRECTION_UP);
            return;
        }

        public static void Down(CharData ch, string[] str)
        {
            if (ch == null)
                return;

            ch.Move(Exit.DIRECTION_DOWN);
            return;
        }

        /// <summary>
        /// Command to open a door or a container.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Open(CharData ch, string[] str)
        {
            if( ch == null ) return;
            Object obj;
            int door;

            if (str.Length == 0 )
            {
                ch.SendText("What do you wish to open?\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[0], "door") && str.Length > 1 && str[1].Length > 0)
                door = Movement.FindDoor(ch, str[1]);
            else
                door = Movement.FindDoor(ch, str[0]);

            if (door >= 0 && !(ch._level < Limits.LEVEL_AVATAR
                && ch._inRoom.ExitData[door] && ch._inRoom.ExitData[door].ExitFlags != 0
                && ch._inRoom.ExitData[door].HasFlag(Exit.ExitFlag.secret)))
            {
                /* 'open door' */
                Exit pexitRev;
                Room toRoom;

                if (ch._flyLevel > 0)
                {
                    ch.SendText("You see no doors this high up!\r\n");
                    return;
                }
                if (ch._position == Position.fighting)
                {
                    ch.SendText("Stop fighting first!\r\n");
                    return;
                }
                Exit pexit = ch._inRoom.ExitData[door];
                if (!pexit.HasFlag(Exit.ExitFlag.closed))
                {
                    ch.SendText("It's already open.\r\n");
                    return;
                }
                if (pexit.HasFlag(Exit.ExitFlag.locked))
                {
                    ch.SendText("It's locked.\r\n");
                    return;
                }

                pexit.RemoveFlag(Exit.ExitFlag.closed);
                SocketConnection.Act("$n&n opens the $d.", ch, null, pexit.Keyword, SocketConnection.MessageTarget.room);
                ch.SendText("Done.\r\n");

                /* open the other side */
                if ((toRoom = Room.GetRoom(pexit.IndexNumber))
                        && (pexitRev = toRoom.ExitData[Exit.ReverseDirection[door]])
                        && pexitRev.TargetRoom == ch._inRoom)
                {
                    pexitRev.RemoveFlag(Exit.ExitFlag.closed);
                    pexitRev.RemoveFlag(Exit.ExitFlag.secret);
                    foreach (CharData roomChar in ch._inRoom.People)
                    {
                        SocketConnection.Act("The $d opens.", roomChar, null, pexitRev.Keyword, SocketConnection.MessageTarget.character);
                    }
                }

                return;
            }

            if ((obj = ch.GetObjHere(str[0])))
            {
                /* 'open portal' */
                if (obj.ItemType == ObjTemplate.ObjectType.portal)
                {
                    if (!Macros.IsSet(obj.Values[3], ObjTemplate.PORTAL_CLOSEABLE))
                    {
                        ch.SendText("You can't do that.\r\n");
                        return;
                    }
                    if (!Macros.IsSet(obj.Values[3], ObjTemplate.PORTAL_CLOSED))
                    {
                        ch.SendText("It's already open.\r\n");
                        return;
                    }
                    if (Macros.IsSet(obj.Values[3], ObjTemplate.PORTAL_LOCKED))
                    {
                        ch.SendText("It's locked.\r\n");
                        return;
                    }

                    Macros.RemoveBit(ref obj.Values[3], ObjTemplate.PORTAL_CLOSED);
                    ch.SendText("Done.\r\n");
                    SocketConnection.Act("$n&n opens $p&n.", ch, obj, null, SocketConnection.MessageTarget.room);
                    return;
                }

                /* 'open object' */
                if (obj.ItemType != ObjTemplate.ObjectType.container &&
                        obj.ItemType != ObjTemplate.ObjectType.quiver)
                {
                    ch.SendText("That's not something that can be opened.\r\n");
                    return;
                }
                if (!Macros.IsSet(obj.Values[1], ObjTemplate.CONTAINER_CLOSED.Vector))
                {
                    ch.SendText("It's already open.\r\n");
                    return;
                }
                if (!Macros.IsSet(obj.Values[1], ObjTemplate.CONTAINER_CLOSEABLE.Vector))
                {
                    ch.SendText("You can't do that.\r\n");
                    return;
                }
                if (Macros.IsSet(obj.Values[1], ObjTemplate.CONTAINER_LOCKED.Vector))
                {
                    ch.SendText("It's locked.\r\n");
                    return;
                }

                Macros.RemoveBit(ref obj.Values[1], ObjTemplate.CONTAINER_CLOSED.Vector);
                ch.SendText("Done.\r\n");
                SocketConnection.Act("$n&n opens $p&n.", ch, obj, null, SocketConnection.MessageTarget.room);
                if (obj.Trap != null && obj.Trap.CheckTrigger( Trap.TriggerType.open))
                {
                    ch.SetOffTrap(obj);
                    if (ch._position == Position.dead)
                        return;
                }
                return;
            }

            ch.SendText("Open what?\r\n");
            return;
        }

        public static void Close(CharData ch, string[] str)
        {
            if( ch == null ) return;
            string arg1 = String.Empty;
            int door;

            if (str.Length == 0)
            {
                ch.SendText("What do you wish to close?\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[0], "door") && arg1.Length > 0)
            {
                door = Movement.FindDoor(ch, arg1);
            }
            else
            {
                door = Movement.FindDoor(ch, str[0]);
            }

            if (door >= 0)
            {
                /* 'close door' */
                Exit pexitRev;
                Room toRoom;

                if (ch._flyLevel > 0)
                {
                    ch.SendText("You can't reach that from up here!\r\n");
                    return;
                }
                if (ch._position == Position.fighting)
                {
                    ch.SendText("You can't close doors while fighting!.\r\n");
                    return;
                }

                Exit pexit = ch._inRoom.ExitData[door];
                if (pexit.HasFlag(Exit.ExitFlag.closed))
                {
                    ch.SendText("It's already closed.\r\n");
                    return;
                }

                if (pexit.HasFlag(Exit.ExitFlag.bashed))
                {
                    SocketConnection.Act("The $d has been bashed open and cannot be closed.",
                         ch, null, pexit.Keyword, SocketConnection.MessageTarget.character);
                    return;
                }

                pexit.AddFlag(Exit.ExitFlag.closed);
                SocketConnection.Act("$n&n closes the $d.", ch, null, pexit.Keyword, SocketConnection.MessageTarget.room);
                ch.SendText("Done.\r\n");

                /* close the other side */
                if ((toRoom = Room.GetRoom(pexit.IndexNumber)) && (pexitRev = toRoom.ExitData[Exit.ReverseDirection[door]])
                        && pexitRev.TargetRoom == ch._inRoom)
                {
                    pexitRev.AddFlag(Exit.ExitFlag.closed);
                    foreach (CharData roomChar in ch._inRoom.People)
                    {
                        SocketConnection.Act("The $d closes.", roomChar, null, pexitRev.Keyword, SocketConnection.MessageTarget.character);
                    }
                }

                return;
            }

            Object obj = ch.GetObjHere(str[0]);
            if (obj)
            {
                /* 'close portal' */
                if (obj.ItemType == ObjTemplate.ObjectType.portal)
                {
                    if (Macros.IsSet(obj.Values[3], ObjTemplate.PORTAL_CLOSED))
                    {
                        ch.SendText("It's already closed.\r\n");
                        return;
                    }
                    if (!Macros.IsSet(obj.Values[3], ObjTemplate.PORTAL_CLOSEABLE))
                    {
                        ch.SendText("You can't do that.\r\n");
                        return;
                    }

                    Macros.SetBit(ref obj.Values[3], ObjTemplate.PORTAL_CLOSED);
                    ch.SendText("Done.\r\n");
                    SocketConnection.Act("$n&n closes $p&n.", ch, obj, null, SocketConnection.MessageTarget.room);
                    return;
                }

                /* 'close object' */
                if (obj.ItemType != ObjTemplate.ObjectType.container)
                {
                    ch.SendText("That's not something that can be closed.\r\n");
                    return;
                }
                if (Macros.IsSet(obj.Values[1], ObjTemplate.CONTAINER_CLOSED.Vector))
                {
                    ch.SendText("It's already closed.\r\n");
                    return;
                }
                if (!Macros.IsSet(obj.Values[1], ObjTemplate.CONTAINER_CLOSEABLE.Vector))
                {
                    ch.SendText("You can't do that.\r\n");
                    return;
                }

                Macros.SetBit(ref obj.Values[1], ObjTemplate.CONTAINER_CLOSED.Vector);
                ch.SendText("Done.\r\n");
                SocketConnection.Act("$n&n closes $p&n.", ch, obj, null, SocketConnection.MessageTarget.room);
                return;
            }

            return;
        }

        public static void Lock(CharData ch, string[] str)
        {
            if( ch == null ) return;
            int door;

            if (str.Length == 0)
            {
                ch.SendText("What do you wish to lock?\r\n");
                return;
            }

            if ((door = Movement.FindDoor(ch, str[0])) >= 0)
            {
                /* 'lock door' */
                Exit reverseExit;
                Room toRoom;

                Exit pexit = ch._inRoom.ExitData[door];
                if (!pexit.HasFlag(Exit.ExitFlag.closed))
                {
                    ch.SendText("It's not closed.\r\n");
                    return;
                }
                if (pexit.Key < 0 && !ch.IsImmortal())
                {
                    ch.SendText("It can't be locked.\r\n");
                    return;
                }
                if (!ch.GetKey(pexit.Key) && !ch.IsImmortal())
                {
                    ch.SendText("You lack the key.\r\n");
                    return;
                }
                if (pexit.HasFlag(Exit.ExitFlag.locked))
                {
                    ch.SendText("It's already locked.\r\n");
                    return;
                }

                pexit.AddFlag(Exit.ExitFlag.locked);
                ch.SendText("*Click*\r\n");
                SocketConnection.Act("$n&n locks the $d.", ch, null, pexit.Keyword, SocketConnection.MessageTarget.room);

                /* lock the other side */
                if ((toRoom = Room.GetRoom(pexit.IndexNumber)) && (reverseExit = toRoom.ExitData[Exit.ReverseDirection[door]])
                        && reverseExit.TargetRoom == ch._inRoom)
                {
                    reverseExit.AddFlag(Exit.ExitFlag.locked);
                }

                return;
            }

            Object obj = ch.GetObjHere(str[0]);
            if (obj)
            {
                /* 'lock portal' */
                if (obj.ItemType == ObjTemplate.ObjectType.portal)
                {
                    if (!Macros.IsSet(obj.Values[3], ObjTemplate.PORTAL_CLOSED))
                    {
                        ch.SendText("It's not closed.\r\n");
                        return;
                    }
                    if (obj.Values[4] < 0)
                    {
                        ch.SendText("It can't be locked.\r\n");
                        return;
                    }
                    if (!ch.GetKey(obj.Values[4]))
                    {
                        ch.SendText("You lack the key.\r\n");
                        return;
                    }
                    if (Macros.IsSet(obj.Values[3], ObjTemplate.PORTAL_LOCKED))
                    {
                        ch.SendText("It's already locked.\r\n");
                        return;
                    }

                    Macros.SetBit(ref obj.Values[3], ObjTemplate.PORTAL_LOCKED);
                    ch.SendText("*Click*\r\n");
                    SocketConnection.Act("$n&n locks $p&n.", ch, obj, null, SocketConnection.MessageTarget.room);
                    return;
                }

                /* 'lock object' */
                if (obj.ItemType != ObjTemplate.ObjectType.container)
                {
                    ch.SendText("That's not a container.\r\n");
                    return;
                }
                if (!Macros.IsSet(obj.Values[1], ObjTemplate.CONTAINER_CLOSED.Vector))
                {
                    ch.SendText("It's not closed.\r\n");
                    return;
                }
                if (obj.Values[2] < 0 && !ch.IsImmortal())
                {
                    ch.SendText("It can't be locked.\r\n");
                    return;
                }
                if (!ch.GetKey(obj.Values[2]) && !ch.IsImmortal())
                {
                    ch.SendText("You lack the key.\r\n");
                    return;
                }
                if (Macros.IsSet(obj.Values[1], ObjTemplate.CONTAINER_LOCKED.Vector))
                {
                    ch.SendText("It's already locked.\r\n");
                    return;
                }

                Macros.SetBit(ref obj.Values[1], ObjTemplate.CONTAINER_LOCKED.Vector);
                ch.SendText("*Click*\r\n");
                SocketConnection.Act("$n&n locks $p&n.", ch, obj, null, SocketConnection.MessageTarget.room);
                return;
            }

            return;
        }

        public static void Unlock(CharData ch, string[] str)
        {
            if( ch == null ) return;
            string arg1 = String.Empty;
            int door;

            if (str.Length == 0)
            {
                ch.SendText("What do you wish to unlock?\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[0], "door") && arg1.Length != 0)
                door = Movement.FindDoor(ch, arg1);
            else
                door = Movement.FindDoor(ch, str[0]);

            if (door >= 0 && !(ch._level < Limits.LEVEL_AVATAR
                                 && ch._inRoom.ExitData[door] && ch._inRoom.ExitData[door].ExitFlags != 0
                                 && ch._inRoom.ExitData[door].HasFlag(Exit.ExitFlag.secret)))
            {
                /* 'unlock door' */
                Exit pexitRev;
                Room toRoom;

                Exit pexit = ch._inRoom.ExitData[door];
                if (!pexit.HasFlag(Exit.ExitFlag.closed))
                {
                    ch.SendText("It's not closed.\r\n");
                    return;
                }
                if (pexit.Key < 0)
                {
                    ch.SendText("It can't be unlocked.\r\n");
                    return;
                }
                if (!ch.GetKey(pexit.Key) && !ch.IsImmortal())
                {
                    ch.SendText("You lack the key.\r\n");
                    return;
                }
                if (!pexit.HasFlag(Exit.ExitFlag.locked))
                {
                    ch.SendText("It's already unlocked.\r\n");
                    return;
                }

                pexit.RemoveFlag(Exit.ExitFlag.locked);
                ch.SendText("*Click*\r\n");
                SocketConnection.Act("$n&n unlocks the $d.", ch, null, pexit.Keyword, SocketConnection.MessageTarget.room);

                if (pexit.HasFlag(Exit.ExitFlag.destroys_key))
                {
                    (ch.GetKey(pexit.Key)).RemoveFromWorld();
                    SocketConnection.Act("The $d eats the key!", ch, null, pexit.Keyword, SocketConnection.MessageTarget.character);
                    SocketConnection.Act("The $d eats the key!", ch, null, pexit.Keyword, SocketConnection.MessageTarget.room);
                }

                /* unlock the other side */
                if ((toRoom = Room.GetRoom(pexit.IndexNumber))
                        && (pexitRev = toRoom.ExitData[Exit.ReverseDirection[door]])
                        && pexitRev.TargetRoom == ch._inRoom)
                {
                    pexitRev.RemoveFlag(Exit.ExitFlag.locked);
                }

                return;
            }

            Object obj = ch.GetObjHere(str[0]);
            if (obj)
            {
                /* 'unlock portal' */
                if (obj.ItemType == ObjTemplate.ObjectType.portal)
                {
                    if (!Macros.IsSet(obj.Values[1], ObjTemplate.PORTAL_CLOSED))
                    {
                        ch.SendText("It's not closed.\r\n");
                        return;
                    }
                    if (obj.Values[4] < 0)
                    {
                        ch.SendText("It can't be unlocked.\r\n");
                        return;
                    }
                    if (!ch.GetKey(obj.Values[4]))
                    {
                        ch.SendText("You lack the key.\r\n");
                        return;
                    }
                    if (!Macros.IsSet(obj.Values[3], ObjTemplate.PORTAL_LOCKED))
                    {
                        ch.SendText("It's already unlocked.\r\n");
                        return;
                    }

                    Macros.RemoveBit(ref obj.Values[3], ObjTemplate.PORTAL_LOCKED);
                    ch.SendText("*Click*\r\n");
                    SocketConnection.Act("$n&n unlocks $p&n.", ch, obj, null, SocketConnection.MessageTarget.room);
                    return;
                }

                /* 'unlock object' */
                if (obj.ItemType != ObjTemplate.ObjectType.container)
                {
                    ch.SendText("That's not a container.\r\n");
                    return;
                }
                if (!Macros.IsSet(obj.Values[1], ObjTemplate.CONTAINER_CLOSED.Vector))
                {
                    ch.SendText("It's not closed.\r\n");
                    return;
                }
                if (obj.Values[2] < 0)
                {
                    ch.SendText("It can't be unlocked.\r\n");
                    return;
                }
                if (!ch.GetKey(obj.Values[2]))
                {
                    ch.SendText("You lack the key.\r\n");
                    return;
                }
                if (!Macros.IsSet(obj.Values[1], ObjTemplate.CONTAINER_LOCKED.Vector))
                {
                    ch.SendText("It's already unlocked.\r\n");
                    return;
                }

                Macros.RemoveBit(ref obj.Values[1], ObjTemplate.CONTAINER_LOCKED.Vector);
                ch.SendText("*Click*\r\n");
                SocketConnection.Act("$n&n unlocks $p&n.", ch, obj, null, SocketConnection.MessageTarget.room);
                return;
            }

            return;
        }

        public static void Pick(CharData ch, string[] str)
        {
            if( ch == null ) return;
            Object obj;
            int door;

            if (str.Length == 0)
            {
                ch.SendText("Pick what, your nose?\r\n");
                return;
            }

            if (ch._riding)
            {
                ch.SendText("You can't do that while mounted.\r\n");
                return;
            }

            ch.WaitState(Skill.SkillList["pick lock"].Delay);

            // Look for guards.
            foreach (CharData gch in ch._inRoom.People)
            {
                if (gch.IsNPC() && gch.IsAwake() && ch._level + 5 < gch._level)
                {
                    SocketConnection.Act("$N&n is standing too close to the lock.", ch, null, gch, SocketConnection.MessageTarget.character);
                    return;
                }
            }

            // Check skill roll for player, make sure mob isn't charmed.
            if ((!ch.IsNPC() && MUDMath.NumberPercent() > ((PC)ch).SkillAptitude["pick lock"])
                    || (ch.IsNPC() && ch.IsAffected( Affect.AFFECT_CHARM)))
            {
                ch.PracticeSkill("pick lock");
                ch.SendText("You failed.\r\n");
                return;
            }

            if ((door = Movement.FindDoor(ch, str[0])) >= 0)
            {
                /* 'pick door' */
                Exit pexitRev;
                Room toRoom;

                Exit exit = ch._inRoom.ExitData[door];
                if (!exit.HasFlag(Exit.ExitFlag.closed))
                {
                    ch.SendText("It's not closed.\r\n");
                    return;
                }
                if (exit.Key < 0)
                {
                    ch.SendText("It can't be picked.\r\n");
                    return;
                }
                if (!exit.HasFlag(Exit.ExitFlag.locked))
                {
                    ch.SendText("It's already unlocked.\r\n");
                    return;
                }
                if (exit.HasFlag(Exit.ExitFlag.pickproof))
                {
                    ch.SendText("You failed.\r\n");
                    return;
                }

                exit.RemoveFlag(Exit.ExitFlag.locked);
                ch.SendText("*Click*\r\n");
                SocketConnection.Act("$n&n picks the $d.", ch, null, exit.Keyword, SocketConnection.MessageTarget.room);

                /* pick the other side */
                if ((toRoom = Room.GetRoom(exit.IndexNumber)) && (pexitRev = toRoom.ExitData[Exit.ReverseDirection[door]])
                        && pexitRev.TargetRoom == ch._inRoom)
                {
                    pexitRev.RemoveFlag(Exit.ExitFlag.locked);
                }

                return;
            }

            if ((obj = ch.GetObjHere(str[0])))
            {
                /* 'pick portal' */
                if (obj.ItemType == ObjTemplate.ObjectType.portal)
                {
                    if (!Macros.IsSet(obj.Values[3], ObjTemplate.PORTAL_CLOSED))
                    {
                        ch.SendText("It's not closed.\r\n");
                        return;
                    }
                    if (obj.Values[4] < 0)
                    {
                        ch.SendText("It can't be unlocked.\r\n");
                        return;
                    }
                    if (!Macros.IsSet(obj.Values[3], ObjTemplate.PORTAL_LOCKED))
                    {
                        ch.SendText("It's already unlocked.\r\n");
                        return;
                    }
                    if (Macros.IsSet(obj.Values[3], ObjTemplate.PORTAL_PICKPROOF))
                    {
                        ch.SendText("You failed.\r\n");
                        return;
                    }

                    Macros.RemoveBit(ref obj.Values[3], ObjTemplate.PORTAL_LOCKED);
                    ch.SendText("*Click*\r\n");
                    SocketConnection.Act("$n&n picks $p&n.", ch, obj, null, SocketConnection.MessageTarget.room);
                    return;
                }

                /* 'pick object' */
                if (obj.ItemType != ObjTemplate.ObjectType.container)
                {
                    ch.SendText("That's not a container.\r\n");
                    return;
                }
                if (!Macros.IsSet(obj.Values[1], ObjTemplate.CONTAINER_CLOSED.Vector))
                {
                    ch.SendText("It's not closed.\r\n");
                    return;
                }
                if (obj.Values[2] < 0)
                {
                    ch.SendText("It can't be unlocked.\r\n");
                    return;
                }
                if (!Macros.IsSet(obj.Values[1], ObjTemplate.CONTAINER_LOCKED.Vector))
                {
                    ch.SendText("It's already unlocked.\r\n");
                    return;
                }
                if (Macros.IsSet(obj.Values[1], ObjTemplate.CONTAINER_PICKPROOF.Vector))
                {
                    ch.SendText("You failed.\r\n");
                    return;
                }

                Macros.RemoveBit(ref obj.Values[1], ObjTemplate.CONTAINER_LOCKED.Vector);
                ch.SendText("*Click*\r\n");
                SocketConnection.Act("$n&n picks $p&n.", ch, obj, null, SocketConnection.MessageTarget.room);
                return;
            }

            return;
        }

        /// <summary>
        /// Command to stand up.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Stand(CharData ch, string[] str)
        {
            if( ch == null ) return;
            if (ch.IsAffected( Affect.AFFECT_HOLD) || ch.IsAffected( Affect.AFFECT_MINOR_PARA))
            {
                ch.SendText("You're paralyzed!\r\n");
                return;
            }

            if (!ch.IsNPC() && ch.HasActBit(PC.PLAYER_MEMORIZING))
            {
                ch.RemoveActBit(PC.PLAYER_MEMORIZING);
                ch.SendText("You abandon your studies.\r\n");
            }

            switch (ch._position)
            {
                case Position.sleeping:
                    if (ch.IsAffected( Affect.AFFECT_SLEEP))
                    {
                        ch.SendText("You can't wake up!\r\n");
                        return;
                    }

                    ch.SendText("You wake and stand up.\r\n");
                    SocketConnection.Act("$n&n wakes and stands up.", ch, null, null, SocketConnection.MessageTarget.room);
                    ch._position = Position.standing;
                    break;

                case Position.sitting:
                case Position.kneeling:
                case Position.reclining:
                case Position.resting:
                    ch.SendText("You stand up.\r\n");
                    SocketConnection.Act("$n&n stands up.", ch, null, null, SocketConnection.MessageTarget.room);
                    if (ch._fighting)
                    {
                        ch._position = Position.fighting;
                    }
                    else
                    {
                        ch._position = Position.standing;
                    }
                    break;

                case Position.fighting:
                case Position.standing:
                    ch.SendText("You are already standing.\r\n");
                    break;
            }

            return;
        }

        /// <summary>
        /// Command to rest.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Rest(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch.IsAffected( Affect.AFFECT_HOLD) || ch.IsAffected( Affect.AFFECT_MINOR_PARA))
            {
                ch.SendText("You're paralyzed!\r\n");
                return;
            }

            switch (ch._position)
            {
                case Position.sleeping:
                    ch.SendText("You are already sleeping.\r\n");
                    break;

                case Position.resting:
                    ch.SendText("You are already resting.\r\n");
                    break;

                case Position.fighting:
                    ch.SendText("Not while you're fighting!\r\n");
                    break;

                case Position.sitting:
                case Position.kneeling:
                case Position.reclining:
                case Position.standing:
                    ch.SendText("You rest.\r\n");
                    SocketConnection.Act("$n&n rests.", ch, null, null, SocketConnection.MessageTarget.room);
                    ch._position = Position.resting;
                    break;
            }

            return;
        }

        /// <summary>
        /// Command to recline.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Recline(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch.IsAffected(Affect.AFFECT_HOLD) || ch.IsAffected(Affect.AFFECT_MINOR_PARA))
            {
                ch.SendText("You're paralyzed!\r\n");
                return;
            }

            switch (ch._position)
            {
                case Position.sleeping:
                    ch.SendText("You are sleeping.\r\n");
                    break;

                case Position.reclining:
                    ch.SendText("You are already reclining.\r\n");
                    break;

                case Position.fighting:
                    ch.SendText("Not while you're fighting!\r\n");
                    break;

                case Position.sitting:
                case Position.kneeling:
                case Position.resting:
                case Position.standing:
                    if (!ch.IsNPC() && ch.HasActBit(PC.PLAYER_MEMORIZING))
                    {
                        ch.RemoveActBit(PC.PLAYER_MEMORIZING);
                        ch.SendText("You abandon your studies.\r\n");
                    }
                    ch.SendText("You recline.\r\n");
                    SocketConnection.Act("$n&n reclines.", ch, null, null, SocketConnection.MessageTarget.room);
                    ch._position = Position.reclining;
                    break;
            }

            return;
        }

        /// <summary>
        /// Command to sit down.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Sit(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch.IsAffected( Affect.AFFECT_HOLD) || ch.IsAffected( Affect.AFFECT_MINOR_PARA))
            {
                ch.SendText("You're paralyzed!\r\n");
                return;
            }

            switch (ch._position)
            {
                case Position.sleeping:
                    ch.SendText("You can't do that while you are asleep.\r\n");
                    break;

                case Position.resting:
                    ch.SendText("You sit up.\r\n");
                    SocketConnection.Act("$n&n sits up.", ch, null, null, SocketConnection.MessageTarget.room);
                    ch._position = Position.sitting;
                    break;

                case Position.kneeling:
                case Position.reclining:
                    ch.SendText("You sit up.\r\n");
                    SocketConnection.Act("$n&n sits up.", ch, null, null, SocketConnection.MessageTarget.room);
                    ch._position = Position.sitting;
                    break;
                case Position.fighting:
                case Position.standing:
                    ch.SendText("You sit down.\r\n");
                    SocketConnection.Act("$n&n sits down.", ch, null, null, SocketConnection.MessageTarget.room);
                    ch._position = Position.sitting;
                    break;
            }

            return;
        }

        /// <summary>
        /// Command to get on your knees.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Kneel(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch.IsAffected( Affect.AFFECT_HOLD) ||
                    ch.IsAffected( Affect.AFFECT_MINOR_PARA))
            {
                ch.SendText("You're paralyzed!\r\n");
                return;
            }

            switch (ch._position)
            {
                case Position.sleeping:
                    ch.SendText("You can't do that while you are asleep.\r\n");
                    break;

                case Position.reclining:
                case Position.resting:
                case Position.sitting:
                    if (!ch.IsNPC() && ch.HasActBit(PC.PLAYER_MEMORIZING))
                    {
                        ch.RemoveActBit(PC.PLAYER_MEMORIZING);
                        ch.SendText("You abandon your studies.\r\n");
                    }
                    ch.SendText("You swing up to your knees.\r\n");
                    SocketConnection.Act("$n&n swings up to $s knees.", ch, null, null, SocketConnection.MessageTarget.room);
                    ch._position = Position.kneeling;
                    break;

                case Position.fighting:
                case Position.standing:
                    ch.SendText("You kneel.\r\n");
                    SocketConnection.Act("$n&n drops to $s knees.", ch, null, null, SocketConnection.MessageTarget.room);
                    ch._position = Position.kneeling;
                    break;
            }

            return;
        }

        /// <summary>
        /// Command to fall asleep.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        static public void Sleep(CharData ch, string[] str)
        {
            if( ch == null ) return;
            switch (ch._position)
            {
                case Position.sleeping:
                    ch.SendText("You are already sleeping.\r\n");
                    break;

                case Position.reclining:
                case Position.sitting:
                case Position.kneeling:
                case Position.resting:
                case Position.standing:

                    if (!ch.IsNPC() && ch.HasActBit(PC.PLAYER_MEMORIZING))
                    {
                        ch.RemoveActBit(PC.PLAYER_MEMORIZING);
                        ch.SendText("You abandon your studies.\r\n");
                    }
                    ch.SendText("You sleep.\r\n");
                    SocketConnection.Act("$n&n sleeps.", ch, null, null, SocketConnection.MessageTarget.room);
                    ch._position = Position.sleeping;
                    break;

                case Position.fighting:
                    ch.SendText("Not while you're fighting!\r\n");
                    break;
            }

            return;
        }

        /// <summary>
        /// Wake one's self or someone else.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Wake(CharData ch, string[] str)
        {
            if( ch == null ) return;
            string arg = String.Empty;

            if (ch.IsAwake())
            {
                ch.SendText("You are already awake.\r\n");
                return;
            }

            if (str.Length == 0 || String.IsNullOrEmpty(str[0]) || 
                str[0].Equals("me", StringComparison.CurrentCultureIgnoreCase) && ch._currentMana > 0)
            {
                Stand(ch, str);
                return;
            }

            if (!ch.IsAwake())
            {
                ch.SendText("You are asleep yourself!\r\n");
                return;
            }

            CharData victim = ch.GetCharRoom(arg);
            if (victim == null)
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (victim.IsAwake())
            {
                SocketConnection.Act("$N&n is already awake.", ch, null, victim, SocketConnection.MessageTarget.character);
                return;
            }

            if (victim.IsAffected(Affect.AFFECT_SLEEP))
            {
                SocketConnection.Act("You can't wake $M!", ch, null, victim, SocketConnection.MessageTarget.character);
                return;
            }

            victim._position = Position.resting;
            SocketConnection.Act("You wake $M.", ch, null, victim, SocketConnection.MessageTarget.character);
            SocketConnection.Act("$n&n wakes you.", ch, null, victim, SocketConnection.MessageTarget.victim);
            return;
        }

        public static void Sneak(CharData ch, string[] str)
        {
            if( ch == null ) return;
            /* Don't allow charmed mobs to do this, check player's skill */
            if ((!ch.HasSkill("sneak")))
            {
                ch.SendText("You're about as sneaky as a buffalo in tap shoes.\r\n");
                return;
            }

            if (ch._riding)
            {
                ch.SendText("You can't do that while mounted.\r\n");
                return;
            }

            if (str.Length != 0 && !MUDString.StringsNotEqual(str[0], "off"))
            {
                if (!ch.IsAffected(Affect.AFFECT_SNEAK))
                {
                    ch.SendText("You're not sneaking.\r\n");
                }
                else
                {
                    ch.SendText("You stop sneaking around.\r\n");
                    ch.RemoveAffect(Affect.AFFECT_SNEAK);
                }
                return;
            }

            ch.SendText("You attempt to move silently.\r\n");
            ch.RemoveAffect( Affect.AFFECT_SNEAK );

            /* Check skill knowledge when moving only. */
            Affect af = new Affect(Affect.AffectType.skill, "sneak", -1, Affect.Apply.none, 0, Affect.AFFECT_SNEAK);
            ch.AddAffect(af);

            ch.PracticeSkill("sneak");
            ch.WaitState(10);
            return;
        }

        public static void Hide(CharData ch, string[] str)
        {
            if( ch == null ) return;
            /* Check player's skill */
            if (!ch.HasSkill("hide"))
            {
                if(str.Length != 0)
                {
                    HideItem(ch, new[] { str[0] });
                    return;
                }
                ch.SendText("You're far too obvious to hide anywhere.\r\n");
                return;
            }

            if (ch._riding)
            {
                ch.SendText("You can't do that while mounted.\r\n");
                return;
            }

            if (ch._position <= Position.sleeping)
                return;
            ch.SendText("You attempt to hide.\r\n");

            if (ch.IsAffected(Affect.AFFECT_HIDE))
                ch.RemoveAffect(Affect.AFFECT_HIDE);

            if (ch.CheckSkill("hide"))
            {
                ch.SetAffBit(Affect.AFFECT_HIDE);
            }

            ch.WaitState(12);

            return;
        }

        /// <summary>
        /// Lets a player go visible if they want to.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Visible(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (!ch.IsAffected(Affect.AFFECT_INVISIBLE) && !ch.IsAffected(Affect.AFFECT_MINOR_INVIS) &&
                !ch.IsAffected(Affect.AFFECT_DUERGAR_HIDE))
            {
                ch.SendText("You already stick out like a &+Rsore thumb&n.\r\n" );
                return;
            }

            ch.RemoveAffect(Affect.AFFECT_INVISIBLE);
            ch.RemoveAffect(Affect.AFFECT_MINOR_INVIS);
            ch.RemoveAffect(Affect.AFFECT_DUERGAR_HIDE);

            ch.SendText("You make yourself visible.\r\n");
            SocketConnection.Act("$n&n slowly fades into existence.\r\n", ch, null, null, SocketConnection.MessageTarget.room );

            return;
        }

        /// <summary>
        /// Train: For monks or mystics, lets them learn skills and traditions.  For everyone
        /// else it tells them they practice by using their skills.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Train(CharData ch, string[] str)
        {
            if( ch == null ) return;
            int count, teacherTradition = 0;
            string buf;
            Object icon = null;
            CharData teacher = null;
            int skillLevel;

            if (!ch.IsClass(CharClass.Names.monk) && !ch.IsClass(CharClass.Names.mystic))
            {
                // Send them to the error message.
                Practice(ch, str);
                return;
            }
            if (ch.IsNPC())
            {
                return;
            }
            //find a teacher
            foreach (CharData iteacher in ch._inRoom.People)
            {
                if (iteacher._charClass == ch._charClass && iteacher.HasActBit(MobTemplate.ACT_TEACHER))
                {
                    teacher = iteacher;
                    break;
                }
            }
            // find an icon
            foreach (Object iconobj in ch._inRoom.Contents)
            {
                if (iconobj.ItemType == ObjTemplate.ObjectType.tradition_icon)
                {
                    icon = iconobj;
                    break;
                }
            }
            // if not in room, check on the teacher
            if (!icon && teacher)
            {
                foreach (Object iconobj in teacher._carrying)
                {
                    if (iconobj.ItemType == ObjTemplate.ObjectType.tradition_icon)
                    {
                        icon = iconobj;
                        break;
                    }
                }
            }
            if (icon && teacher)
            {
                teacherTradition = icon.Values[0];
            }
            int tradition = ((PC)ch).Tradition;
            
            if (str.Length == 0)
            {
                if (tradition == 0 && teacherTradition == 0)
                {
                    // tell em how to train
                    ch.SendText("One trains their skills by first training a tradition.\r\n");
                    return;
                }
                string buf1;
                if (tradition != teacherTradition && teacherTradition <= TraditionData.Table.Length
                    && teacherTradition != 0)
                {
                    // they can train a new tradition here
                    if (tradition == 0)
                    {
                        buf1 = String.Format("To train the {0} tradition, type 'train tradition'.\r\n", TraditionData.Names[teacherTradition]);
                    }
                    else
                    {
                        buf1 = String.Format("It will cost you {0} points to train tradition in the {1}.\r\n", ch._level, TraditionData.Names[teacherTradition]);
                    }
                    ch.SendText(buf1);
                    return;
                }
                //show  existing monk skills 

                buf1 = "&+WTradition:&n ";
                if (tradition != 0)
                {
                    buf = String.Format("&+B{0}&n\r\n", TraditionData.Names[tradition]);
                }
                else
                {
                    buf = String.Format("none\r\n");
                }
                buf1 += buf;
                buf1 += "\r\n&+WYou can train the following:&n\r\n\r\n";
                buf1 += "      Skill                  Level                  Cost\r\n";
                for (count = 0; count < TraditionData.Table.Length; ++count)
                {
                    if (TraditionData.Table[count].Tradition != tradition)
                        continue;
                    string sn = (TraditionData.Table[count].TraditionName);
                    skillLevel = (((PC)ch).SkillAptitude[sn] + 1) / 20;
                    if (skillLevel < 5 && TraditionData.Table[count].Cost[skillLevel] >= 0)
                    {
                        buf = String.Format("    &n&+c{0}  &+Y{1}&n  &+r{2}&n\r\n",
                        MUDString.PadStr(Skill.SkillList[sn].Name, 25),
                        MUDString.PadStr(StringConversion.SkillString(((PC)ch).SkillAptitude[sn]), 25),
                        TraditionData.Table[count].Cost[skillLevel]);
                    }
                    else
                    {
                        buf = String.Format("    &n&+c{0}  &+Y{1}&n\r\n",
                        MUDString.PadStr(Skill.SkillList[sn].Name, 25),
                        StringConversion.SkillString(((PC)ch).SkillAptitude[sn]));
                    }
                    buf1 += buf;
                } // end for
                buf1 += "\r\n";
                ch.SendText(buf1);
                return;
            }
            if (!MUDString.StringsNotEqual(str[0], "tradition"))
            {
                if (str.Length < 2 || MUDString.StringsNotEqual(str[1], "confirm"))
                {
                    ch.SendText("To train monk traditions, type 'train tradition confirm'\r\n");
                    return;
                }
                if (!teacher)
                {
                    ch.SendText("You see no teacher here.\r\n");
                    return;
                }
                if (teacherTradition == 0)
                {
                    ch.SendText("This teacher needs to be in a monastery to teach.\r\n");
                    return;
                }
                if (teacherTradition >= TraditionData.Table.Length)
                {
                    ch.SendText("It seems you have found an order so secretive that even we\r\n");
                    ch.SendText("don't know what they do!\r\n");
                    return;
                }
                if (((PC)ch).Tradition > 0 && ((PC)ch).SkillPoints < ch._level)
                {
                    ch.SendText("You do not have enough skill points to change traditions.\r\n");
                    return;
                }
                if (((PC)ch).Tradition > 0)
                {
                    ((PC)ch).SkillPoints -= ch._level;
                }
                ((PC)ch).Tradition = teacherTradition;
                buf = "You are now an initiate of the " + TraditionData.Names[teacherTradition] + "\r\n";
                ch.SendText(buf);
                return;
            }
            //now we process arg string again and train the skills
            MonkSkill skill = StringLookup.MonkSkillLookup(str[0]);
            if (skill == null )
            {
                ch.SendText("You can't train that skill here.\r\n");
                return;
            }
            if (!teacher)
            {
                ch.SendText("You see no teacher here.\r\n");
                return;
            }
            for (count = 0; count < TraditionData.Table.Length; ++count)
            {
                if (skill.Name != (TraditionData.Table[count].TraditionName))
                    continue;
                if (TraditionData.Table[count].Tradition != ((PC)ch).Tradition)
                    continue;
                skillLevel = (((PC)ch).MonkAptitude[skill.Name] + 1) / 20;
                if (skillLevel >= 5)
                {
                    ch.SendText("You have already mastered that skill.\r\n");
                    return;
                }
                if (TraditionData.Table[count].Cost[skillLevel] < 0)
                {
                    ch.SendText("You cannot train that skill any higher in this tradition.\r\n");
                    return;
                }
                if (TraditionData.Table[count].Cost[skillLevel] > ((PC)ch).SkillPoints)
                {
                    ch.SendText("You lack the experience to train this skill further.\r\n");
                    return;
                }
                // Train the skill
                ((PC)ch).SkillAptitude[skill.Name] += 20;
                ((PC)ch).SkillPoints -= TraditionData.Table[count].Cost[skillLevel];
                while (TraditionData.Table[count].Cost[skillLevel + 1] == 0 && skillLevel < 4)
                {
                    // bump em up to the next level free of charge
                    ((PC)ch).SkillAptitude[skill.Name] += 20;
                    skillLevel++;
                }
                buf = String.Format("&+cYou advance in {0}.&n\r\n", skill.Name);
                ch.SendText(buf);
                return;
            }

        }

        public static void Chameleon(CharData ch, string[] str)
        {
            if( ch == null ) return;
            if (!ch.IsNPC() && !ch.HasSkill("chameleon power"))
            {
                ch.SendText("You don't know how to act like a chameleon.\r\n");
                return;
            }

            ch.SendText("You attempt to blend in with your surroundings.\r\n");

            if (ch.IsAffected(Affect.AFFECT_HIDE))
            {
                ch.RemoveAffect(Affect.AFFECT_HIDE);
            }

            if (ch.CheckSkill("chameleon power"))
            {
                ch.SetAffBit(Affect.AFFECT_HIDE);
            }

            return;
        }

        /// <summary>
        /// Checks for people and creatures in the nearby area.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Scan(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Exit pexit;
            Room room;
            string text = String.Empty;
            int dir;

            if (ch._inRoom == null)
            {
                ch.SendText("There's no area to scan!\r\n");
                return;
            }

            ch.SendText("You scan the area.\r\n");
            for (dir = 0; dir < Limits.MAX_DIRECTION; dir++)
            {
                room = ch._inRoom;

                int distance;
                for (distance = 1; distance <= 3; distance++)
                {
                    pexit = room.ExitData[dir];
                    if (!pexit || !pexit.TargetRoom || pexit.HasFlag(Exit.ExitFlag.closed)
                        || ((pexit.HasFlag(Exit.ExitFlag.secret) || pexit.HasFlag(Exit.ExitFlag.blocked)
                        || pexit.HasFlag(Exit.ExitFlag.walled)) && !ch.IsImmortal()))
                    {
                        break;
                    }

                    if (Movement.ScanRoom(ch, Room.GetRoom(pexit.IndexNumber), ref text, distance, dir) != 0)
                    {
                        ch.SendText(text);
                    }

                    room = Room.GetRoom(pexit.IndexNumber);
                }
            }
            foreach (CharData.FlyLevel flyLevel in Enum.GetValues(typeof(CharData.FlyLevel)))
            {
                if (ch._flyLevel == flyLevel)
                {
                    continue;
                }
                if (Movement.ScanThisRoom(ch, ch._inRoom, text, flyLevel) != 0)
                {
                    ch.SendText(text);
                }
            }
            return;

        }

        public static void Heighten(CharData ch, string[] str)
        {
            if( ch == null ) return;
            Affect af = new Affect();

            if (!ch.IsNPC() && !ch.HasSkill("heighten senses"))
            {
                ch.SendText("Your senses are as heightened as they're going to get.\r\n");
                return;
            }

            if (ch.HasAffect( Affect.AffectType.skill, "heighten senses"))
                return;

            if (ch.CheckSkill("heighten senses"))
            {
                af.Value = "heighten senses";
                af.Type = Affect.AffectType.skill;
                af.Duration = 24 + ch._level;
                af.SetBitvector(Affect.AFFECT_DETECT_INVIS);
                ch.AddAffect(af);

                af.SetBitvector(Affect.AFFECT_SENSE_LIFE);
                ch.AddAffect(af);

                af.SetBitvector(Affect.AFFECT_INFRAVISION);
                ch.AddAffect(af);

                ch.SendText("Your senses are heightened.\r\n");
            }
            return;
        }

        public static void Shadow(CharData ch, string[] str)
        {
            if( ch == null ) return;
            Affect af = new Affect();

            if (!ch.IsNPC()
                    && !ch.HasSkill("shadow form"))
            {
                ch.SendText("You don't know how to take shadwo form.\r\n");
                return;
            }

            ch.SendText("You attempt to move in the shadows.\r\n");
            ch.AffectStrip( Affect.AffectType.skill, "shadow form");

            if (ch.CheckSkill("shadow form"))
            {
                af.Value = "shadow form";
                af.Type = Affect.AffectType.skill;
                af.Duration = ch._level;
                af.SetBitvector(Affect.AFFECT_SNEAK);
                ch.AddAffect(af);
            }
            ch.WaitState(10);

            return;
        }

        public static void Shift(CharData ch, string[] str)
        {
            if( ch == null ) return;
            if (ch.GetRace() != Race.RACE_GITHYANKI && !ch.IsImmortal())
            {
                ch.SendText("You lack that abillity!\r\n");
                return;
            }
            
            if (str.Length < 1 || String.IsNullOrEmpty(str[0]))
            {
                ch.SendText("Shift to where?\r\n");
                return;
            }

            if (ch._fighting)
            {
                ch.SendText("You can't break off your fight.\r\n");
                return;
            }
            if ((ch.HasInnateTimer(InnateTimerData.Type.shift_astral) && !MUDString.IsPrefixOf(str[0], "astral"))
                || (ch.HasInnateTimer(InnateTimerData.Type.shift_prime) && !MUDString.IsPrefixOf(str[0], "prime")))
            {
                ch.SendText("You need to rest a _bitvector first.\r\n");
                return;
            }

            Area area = ch._inRoom.Area;
            Spell spell = StringLookup.SpellLookup("plane shift");
            if (!spell)
            {
                ch.SendText("Something seems to be blocking your ability to shift.");
                Log.Error("Shift: 'plane shift' spell not found. Check the spells file.");
                return;
            }
            spell.Invoke(ch, ch._level, new Target(str[0]));
            // if it failed, don't lag or add a timer
            if (area == ch._inRoom.Area)
                return;
            if (!ch.IsImmortal())
            {
                if (!MUDString.IsPrefixOf(str[0], "astral"))
                    ch.AddInnateTimer(InnateTimerData.Type.shift_astral, 8);
                else if (!MUDString.IsPrefixOf(str[0], "prime"))
                    ch.AddInnateTimer(InnateTimerData.Type.shift_prime, 8);
            }
            ch.WaitState(14);
        }

        public static void Doorbash(CharData ch, string[] str)
        {
            if( ch == null ) return;
            int door;
            Room toRoom;

            if (ch.IsNPC() || (!ch.HasSkill("doorbash") && !ch.HasInnate(Race.RACE_DOORBASH)))
            {
                ch.SendText("You don't feel massive enough!\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Doorbash what?\r\n");
                return;
            }

            if (ch._fighting)
            {
                ch.SendText("You can't break off your fight.\r\n");
                return;
            }

            if ((door = Movement.FindDoor(ch, str[0])) >= 0)
            {
                Exit reverseExit;
                int chance;

                Exit exit = ch._inRoom.ExitData[door];
                if (!exit.HasFlag(Exit.ExitFlag.closed))
                {
                    ch.SendText("Calm down. It is already open.\r\n");
                    return;
                }

                ch.WaitState(Skill.SkillList["doorbash"].Delay);

                if (ch.IsNPC())
                    chance = 0;
                else if (!ch.HasSkill("doorbash"))
                    chance = 20;
                else
                    chance = ((PC)ch).SkillAptitude["doorbash"] / 2;

                if (exit.HasFlag(Exit.ExitFlag.locked))
                    chance /= 2;

                if (exit.HasFlag(Exit.ExitFlag.bashproof)
                        && !ch.IsImmortal())
                {
                    SocketConnection.Act("WHAAAAM!!!  You bash against the $d, but it doesn't budge.",
                         ch, null, exit.Keyword, SocketConnection.MessageTarget.character);
                    SocketConnection.Act("WHAAAAM!!!  $n&n bashes against the $d, but it holds strong.",
                         ch, null, exit.Keyword, SocketConnection.MessageTarget.room);
                    Combat.InflictDamage(ch, ch, (ch.GetMaxHit() / 20), "doorbash", ObjTemplate.WearLocation.none, AttackType.DamageType.bludgeon);
                    if (exit.HasFlag(Exit.ExitFlag.spiked))
                    {
                        SocketConnection.Act("You are impaled by spikes protruding from the $d!",
                            ch, null, exit.Keyword, SocketConnection.MessageTarget.character);
                        SocketConnection.Act("$n&n is impaled by spikes protruding from the $d!",
                            ch, null, exit.Keyword, SocketConnection.MessageTarget.room);
                        Combat.InflictDamage(ch, ch, (ch.GetMaxHit() / 5), "doorbash", ObjTemplate.WearLocation.none, AttackType.DamageType.pierce);
                    }
                    return;
                }

                if (exit.HasFlag(Exit.ExitFlag.spiked))
                {
                    SocketConnection.Act("You are impaled by spikes protruding from the $d!",
                        ch, null, exit.Keyword, SocketConnection.MessageTarget.character);
                    SocketConnection.Act("$n&n is impaled by spikes protruding from the $d!",
                        ch, null, exit.Keyword, SocketConnection.MessageTarget.room);
                    Combat.InflictDamage(ch, ch, (ch.GetMaxHit() / 5), "doorbash", ObjTemplate.WearLocation.none, AttackType.DamageType.pierce);
                }

                if ((ch.GetCurrStr() >= 20)
                        && MUDMath.NumberPercent() <
                        (chance + 4 * (ch.GetCurrStr() - 20)))
                {
                    /* Success */

                    exit.RemoveFlag(Exit.ExitFlag.closed);
                    if (exit.HasFlag(Exit.ExitFlag.locked))
                        exit.RemoveFlag(Exit.ExitFlag.locked);

                    exit.AddFlag(Exit.ExitFlag.bashed);

                    SocketConnection.Act("Crash!  You bashed open the $d!",
                         ch, null, exit.Keyword, SocketConnection.MessageTarget.character);
                    SocketConnection.Act("$n&n bashes open the $d!",
                         ch, null, exit.Keyword, SocketConnection.MessageTarget.room);

                    Combat.InflictDamage(ch, ch, (ch.GetMaxHit() / 30), "doorbash", ObjTemplate.WearLocation.none, AttackType.DamageType.bludgeon);

                    /* Bash through the other side */
                    if ((toRoom = Room.GetRoom(exit.IndexNumber)) && (reverseExit = toRoom.ExitData[Exit.ReverseDirection[door]])
                        && reverseExit.TargetRoom == ch._inRoom)
                    {
                        reverseExit.RemoveFlag(Exit.ExitFlag.closed);
                        if (reverseExit.HasFlag(Exit.ExitFlag.locked))
                        {
                            reverseExit.RemoveFlag(Exit.ExitFlag.locked);
                        }

                        reverseExit.AddFlag(Exit.ExitFlag.bashed);

                        foreach (CharData irch in toRoom.People)
                        {
                            SocketConnection.Act("The $d crashes open!",
                                 irch, null, reverseExit.Keyword, SocketConnection.MessageTarget.character);
                        }

                        // Have any aggro mobs on the other side come after the player -- Xangis
                        foreach (CharData gch in toRoom.People)
                        {
                            if (gch != ch && (gch.IsNPC() && !gch.IsAffected( Affect.AFFECT_CHARM))
                                && gch.IsAggressive(ch) && gch.IsAwake() && CharData.CanSee(gch, ch)
                                && !gch._fighting)
                            {
                                Combat.StartHating(gch, ch);
                                Combat.StartHunting(gch, ch);
                            }
                        }

                    }
                }
                else
                {
                    /* Failure */

                    SocketConnection.Act("OW!  You bash against the $d, but it doesn't budge.",
                         ch, null, exit.Keyword, SocketConnection.MessageTarget.character);
                    SocketConnection.Act("$n&n bashes against the $d, but it holds strong.",
                         ch, null, exit.Keyword, SocketConnection.MessageTarget.room);
                    Combat.InflictDamage(ch, ch, (ch.GetMaxHit() / 10), "doorbash", ObjTemplate.WearLocation.none, AttackType.DamageType.bludgeon);
                }
            }

            /*
            * Check for "guards"... anyone bashing a door is considered as
            * a potential aggressor, and there's a 25% chance that mobs
            * will do unto before being done unto.
            * But first...let's make sure ch ain't dead?  That'd be a pain.
            */

            if (ch._hitpoints <= 1)
                return;

            ch.PracticeSkill("doorbash");

            foreach (CharData gch in ch._inRoom.People)
            {
                if (gch != ch
                        && gch.HasActBit(MobTemplate.ACT_PROTECTOR)
                        && (gch.IsNPC() && !gch.IsAffected( Affect.AFFECT_CHARM))
                        && gch.IsAwake()
                        && CharData.CanSee(gch, ch)
                        && !gch._fighting
                        && MUDMath.NumberBits(2) == 0)
                {
                    SocketConnection.Act("$n&n is very unhappy about you trying to destroy the door.", gch, null, ch, SocketConnection.MessageTarget.victim);
                    gch.AttackCharacter(ch);
                }
            }

            return;

        }

        public static void Capture(CharData ch, string[] str)
        {
            if( ch == null ) return;
            CharData victim;
            Affect af = new Affect();

            /* Check player's level and class, allow mobs to do this too */
            if ((!ch.HasSkill("capture")))
            {
                ch.SendText("You couldn't capture a dead rat.\r\n");
                return;
            }

            if (str.Length == 0)
            {
                victim = ch._fighting;
                if (!victim)
                {
                    ch.SendText("Capture whom?\r\n");
                    return;
                }
            }
            else                /* argument supplied */
            {
                victim = ch.GetCharRoom(str[0]);
                if (!victim)
                {
                    ch.SendText("They aren't here.\r\n");
                    return;
                }
            }
            if (ch._fighting && ch._fighting != victim)
            {
                ch.SendText("Take care of the person you are fighting first!\r\n");
                return;
            }
            if (!ch.IsImmortal())
                ch.WaitState(Skill.SkillList["capture"].Delay);

            Object rope = Object.GetEquipmentOnCharacter(ch, ObjTemplate.WearLocation.hand_one);
            if (!rope || rope.ItemType != ObjTemplate.ObjectType.rope)
            {
                rope = Object.GetEquipmentOnCharacter(ch, ObjTemplate.WearLocation.hand_two);
                if (!rope || rope.ItemType != ObjTemplate.ObjectType.rope)
                {
                    rope = Object.GetEquipmentOnCharacter(ch, ObjTemplate.WearLocation.hand_three);
                    if (!rope || rope.ItemType != ObjTemplate.ObjectType.rope)
                    {
                        rope = Object.GetEquipmentOnCharacter(ch, ObjTemplate.WearLocation.hand_four);
                        if (!rope || rope.ItemType != ObjTemplate.ObjectType.rope)
                            rope = null;
                    }
                }
            }
            if (!rope)
            {
                ch.SendText("You must have some rope to tie someone up!\r\n");
                return;
            }
            rope.RemoveFromWorld();

            /* only appropriately skilled PCs and uncharmed mobs */
            if ((ch.IsNPC() && !ch.IsAffected( Affect.AFFECT_CHARM))
                    || (!ch.IsNPC() && MUDMath.NumberPercent() < ((PC)ch).SkillAptitude["capture"] / 4))
            {
                victim.AffectStrip( Affect.AffectType.skill, "capture");

                af.Value = "capture";
                af.Type = Affect.AffectType.skill;
                af.Duration = 3 + ((ch._level) / 8);
                af.SetBitvector(Affect.AFFECT_BOUND);

                victim.AddAffect(af);

                SocketConnection.Act("You have captured $M!", ch, null, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n has captured you!", ch, null, victim, SocketConnection.MessageTarget.victim);
                SocketConnection.Act("$n&n has captured $N&n.", ch, null, victim, SocketConnection.MessageTarget.everyone_but_victim);
            }
            else
            {
                SocketConnection.Act("You failed to capture $M.  Uh oh!",
                     ch, null, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n tried to capture you!  Get $m!",
                     ch, null, victim, SocketConnection.MessageTarget.victim);
                SocketConnection.Act("$n&n attempted to capture $N&n, but failed!",
                     ch, null, victim, SocketConnection.MessageTarget.everyone_but_victim);
            }

            /* go for the one who wanted to fight :) */
            if (ch.IsNPC() && ch.IsAffected( Affect.AFFECT_CHARM) && !victim._fighting)
            {
                victim.AttackCharacter(ch._master);
            }
            else if (!victim._fighting)
            {
                victim.AttackCharacter(ch);
            }

            return;
        }

        public static void Untangle(CharData ch, string[] str)
        {
            if( ch == null ) return;
            CharData victim;

            if (!ch.IsNPC() && !ch.HasSkill("untangle"))
            {
                ch.SendText("You aren't nimble enough.\r\n");
                return;
            }

            if (str.Length == 0)
            {
                victim = ch;
            }
            else
            {
                victim = ch.GetCharRoom(str[0]);
                if (victim == null)
                {
                    ch.SendText("They aren't here.\r\n");
                    return;
                }
            }

            if (!victim.HasAffect( Affect.AffectType.skill, "capture"))
            {
                ch.SendText("There's nothing to untangle.\r\n");
                return;
            }

            if ((ch.IsNPC() && !ch.IsAffected( Affect.AFFECT_CHARM)) || (!ch.IsNPC()
                         && MUDMath.NumberPercent() < ((PC)ch).SkillAptitude["untangle"]))
            {
                victim.AffectStrip( Affect.AffectType.skill, "capture");

                if (victim != ch)
                {
                    SocketConnection.Act("You untangle $N&n.", ch, null, victim, SocketConnection.MessageTarget.character);
                    SocketConnection.Act("$n&n untangles you.", ch, null, victim, SocketConnection.MessageTarget.victim);
                    SocketConnection.Act("$n&n untangles $n&n.", ch, null, victim, SocketConnection.MessageTarget.everyone_but_victim);
                }
                else
                {
                    ch.SendText("You untangle yourself.\r\n");
                    SocketConnection.Act("$n&n untangles $mself.", ch, null, null, SocketConnection.MessageTarget.room);
                }

                ch.PracticeSkill("untangle");

                return;
            }
        }

        public static void Enter(CharData ch, string[] str)
        {
            if( ch == null ) return;
            Room location;
            bool ship = false;

            if (str.Length == 0)
            {
                ch.SendText("Enter what?\r\n");
                return;
            }

            if (ch._fighting)
            {
                ch.SendText("Not while you're fighting!\r\n");
                return;
            }

            Room original = ch._inRoom;
            Object portal = Object.GetObjFromList(ch._inRoom.Contents, ch, str[0]);

            if (!portal)
            {
                SocketConnection.Act("There is no $t in here.", ch, str[0], null, SocketConnection.MessageTarget.character);
                return;
            }

            if (portal.ItemType != ObjTemplate.ObjectType.portal)
            {
                if (portal.ItemType != ObjTemplate.ObjectType.ship && portal.ItemType != ObjTemplate.ObjectType.vehicle)
                {
                    ch.SendText("That's not a portal.\r\n");
                    return;
                }
                ship = true;
            }

            if (!ship)
            {
                if (Macros.IsSet(portal.Values[3], ObjTemplate.PORTAL_CLOSED))
                {
                    ch.SendText("That portal is closed.\r\n");
                    return;
                }

                if (portal.Values[2] == 0)
                {
                    SocketConnection.Act("$p&n has no power left.", ch, portal, null, SocketConnection.MessageTarget.character);
                    return;
                }

                if (!Macros.IsSet(portal.Values[3], ObjTemplate.PORTAL_NO_CURSED)
                        && (ch.IsAffected( Affect.AFFECT_CURSE)                                                                           ))
                {
                    ch.SendText("Your deity has forsaken you.\r\n");
                    return;
                }
                location = Room.GetRoom(portal.Values[0]);

                if (Macros.IsSet(portal.Values[3], ObjTemplate.PORTAL_BUGGY) && MUDMath.NumberPercent() < 5)
                {
                    location = Movement.GetRandomRoom();
                }

                if (Macros.IsSet(portal.Values[3], ObjTemplate.PORTAL_RANDOM))
                {
                    location = Movement.GetRandomRoom();
                    portal.Values[0] = location.IndexNumber;
                }

                if (!location)
                {
                    ch.SendText("The target room for this portal does not exist.\r\n");
                    return;
                }

                if (location == original)
                {
                    SocketConnection.Act("$p&n doesn't seem to go anywhere.", ch, portal, null, SocketConnection.MessageTarget.character);
                    return;
                }
            }
            else
            {
                location = Room.GetRoom(portal.Values[1]);
                if (!location)
                {
                    ch.SendText("That boat is broken.  You may not board it.\r\n");
                    return;
                }
            }

            if (location.IsPrivate())
            {
                ch.SendText("There is no room for you on the other side.\r\n");
                return;
            }

            if (!ship)
            {
                SocketConnection.Act("$n&n steps into $p&n.", ch, portal, null, SocketConnection.MessageTarget.room);
                if (Macros.IsSet(portal.Values[3], ObjTemplate.PORTAL_RANDOM)
                        || Macros.IsSet(portal.Values[3], ObjTemplate.PORTAL_BUGGY))
                {
                    SocketConnection.Act("You walk through $p&n and find yourself somewhere else...",
                         ch, portal, null, SocketConnection.MessageTarget.character);
                }
                else
                {
                    SocketConnection.Act("You enter $p&n.", ch, portal, null, SocketConnection.MessageTarget.character);
                }
            }
            else
            {
                SocketConnection.Act("$n&n boards $p&n.", ch, portal, null, SocketConnection.MessageTarget.room);
                SocketConnection.Act("You board $p&n.", ch, portal, null, SocketConnection.MessageTarget.character);
            }

            ch.RemoveFromRoom();
            ch.AddToRoom(location);

            if (!ship)
            {
                if (Macros.IsSet(portal.Values[3], ObjTemplate.PORTAL_RANDOM)
                        || Macros.IsSet(portal.Values[3], ObjTemplate.PORTAL_BUGGY))
                {
                    SocketConnection.Act("$n&n has arrived.", ch, portal, null, SocketConnection.MessageTarget.room);
                }
                else
                {
                    SocketConnection.Act("$n&n steps out of $p&n.", ch, portal, null, SocketConnection.MessageTarget.room);
                }
            }
            else
            {
                SocketConnection.Act("$n&n has boarded.", ch, portal, null, SocketConnection.MessageTarget.room);
            }

            CommandType.Interpret(ch, "look auto");

            if (!ship)
            {
                if (portal.Values[2] > 0)   /*
                                                  * This way i prevent an underflow 
                                                  */
                    portal.Values[2]--;

                if (portal.Values[2] == 0)/*
                                                * If there are no more charges; remove 
                                                */
                {
                    SocketConnection.Act("$p&n fades out of existence.", ch, portal, null, SocketConnection.MessageTarget.character);
                    SocketConnection.Act("$p&n fades out of existence.", ch, portal, null, SocketConnection.MessageTarget.room);
                    portal.RemoveFromWorld();
                    return;
                }

                if (Macros.IsSet(portal.Values[3], ObjTemplate.PORTAL_GO_WITH))
                {
                    portal.RemoveFromRoom();
                    portal.AddToRoom(location);
                }
            }

            foreach (CharData fch in original.People)
            {
                if (!fch.IsAffected(Affect.AFFECT_CHARM) || fch._master != ch)
                {
                    continue;
                }

                if (fch._position < Position.standing)
                {
                    CommandType.Interpret(ch, "stand");
                }

                if (fch._position == Position.standing && fch._wait == 0)
                {
                    SocketConnection.Act("You follow $N&n.", fch, null, ch, SocketConnection.MessageTarget.character);
                    Enter(fch, str);
                }
            }

            return;
        }

        /// <summary>
        /// Climb on and ride a mount (horse, griffon, etc.)
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Mount(CharData ch, string[] str)
        {
            if (!ch)
            {
                Log.Error("Commandmount: no ch!", 0);
                return;
            }

            if (ch._riding)
            {
                ch.SendText("You're already mounted!\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Mount what?\r\n");
                return;
            }

            CharData victim = ch.GetCharRoom(str[0]);
            if (victim == null)
            {
                ch.SendText("You can't find that here.\r\n");
                return;
            }

            if (!victim.IsNPC() || !victim.HasActBit(MobTemplate.ACT_MOUNT))
            {
                ch.SendText("You can't mount that!\r\n");
                return;
            }

            if (ch._rider)
            {
                ch.SendText("You are being ridden by someone else!\r\n");
                return;
            }

            if (victim._rider)
            {
                ch.SendText("That mount already has a rider.\r\n");
                return;
            }

            if (victim._position < Position.standing)
            {
                ch.SendText("Your mount must be standing.\r\n");
                return;
            }

            if (victim._position == Position.fighting || victim._fighting)
            {
                ch.SendText("Your mount is moving around too much.\r\n");
                return;
            }

            ch.WaitState(Skill.SkillList["mount"].Delay);
            // NPCs and Immortals automatically succeed.  The former is partly because the mount command
            // can be issued by a zone reset.  We wouldn't want a mob to fail a mount when the area declares
            // that they should be mounted.
            if (ch.IsNPC() || ch.IsImmortal() || ch.CheckSkill("mount", PracticeType.easy ))
            {
                victim._rider = ch;
                ch._riding = victim;
                SocketConnection.Act("You mount $N&n.", ch, null, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n skillfully mounts $N&n.", ch, null, victim, SocketConnection.MessageTarget.everyone_but_victim);
                SocketConnection.Act("$n&n mounts you.", ch, null, victim, SocketConnection.MessageTarget.victim);
            }
            else
            {
                SocketConnection.Act("You unsuccessfully try to mount $N&n.", ch, null, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n unsuccessfully attempts to mount $N&n.", ch, null, victim, SocketConnection.MessageTarget.everyone_but_victim);
                SocketConnection.Act("$n&n tries to mount you.", ch, null, victim, SocketConnection.MessageTarget.victim);
            }

            return;
        }

        public static void Dismount(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim = ch._riding;
            if (!victim)
            {
                ch.SendText("You're not mounted.\r\n");
                return;
            }

            if (ch._riding._inRoom != ch._inRoom)
            {
                ch.SendText("Weird! You dismount, but your mount isn't here.");
                if (ch._riding._rider && ch._riding._rider == ch)
                    ch._riding._rider = null;
                ch._riding = null;
                return;
            }

            ch.WaitState(Skill.SkillList["mount"].Delay);
            if (ch.CheckSkill("mount", PracticeType.easy))
            {
                SocketConnection.Act("You dismount $N&n.", ch, null, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n skillfully dismounts $N&n.", ch, null, victim, SocketConnection.MessageTarget.everyone_but_victim);
                SocketConnection.Act("$n&n dismounts you.  Whew!", ch, null, victim, SocketConnection.MessageTarget.victim);
                victim._rider = null;
                ch._riding = null;
                ch._position = Position.standing;
            }
            else
            {
                SocketConnection.Act("You fall off while dismounting $N&n.  Ouch!", ch, null, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n falls off of $N&n while dismounting.", ch, null, victim, SocketConnection.MessageTarget.everyone_but_victim);
                SocketConnection.Act("$n&n falls off your back.", ch, null, victim, SocketConnection.MessageTarget.victim);
                victim._rider = null;
                ch._riding = null;
                ch._position = Position.resting;
                Combat.InflictDamage(ch, ch, 1, String.Empty, ObjTemplate.WearLocation.none, AttackType.DamageType.bludgeon);
            }

            return;
        }

        public static void Buck(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (!ch._rider)
            {
                ch.SendText("There is no one riding you.\r\n");
                return;
            }

            SocketConnection.Act("$n&n bucks $N&n!", ch, null, ch._rider, SocketConnection.MessageTarget.everyone_but_victim);
            SocketConnection.Act("You buck $M!", ch, null, ch._rider, SocketConnection.MessageTarget.character);
            SocketConnection.Act("$n&n bucks you from $m!", ch, null, ch._rider, SocketConnection.MessageTarget.victim);

            ch._rider._riding = null;
            ch._rider._position = Position.resting;
            ch._rider = null;
            return;
        }

        public static void FirstAid(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch.IsNPC())
                return;

            if (ch._fighting || ch._position == Position.fighting)
            {
                ch.SendText("You can't do that while fighting!\r\n");
                return;
            }

            if (((PC)ch).FirstaidTimer > 0)
            {
                ch.SendText("You can only first aid once per day.\r\n");
                return;
            }

            if (ch._hitpoints < ch.GetMaxHit())
            {
                ch._hitpoints += MUDMath.Dice(3, (ch._level / 2)) + 1;
                if (((PC)ch).SkillAptitude["bandage"] > 9)
                {
                    ch._hitpoints += ((PC)ch).SkillAptitude["bandage"] / 8;
                    ch.PracticeSkill("bandage");
                }
                if (ch._hitpoints > ch.GetMaxHit())
                {
                    ch._hitpoints = ch.GetMaxHit();
                }
            }

            ((PC)ch).FirstaidTimer = 24;

            ch.SendText("You attempt to render first aid unto yourself.\r\n");

            return;
        }

        /// <summary>
        /// Looks at an object, mobile, or room.
        /// </summary>
        /// <param name="ch">The acting character.</param>
        /// <param name="str">Command arguments.</param>
        public static void LookCommand(CharData ch, string[] str)
        {
            if( ch == null ) return;

            // Build argument list, stripping articles.
            bool inside = false;
            List<String> args = new List<string>(str);
            for (int i = (args.Count - 1); i >= 0; i-- )
            {
                if (args[i].Equals("in", StringComparison.CurrentCultureIgnoreCase) || args[i].Equals("i", StringComparison.CurrentCultureIgnoreCase))
                {
                    args.RemoveAt(i);
                    inside = true;
                }
                else if (args[i].Equals("at", StringComparison.CurrentCultureIgnoreCase))
                {
                    args.RemoveAt(i);
                }
            }

            // If it's a mob that isn't switched, bail.
            if (ch._socket == null)
                return;

            if (ch._position < Position.sleeping)
            {
                ch.SendText("&nYou can't see anything but &+Ystars&n!  See how pretty!\r\n");
                return;
            }

            if (ch._position == Position.sleeping)
            {
                ch.SendText("&nYou can't see anything, you're &+Lsleeping&n!  Zzz.\r\n");
                return;
            }

            if (ch.IsBlind())
                return;

            // Look panel for ships.
            if ( args.Count > 0 && args[0].Equals("panel", StringComparison.CurrentCultureIgnoreCase))
            {
                CommandType.Interpret(ch, "Lookpanel");
                return;
            }
            // Look out for ships.
            if (args.Count > 0 && args[0].Equals("out", StringComparison.CurrentCultureIgnoreCase))
            {
                CommandType.Interpret(ch, "Lookout");
                return;
            }

            Object obj;
            Exit exit;
            string pdesc;
            int number = 0;
            string output = String.Empty;

            // 'look' or 'look auto' or 'look room'
            if (args.Count == 0 || args[0].Equals( "auto", StringComparison.CurrentCultureIgnoreCase) ||
                args[0].Equals("room", StringComparison.CurrentCultureIgnoreCase))
            {
                if (ch._inRoom == null)
                {
                    ch.SendText("You are not in a room.  You are just floating in empty space.  This should never happen.  You should <petition> someone for help.\r\n");
                    Log.Error("Character executing Commandlook command from null room: " + ch._name);
                    return;
                }
                if (ch._flyLevel > 0)
                {
                    switch (ch._flyLevel)
                    {
                        case CharData.FlyLevel.low:
                            ch.SendText("Hovering above ");
                            break;
                        case CharData.FlyLevel.medium:
                            ch.SendText("Flying above ");
                            break;
                        case CharData.FlyLevel.high:
                            ch.SendText("Flying high above ");
                            break;
                    }
                }
                if (!ch.HasActBit(PC.PLAYER_GODMODE)
                        && ch._inRoom.IsDark()
                        && !ch.HasInnate(Race.RACE_ULTRAVISION)
                        && !ch.IsAffected( Affect.AFFECT_ULTRAVISION))
                {
                    ch.SendText("&+lSomewhere\r\n");
                }
                else if (!ch.HasActBit(PC.PLAYER_GODMODE))
                {
                    String roomOpen = String.Empty;
                    String roomClose = String.Empty;
                    if (!ch.IsNPC() && ch._socket._terminalType == SocketConnection.TerminalType.TERMINAL_ENHANCED)
                    {
                        roomOpen = "<zone>" + ch._inRoom.Area.Name + "</zone><roomTitle>";
                        roomClose = "</roomTitle>";
                    }
                    else
                    {
                        roomClose = "&n\r\n";
                    }
                    // Added support for both manual and automatic descriptions on the worldmap.
                    if (!ch._inRoom.Area.HasFlag(Area.AREA_WORLDMAP) || ch._inRoom.Title.Length > 1)
                    {
                        output += roomOpen + ch._inRoom.Title + roomClose;
                    }
                    else
                    {
                        output += roomOpen + "No room title." + roomClose;
                    }
                }
                else
                {
                    if (!ch.IsNPC() && ch._socket._terminalType == SocketConnection.TerminalType.TERMINAL_ENHANCED)
                    {
                        ch.SendText("<zone>" + ch._inRoom.Area.Name + "</zone>");
                    }
                    Look.ShowRoomInfo(ch, ch._inRoom);
                }

                if (!ch.IsNPC() && !ch.HasActBit(PC.PLAYER_GODMODE) && ch._inRoom.IsDark()
                    && !ch.HasInnate(Race.RACE_ULTRAVISION) && !ch.IsAffected( Affect.AFFECT_ULTRAVISION))
                {
                    ch.SendText("&+LIt is pitch black...&n \r\n");
                    Look.ShowCharacterToCharacter(ch._inRoom.People, ch);
                    return;
                }

                if (!ch.IsNPC() && (args.Count > 0 && (args[0].Equals("room", StringComparison.CurrentCultureIgnoreCase) ||
                    args[0].Equals("auto", StringComparison.CurrentCultureIgnoreCase))))
                {
                    String roomDescOpen = String.Empty;
                    String roomDescClose = String.Empty;
                    String mapSpace = String.Empty;

                    if (!ch.IsNPC() && ch._socket._terminalType == SocketConnection.TerminalType.TERMINAL_ENHANCED)
                    {
                        roomDescOpen = "<roomDescription>";
                        roomDescClose = "</roomDescription>";
                    }
                    else
                    {
                        roomDescClose = "&n\r\n";
                        mapSpace = "    ";
                    }
                    if( !ch.HasActBit(PC.PLAYER_BRIEF) && !ch._inRoom.Area.HasFlag(Area.AREA_WORLDMAP))
                    {
                        // Added support for both manual and automatic descriptions on the worldmap.
                        if (ch._inRoom.Description.Length > 0)
                        {
                            output += roomDescOpen + "    " + (ch._inRoom.Description.Trim()) + roomDescClose;
                        }
                        //else if (ch._inRoom.WorldmapTerrainType < Database.SystemData.MapInfo.Length)
                        //    output += roomDescOpen + mapSpace + Database.SystemData.MapInfo[ch._inRoom.WorldmapTerrainType].RoomDescription + roomDescClose;
                        else
                        {
                            output += roomDescOpen + "    No room description." + roomDescClose;
                        }
                    }
                }
                if (!String.IsNullOrEmpty(output))
                {
                    ch.SendText(output);
                }

                if (ch._inRoom.Area.HasFlag(Area.AREA_WORLDMAP))
                {
                    if (ch.HasActBit(PC.PLAYER_MAP))
                    {
                        Command.Worldmap(ch, null);
                    }
                    else if (!ch.IsNPC() && ch._socket._terminalType != SocketConnection.TerminalType.TERMINAL_ENHANCED)
                    {
                        ch.SendText("\r\n");
                    }
                }

                if (ch._inRoom.HasFlag(RoomTemplate.ROOM_SILENT))
                {
                    ch.SendText("&nIt seems preternaturally quiet.\r\n");
                }

                CommandType.Interpret(ch, "exits auto");

                Look.ShowRoomAffects(ch, ch._inRoom);

                Look.ShowListToCharacter(ch._inRoom.Contents, ch, false, false);
                Look.ShowCharacterToCharacter(ch._inRoom.People, ch);
                return;
            }

            // 'look direction'
            int door = -1;
            if (args.Count > 0)
            {
                if ("north".StartsWith(args[0], StringComparison.CurrentCultureIgnoreCase))
                    door = 0;
                else if ("east".StartsWith(args[0], StringComparison.CurrentCultureIgnoreCase))
                    door = 1;
                else if ("south".StartsWith(args[0], StringComparison.CurrentCultureIgnoreCase))
                    door = 2;
                else if ("west".StartsWith(args[0], StringComparison.CurrentCultureIgnoreCase))
                    door = 3;
                else if ("up".StartsWith(args[0], StringComparison.CurrentCultureIgnoreCase))
                    door = 4;
                else if ("down".StartsWith(args[0], StringComparison.CurrentCultureIgnoreCase))
                    door = 5;
                else if ("northwest".StartsWith(args[0], StringComparison.CurrentCultureIgnoreCase))
                    door = 6;
                else if ("southwest".StartsWith(args[0], StringComparison.CurrentCultureIgnoreCase))
                    door = 7;
                else if ("northeast".StartsWith(args[0], StringComparison.CurrentCultureIgnoreCase))
                    door = 8;
                else if ("southeast".StartsWith(args[0], StringComparison.CurrentCultureIgnoreCase))
                    door = 9;
                else if ("nw".StartsWith(args[0], StringComparison.CurrentCultureIgnoreCase))
                    door = 6;
                else if ("sw".StartsWith(args[0], StringComparison.CurrentCultureIgnoreCase))
                    door = 7;
                else if ("ne".StartsWith(args[0], StringComparison.CurrentCultureIgnoreCase))
                    door = 8;
                else if ("se".StartsWith(args[0], StringComparison.CurrentCultureIgnoreCase))
                    door = 9;
            }
            if (door != -1)
            {
                // If no exit data, then return.
                exit = ch._inRoom.ExitData[door];
                if (!exit)
                {
                    ch.SendText("There's nothing to see in that direction.\r\n");
                    return;
                }

                if (exit.HasFlag(Exit.ExitFlag.walled))
                {
                    ch.SendText("There's a wall in the way.\r\n");
                    return;
                }

                // Check for farsee
                if ((ch.IsAffected( Affect.AFFECT_FARSEE) || ch.HasActBit(PC.PLAYER_GODMODE))
                        && !exit.HasFlag(Exit.ExitFlag.closed))
                {
                    if (exit.TargetRoom)
                    {
                        Room room = ch._inRoom;
                        ch.RemoveFromRoom();
                        ch.AddToRoom(Room.GetRoom(exit.IndexNumber));
                        CommandType.Interpret(ch, "look");
                        ch.RemoveFromRoom();
                        ch.AddToRoom(room);
                        return;
                    }
                    ch.SendText("Nothing special there.\r\n");
                }

                if (exit.Description.Length != 0)
                {
                    ch.SendText(exit.Description);
                }
                else
                {
                    ch.SendText("Nothing special there.\r\n");
                }

                if (exit.Keyword.Length != 0)
                {
                    if (exit.HasFlag(Exit.ExitFlag.bashed))
                        SocketConnection.Act("The $d has been bashed from its &n&+whinges&n.",
                             ch, null, exit.Keyword, SocketConnection.MessageTarget.character);
                    else if (exit.HasFlag(Exit.ExitFlag.closed))
                        SocketConnection.Act("The $d is closed.", ch, null, exit.Keyword, SocketConnection.MessageTarget.character);
                    else if (exit.HasFlag(Exit.ExitFlag.secret))
                        SocketConnection.Act("The $d is secret.", ch, null, exit.Keyword, SocketConnection.MessageTarget.character);
                    else if (exit.HasFlag(Exit.ExitFlag.blocked))
                        SocketConnection.Act("The $d is blocked.", ch, null, exit.Keyword, SocketConnection.MessageTarget.character);
                }
                else
                {
                    if (exit.HasFlag(Exit.ExitFlag.bashed))
                    {
                        SocketConnection.Act("The door has been bashed from its &n&+whinges&n.",
                             ch, null, null, SocketConnection.MessageTarget.character);
                    }
                    else if (exit.HasFlag(Exit.ExitFlag.closed))
                        SocketConnection.Act("The door is closed.", ch, null, null, SocketConnection.MessageTarget.character);
                    else if (exit.HasFlag(Exit.ExitFlag.is_door))
                        SocketConnection.Act("The door is open.", ch, null, null, SocketConnection.MessageTarget.character);
                    else if (exit.HasFlag(Exit.ExitFlag.secret))
                        SocketConnection.Act("The door is secret.", ch, null, exit.Keyword, SocketConnection.MessageTarget.character);
                    else if (exit.HasFlag(Exit.ExitFlag.blocked))
                        SocketConnection.Act("The $d is blocked.", ch, null, exit.Keyword, SocketConnection.MessageTarget.character);
                }
                // If exit found, don't keep looking.
                return;
            }

            // Look inside something ('look in').
            if (inside)
            {
                // 'look in'
                if (args.Count < 1)
                {
                    ch.SendText("Look in what?\r\n");
                    return;
                }

                obj = ch.GetObjHere(args[0]);
                if (!obj)
                {
                    ch.SendText("You do not see that here.\r\n");
                    return;
                }

                switch (obj.ItemType)
                {
                    default:
                        ch.SendText("That is not a container.\r\n");
                        break;

                    case ObjTemplate.ObjectType.drink_container:
                        if (obj.Values[1] == -1)
                        {
                            ch.SendText("It is full.\r\n");
                            break;
                        }

                        if (obj.Values[1] <= 0)
                        {
                            ch.SendText("It is empty.\r\n");
                            break;
                        }

                        output += "It's ";
                        if (obj.Values[1] < obj.Values[0] / 4)
                            output += "less than half";
                        else if (obj.Values[1] < (3 * obj.Values[0] / 4))
                            output += "about half";
                        else if (obj.Values[1] < obj.Values[0])
                            output += "more than half";
                        else
                            output += "completely";
                        output += " full of a " + Liquid.Table[obj.Values[2]].Color + "liquid.\r\n";

                        ch.SendText(output);
                        break;

                    case ObjTemplate.ObjectType.quiver:
                    case ObjTemplate.ObjectType.container:
                    case ObjTemplate.ObjectType.npc_corpse:
                    case ObjTemplate.ObjectType.pc_corpse:
                        if (Macros.IsSet(obj.Values[1], ObjTemplate.CONTAINER_CLOSED.Vector))
                        {
                            ch.SendText("It is closed.\r\n");
                            break;
                        }

                        SocketConnection.Act("$p&n contains:", ch, obj, null, SocketConnection.MessageTarget.character, true);
                        Look.ShowListToCharacter(obj.Contains, ch, true, true);
                        break;
                    case ObjTemplate.ObjectType.portal:
                        SocketConnection.Act("A $p&n leads to:", ch, obj, null, SocketConnection.MessageTarget.character);
                        output += Room.GetRoom(obj.Values[0]).Title + "\r\n";
                        output += Room.GetRoom(obj.Values[0]).Description;
                        output += "\r\n";
                        ch.SendText(output);
                        break;
                }
                return;
            }

            // Look at another char.
            if (args.Count > 0)
            {
                CharData victim = ch.GetCharRoom(args[0]);
                if (victim != null)
                {
                    Look.ShowCharacterToCharacterFull(victim, ch);
                    return;
                }
            }

            // Look at an object.
            if (args.Count > 0)
            {
                // Check inventory.
                obj = ch.GetObjCarrying(args[0]);
                // If not in inventory, check eq.
                if (obj == null)
                    obj = ch.GetObjWear(args[0]);
                // If not on character, check room.
                if (obj == null)
                    obj = Object.GetObjFromList(ch._inRoom.Contents, ch, args[0]);
                // If object found, show it to the char.
                if (obj != null)
                {
                    pdesc = (Database.GetExtraDescription(args[0], obj.ExtraDescription));
                    if (pdesc.Length != 0)
                    {
                        ch.SendText(pdesc);
                    }
                    else if ((pdesc = (Database.GetExtraDescription(args[0], obj.ObjIndexData.ExtraDescriptions))).Length > 0)
                    {
                        ch.SendText(pdesc);
                    }
                    else if (obj.FullDescription.Length > 0)
                    {
                        ch.SendText(obj.FullDescription);
                        ch.SendText("\r\n");
                    }
                    if (obj.HasAffect(Affect.AffectType.skill, "poison weapon"))
                    {
                        if (ch.IsClass(CharClass.Names.thief) || ch.IsClass(CharClass.Names.assassin)
                                || MUDMath.NumberPercent() < ch.GetCurrInt() / 2)
                            ch.SendText("It has a &+Gsickly &+Lcolored&n hue.\r\n");
                    }
                    return;
                }
            }

            // Look at an object in the room
            if (args.Count > 0)
            {
                int count = 0;
                foreach (Object iobj in ch._inRoom.Contents)
                {
                    if (CharData.CanSeeObj(ch, iobj))
                    {
                        pdesc = (Database.GetExtraDescription(args[0], iobj.ExtraDescription));
                        if (pdesc.Length != 0)
                        {
                            if (++count == number)
                            {
                                ch.SendText(pdesc);
                                return;
                            }
                            continue;
                        }
                        pdesc = (Database.GetExtraDescription(args[0], iobj.ObjIndexData.ExtraDescriptions));
                        if (pdesc.Length != 0)
                        {
                            if (++count == number)
                            {
                                ch.SendText(pdesc);
                                return;
                            }
                            continue;
                        }
                        if (MUDString.NameContainedIn(args[0], iobj.Name))
                        {
                            if (++count == number)
                            {
                                ch.SendText(iobj.FullDescription);
                                ch.SendText("\r\n");
                                return;
                            }
                            continue;
                        }
                    }
                }
            }

            // Check for room extra descriptions
            if (args.Count > 0)
            {
                pdesc = (Database.GetExtraDescription(args[0], ch._inRoom.ExtraDescriptions));
                if (!String.IsNullOrEmpty(pdesc))
                {
                    ch.SendText(pdesc);
                    return;
                }
            }

            ch.SendText("You do not see that here.\r\n");
            return;
        }

        /// <summary>
        /// Like look, but more detailed.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Examine(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (str.Length == 0)
            {
                ch.SendText("&nWhat do you wish to examine?\r\n");
                return;
            }

            CommandType.Interpret(ch, "look " + str[0]);

            Object obj = ch.GetObjHere(str[0]);
            if (obj)
            {
                // Show material and condition.
                string text = String.Format("It appears to be made of {0}&n and is of {1} craftsmanship.\r\n",
                                            Material.Table[(int)obj.Material].Name, ObjTemplate.CraftsmanshipString(obj.Craftsmanship));
                ch.SendText(text);
                text = String.Format("It is in {0} percent condition.\r\n", obj.Condition);
                ch.SendText(text);
                if (obj.HasFlag(ObjTemplate.ITEM_NOSELL))
                {
                    text = String.Format("It doesn't appear to be worth much.\r\n", obj.Condition);
                    ch.SendText(text);
                }
                switch (obj.ItemType)
                {
                    default:
                        break;
                    case ObjTemplate.ObjectType.drink_container:
                    case ObjTemplate.ObjectType.container:
                    case ObjTemplate.ObjectType.quiver:
                    case ObjTemplate.ObjectType.npc_corpse:
                    case ObjTemplate.ObjectType.pc_corpse:
                    case ObjTemplate.ObjectType.storage_chest:
                        ch.SendText("\r\n&nWhen you look inside, you see:\r\n");
                        ch.LookInContainer(str[0], false);
                        break;
                    case ObjTemplate.ObjectType.weapon:
                        text = String.Format("It is a weapon of type {0}.\r\n", ((ObjTemplate.WeaponType)(obj.Values[0])));
                        ch.SendText(text);
                        break;
                    case ObjTemplate.ObjectType.shield:
                        ch.SendText("&nIt is ");
                        if (obj.Values[5] > 0)
                            ch.SendText("\r\n&nIt is &+Lspiked&n.");
                        //buf = String.Format(  "{0}, and {1} in size.&n\r\n",
                        //  shield_thickness_string(obj.value[4]), shield_size_string(obj.value[2]));
                        //ch.SendText( buf );
                        break;
                    case ObjTemplate.ObjectType.armor:
                        text = String.Format("It can be worn on the {0}.", StringConversion.WearString(obj));
                        ch.SendText(text);
                        break;
                }

                // Show item level if eq restrictions are in effect - Xangis.
                if (Macros.IsSet((int)Database.SystemData.ActFlags, (int)Sysdata.MudFlags.levelrestrictedeq))
                {
                    if (obj.Level < 10)
                        ch.SendText("This is a piece of newbie equipment.\r\n");
                    else if (obj.Level < 25)
                        ch.SendText("This is a piece of low-level equipment.\r\n");
                    if (obj.Level < 40)
                        ch.SendText("This is a piece of mid-level equipment.\r\n");
                    else
                        ch.SendText("This is a piece of high-level equipment.\r\n");
                }
            }
            return;
        }

        /// <summary>
        /// Shows available room exits.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Exits(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Exit pexit;
            int door;

            bool fAuto = (str.Length != 0 && !MUDString.StringsNotEqual(str[0], "auto"));

            if (ch.IsBlind() || !ch._inRoom)
                return;

            string buf;
            if (!ch.IsNPC() && ch._socket._terminalType == SocketConnection.TerminalType.TERMINAL_ENHANCED && fAuto)
            {
                buf = "<exits>";
            }
            else
            {
                buf = fAuto ? "&+cExits: &n" : "&+cObvious exits:&n\r\n";
            }

            bool found = false;

            // Xangis - made it show the direction with an asterisk if it
            // has a closed door, and in exits command it shows up as a
            // closed <whatever>.  It was silly not to show that a room had
            // doors and such.
            for (door = 0; door < Limits.MAX_DIRECTION; ++door)
            {
                pexit = ch._inRoom.ExitData[door];
                if (pexit && pexit.TargetRoom)
                {
                    if (pexit.HasFlag(Exit.ExitFlag.secret))
                    {
                        /* Mortals do not see secret exits. */
                        if (ch._level < Limits.LEVEL_AVATAR)
                            continue;
                        /* Mark secret exits for immortals. */
                        buf += "&+LS&n&+c";
                    }
                    if (pexit.HasFlag(Exit.ExitFlag.blocked))
                    {
                        /* Mortals do not see secret exits. */
                        if (ch._level < Limits.LEVEL_AVATAR)
                            continue;
                        /* Mark secret exits for immortals. */
                        buf += "&+yB&n&+c";
                    }
                    found = true;
                    if (fAuto)
                    {
                        if (pexit.HasFlag(Exit.ExitFlag.walled) && pexit.HasFlag(Exit.ExitFlag.illusion))
                            continue;
                        if (pexit.HasFlag(Exit.ExitFlag.closed))
                            buf += "&n&+y#&n&+c";
                        // Don't show exits to impassable rooms - Xangis
                        // show a yellow exclamation point to those with holylight on though
                        if (pexit.TargetRoom && pexit.TargetRoom.TerrainType == TerrainType.underground_impassable)
                        {
                            if (!ch.HasActBit(PC.PLAYER_GODMODE))
                                continue;
                            buf += "&+Y!&n";
                        }
                        buf += Exit.DirectionName[door];
                        buf += " ";
                    }
                    else
                    {
                        if (pexit.HasFlag(Exit.ExitFlag.walled))
                        {
                            buf += String.Format("&n{0} - (Walled)&n\r\n",
                                MUDString.PadStr(Exit.DirectionName[door].ToUpper(), 5));
                        }
                        else if (!pexit.HasFlag(Exit.ExitFlag.closed))
                        {
                            // gods with holylight on can go to useless exits.
                            if (pexit.TargetRoom && pexit.TargetRoom.TerrainType == TerrainType.underground_impassable)
                            {
                                if (!ch.HasActBit(PC.PLAYER_GODMODE))
                                    continue;
                                buf += "&+Y!&n";
                            }
                            buf += String.Format("&n {0} - {1}&n\r\n",
                                      MUDString.PadStr(Exit.DirectionName[door].ToUpper(), 5),
                                      (!ch.HasInnate(Race.RACE_ULTRAVISION)
                                        && Room.GetRoom(pexit.IndexNumber).IsDark())
                                      ? "&nToo dark to tell" : pexit.TargetRoom.Title);
                        }
                        else
                        {
                            buf += String.Format("&+y#&n{0} - Closed {1}\r\n",
                                MUDString.PadStr(Exit.DirectionName[door].ToUpper(), 5), pexit.Keyword);
                        }
                    }
                }
            }

            if (!found)
                buf += fAuto ? " none" : "&nNone.\r\n";

            if (!ch.IsNPC() && ch._socket._terminalType == SocketConnection.TerminalType.TERMINAL_ENHANCED && fAuto)
            {
                buf += "&n</exits>";
            }
            else if (fAuto)
            {
                buf += "&n\r\n";
            }

            ch.SendText(buf);
            return;
        }

        /// <summary>
        /// Shows a character's score screen.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Score(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string text = String.Empty;

            if (ch == null)
            {
                Log.Error("Command.Score(): null ch.", 0);
                return;
            }

            Affect prev;

            text += "&+WName: &+G" + ch._name + "&n" + (ch.IsNPC() ? String.Empty : ((PC)ch).Title) + "\r\n";
            text += "&+WRace:&n " + MUDString.PadStr(Race.RaceList[ch.GetRace()].ColorName, 16);
            text += "&+WClass:&n " + MUDString.PadStr(ch._charClass.WholistName, 32) + "&n\r\n";
            text += "&+WLevel: " + MUDString.PadInt(ch._level, 5) + "     Played: " + (ch._played.Hours) + " hours       &+WSex: ";
            text += System.Threading.Thread.CurrentThread.CurrentCulture.TextInfo.ToTitleCase(ch.GetSexString()) + "\r\n";
            if (ch._fighting == null)
            {
                text += "&+WExperience: &+B" + StringConversion.ExperienceString(ch) + "&n\r\n\r\n";
            }
            text += "&+WCurrent/Max Health: [&n&+g" + MUDString.PadInt(ch._hitpoints, 5) + "&+W / &n&+g" + MUDString.PadInt(ch.GetMaxHit(), 5);
            text += "&+W]     Coins:     Carried     In Bank\r\n";
            text += "&+WCurrent/Max Moves:  [&n&+g" + MUDString.PadInt(ch._currentMoves, 5) + "&+W / &n&+g" + MUDString.PadInt(ch._maxMoves, 5);
            text += "&+W]     &+WPlatinum      " + MUDString.PadInt(ch.GetPlatinum(), 5) + "        ";
            text += (ch.IsNPC() ? 0 : ((PC)ch).Bank.Platinum) + "\r\n";
            text += "Current/Max Mana:   [&n&+g" + MUDString.PadInt(ch._currentMana, 5) + "&+W / &n&+g" + MUDString.PadInt(ch._maxMana, 5);
            text += "&+W]     &+YGold          " + MUDString.PadInt(ch.GetGold(), 5) + "        " + (ch.IsNPC() ? 0 : ((PC)ch).Bank.Gold) + "\r\n";
            text += "                                        &n&+wSilver        " + MUDString.PadInt(ch.GetSilver(), 5) + "        ";
            text += (ch.IsNPC() ? 0 : ((PC)ch).Bank.Silver) + "\r\n";
            text += "&+WFrags: &+W" + MUDString.PadInt((ch.IsNPC() ? 0 : ((PC)ch).Frags), 3) + "&n                               &n&+yCopper        ";
            text += MUDString.PadInt(ch.GetCopper(), 5) + "        " + (ch.IsNPC() ? 0 : ((PC)ch).Bank.Copper) + "\r\n";
            if (!ch.IsNPC())
            {
                text += "&+WTotal Deaths: &+W" + MUDString.PadInt(((PC)ch).MobDeaths + ((PC)ch).PlayerDeaths, 5) + "&n     &+WMobs Killed: &+W";
                text += MUDString.PadInt(((PC)ch).MobKills, 5) + "&n\r\n&+WPlayers Killed: &+W" + MUDString.PadInt(((PC)ch).PlayerKills, 5);
                text += "&n   &+WPlayer Deaths: &+W" + MUDString.PadInt(((PC)ch).PlayerDeaths, 5) + "&n\r\n";
            }

            if (!ch.IsNPC())
            {
                int divisor = ((PC)ch).Created.Quantity;
                if (divisor == 0)
                    divisor = 1;
                text += String.Format("&+WItems Created: &n{0}    &+WTotal Value: &n{1}  &+WBest: &n{2}  &+WAvg: &n{3}\r\n",
                    MUDString.PadInt(((PC)ch).Created.Quantity, 5),
                    MUDString.PadInt(((PC)ch).Created.TotalCost, 5),
                    MUDString.PadInt(((PC)ch).Created.MaxCost, 5),
                    MUDString.PadInt((((PC)ch).Created.TotalCost / divisor), 5));
                divisor = ((PC)ch).Destroyed.Quantity;
                if (divisor == 0)
                    divisor = 1;
                text += String.Format("&+WItems Destroyed: &n{0}  &+WTotal Value: &n{1}  &+WBest: &n{2}  &+WAvg: &n{3}\r\n",
                    MUDString.PadInt(((PC)ch).Destroyed.Quantity, 5),
                    MUDString.PadInt(((PC)ch).Destroyed.TotalCost, 5),
                    MUDString.PadInt(((PC)ch).Destroyed.MaxCost, 5),
                    MUDString.PadInt((((PC)ch).Destroyed.TotalCost / divisor), 5));
            }

            if (!ch.IsNPC())
            {
                text += "&+WTotal Score: &+W" + ((PC)ch).Score + "&n\r\n";
            }

            if (ch.IsClass(CharClass.Names.monk) || ch.IsClass(CharClass.Names.mystic))
            {
                text += "&+WTradition: &+B" + TraditionData.Names[((PC)ch).Tradition] + "&n\r\n";
                text += "&+WTraining Points: &+B" + (ch.IsNPC() ? 0 : ((PC)ch).SkillPoints) + "&n\r\n";
            }

            if (ch._followers != null && ch._followers.Count > 0)
            {
                text += "&+BFollowers:&n\r\n";
                foreach (CharData follower in ch._followers)
                {
                    if (follower == null)
                    {
                        continue;
                    }
                    text += follower.ShowNameTo(ch, true) + " &n\r\n";
                }
                text += "\r\n";
            }
            if (ch.IsAffected( Affect.AFFECT_POISON))
            {
                text += "&+GYou are poisoned.&n\r\n";
            }

            if ((ch.IsAffected( Affect.AFFECT_DETECT_MAGIC) || ch.IsImmortal())
                    && MUDString.StringsNotEqual(BitvectorFlagType.AffectString(ch._affectedBy, true), "none"))
            {
                text += "&+BEnchantments: &+W" + BitvectorFlagType.AffectString(ch._affectedBy, true) + "&n\r\n\r\n";
            }

            if (ch._affected != null)
            {
                bool printed = false;
                prev = null;
                foreach (Affect paf in ch._affected)
                {
                    if (!printed)
                    {
                        text += "&+BActive Spells:&+W\r\n";
                        printed = true;
                    }

                    /* Show only new affects to mortals. */
                    if (prev != null && prev.Value == paf.Value
                            && prev.Type == paf.Type && !ch.IsImmortal())
                    {
                        prev = paf;
                        continue;
                    }
                    prev = paf;

                    if (paf.Type == Affect.AffectType.skill && !String.IsNullOrEmpty(paf.Value) && ch.IsImmortal())
                    {
                        text += MUDString.CapitalizeANSIString( Skill.SkillList[paf.Value].Name );
                    }
                    else if (paf.Type == Affect.AffectType.skill && !String.IsNullOrEmpty(paf.Value))
                    {
                        continue;
                    }
                    else if (paf.Type == Affect.AffectType.spell && !String.IsNullOrEmpty(paf.Value))
                    {
                        text += MUDString.CapitalizeANSIString(Spell.SpellList[paf.Value].Name);
                    }
                    else if (paf.Type == Affect.AffectType.song && !String.IsNullOrEmpty(paf.Value))
                    {
                        text += MUDString.CapitalizeANSIString(paf.Value);
                    }
                    else
                    {
                        text += "Something";
                    }

                    if (ch.IsImmortal())
                    {
                        foreach (AffectApplyType apply in paf.Modifiers)
                        {
                            text += " modifies " + StringConversion.AffectApplyString(apply.Location) + " by " + apply.Amount;
                        }
                        text += " for " + paf.Duration + " hours with bits " + paf.AffectString(false) + ".\r\n";
                    }
                    else
                    {
                        if (paf.Duration == 0 && ch.IsAffected( Affect.AFFECT_DETECT_MAGIC))
                        {
                            text += " (fading rapidly)\r\n";
                        }
                        else if (paf.Duration == 1 && ch.IsAffected( Affect.AFFECT_DETECT_MAGIC))
                        {
                            text += " (fading)\r\n";
                        }
                        else
                        {
                            text += "\r\n";
                        }
                    }
                }
            }
            text += "&n";
            ch.SendText(text);
            return;
        }

        /// <summary>
        /// Shows a character's attribute screen.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Attributes(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string buf1 = String.Empty;

            if (ch.IsNPC())
            {
                ch.SendText("&nYour attributes are as would be expected for an NPC.\r\n");
                return;
            }

            if (ch.IsImmortal() && str.Length != 0)
            {
                CharData wch = ch.GetCharWorld(str[0]);
                if (!wch)
                {
                    ch.SendText("No such person.\r\n");
                    return;
                }
                if (wch.IsNPC())
                {
                    ch.SendText("NPCs don't have skills!\r\n");
                    return;
                }
            }

            string buf = String.Format(
                "&+WName: &+G{0}&n    &+WLevel: {1}&n\r\n",
                MUDString.PadStr(ch._name, 17),
                ch._level);
            buf1 += buf;

            buf = String.Format(
                      "&+WRace:&n {0}          &+WClass:&n {1}     &n&+WSex:&n {2}\r\n",
                      MUDString.PadStr(Race.RaceList[ch.GetRace()].ColorName, 16),
                      MUDString.PadStr(ch._charClass.WholistName, 16),
                      System.Threading.Thread.CurrentThread.CurrentCulture.TextInfo.ToTitleCase(ch.GetSexString()));
            buf1 += buf;

            // Break a player's size into strings when we get around to it
            // -- Xangis
            if (!ch.IsNPC())
            {
                buf = String.Format(
                          "&+WHeight:&n {0} inches         &+WWeight:&n {1} pounds    &+WSize:&n {2}\r\n",
                          MUDString.PadInt(((PC)ch).Height, 3),
                          MUDString.PadInt(((PC)ch).Weight, 5),
                          Race.SizeString(ch._size));
            }
            else
            {
                buf = String.Format("&+WSize:&n  {0}\r\n", ch._size);
            }
            buf1 += buf;

            TimeSpan time = TimeSpan.FromTicks(ch._played.Ticks) + (DateTime.Now - ch._logon);
            int days = (int)time.TotalHours / 24;
            time = (time - TimeSpan.FromDays(days));
            int hours = (int)time.TotalHours;
            time = (time - TimeSpan.FromHours(hours));
            int minutes = (int)time.TotalMinutes;

            // Age is a hack until we get it coded - Xangis
            buf = String.Format(
                      "\r\n&+BAge:&n {0} years.             &+BPlaying Time:&n {1} days {2} hours {3} minutes.\r\n",
                      MUDString.PadInt(ch.GetAge(), 3), days, hours, minutes);
            buf1 += buf;

            // Need to create a function to display character status strings
            buf = String.Format("&+BStatus:&n  {0}", System.Threading.Thread.CurrentThread.CurrentCulture.TextInfo.ToTitleCase(Position.PositionString(ch._position)));
            if (!ch.IsNPC() && ch.IsAffected(Affect.AFFECT_BERZERK))
            {
                buf += ", &+Rberzerk&n";
            }
            if (!ch.IsNPC() && ch.HasActBit(PC.PLAYER_MEMORIZING))
            {
                buf += ", Memorizing";
            }
            if (ch.IsAffected(Affect.AFFECT_CASTING))
            {
                buf += ", Casting";
            }
            if (ch.IsAffected(Affect.AFFECT_SINGING))
            {
                buf += ", Singing";
            }
            if (!ch.IsNPC() && ch.HasActBit(PC.PLAYER_MEDITATING))
            {
                buf += ", Meditating";
            }
            if (!ch.IsNPC() && ch.HasActBit(PC.PLAYER_CAMPING))
            { /* This is ugly and should be moved to its own function */
                buf += ", Camping";
            }
            buf += ".\r\n\r\n";
            buf1 += buf;

            // We want players to see the same stats for levels 1-50.

            // Should create string converters so that we have no decimals displayed
            // below this point.
            buf = String.Format("     &+cSTR:&n  {0}      &+cArmor Class:&n {1}.\r\n",
                      MUDString.PadStr(StringConversion.AbilityScoreString(ch.GetCurrStr()), 15), ch.GetAC());
            buf1 += buf;
            buf = String.Format("     &+cAGI:&n  {0}      &+cHitroll:&n     {1}\r\n",
                      MUDString.PadStr(StringConversion.AbilityScoreString(ch.GetCurrAgi()), 15), StringConversion.BonusString(ch.GetHitroll(ObjTemplate.WearLocation.hand_one)));
            buf1 += buf;
            buf = String.Format("     &+cDEX:&n  {0}      &+cDamroll:&n     {1}\r\n",
                      MUDString.PadStr(StringConversion.AbilityScoreString(ch.GetCurrDex()), 15), StringConversion.BonusString(ch.GetDamroll(ObjTemplate.WearLocation.hand_one)));
            buf1 += buf;
            buf = String.Format("     &+cCON:&n  {0}      &+cAlignment:&n   {1}\r\n",
                      MUDString.PadStr(StringConversion.AbilityScoreString(ch.GetCurrCon()), 15), StringConversion.AlignmentString(ch));
            buf1 += buf;
            buf = String.Format("     &n&+cINT:&n  {0}\r\n", MUDString.PadStr(StringConversion.AbilityScoreString(ch.GetCurrInt()), 15));
            buf1 += buf;
            buf = String.Format("     &+cWIS:&n  {0}      &+BSaving Throws&n\r\n",
                      MUDString.PadStr(StringConversion.AbilityScoreString(ch.GetCurrWis()), 15));
            buf1 += buf;
            buf = String.Format("     &+cPOW:&n  {0}      &+cParalysis:&n {1}\r\n",
                      MUDString.PadStr(StringConversion.AbilityScoreString(ch.GetCurrPow()), 15), StringConversion.BonusString(-ch._savingThrows[0]));
            buf1 += buf;
            buf = String.Format("     &+cCHA:&n  {0}      &+cRod:&n       {1}\r\n",
                      MUDString.PadStr(StringConversion.AbilityScoreString(ch.GetCurrCha()), 15), StringConversion.BonusString(-ch._savingThrows[1]));
            buf1 += buf;
            buf = String.Format("     &+cLUK:&n  {0}      &+cPetrify:&n   {1}\r\n",
                      MUDString.PadStr(StringConversion.AbilityScoreString(ch.GetCurrLuck()), 15), StringConversion.BonusString(-ch._savingThrows[2]));
            buf1 += buf;

            buf = String.Format("                                &+cBreath:&n    {0}\r\n",
                      StringConversion.BonusString(-ch._savingThrows[3]));
            buf1 += buf;

            buf = String.Format("&+BWimpy:        &n{0}               &+cSpell:&n     {1}\r\n",
                      MUDString.PadInt(ch._wimpy, 4), StringConversion.BonusString(-ch._savingThrows[4]));
            buf1 += buf;

            buf = String.Format("&+BLoad Carried: &n{0} pounds ({1})\r\n",
                      MUDString.PadInt(ch._carryWeight, 3), StringConversion.WeightString(ch));
            buf1 += buf;

            ch.SendText(buf1);
            return;
        }

        /// <summary>
        /// Shows current experience point progress.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Experience(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch._fighting || (ch._position == Position.fighting))
            {
                ch.SendText("&nEnd the fight first!\r\n");
                return;
            }

            ch.SendText( "&+B" + StringConversion.ExperienceString(ch) + "&n\r\n");
        }

        /// <summary>
        /// Displays game time.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Time(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string suf;

            int day = Database.SystemData.GameDay + 1;

            if (day > 4 && day < 20)
                suf = "th";
            else if (day % 10 == 1)
                suf = "st";
            else if (day % 10 == 2)
                suf = "nd";
            else if (day % 10 == 3)
                suf = "rd";
            else
                suf = "th";

            string text = String.Format(
                "&nIt is {0} o'clock {1}, Day of {2}, {3}{4} the Month of {5}.\r\n&nThe game year is {6}.\r\n",
                (Database.SystemData.GameHour % 12 == 0) ? 12 : Database.SystemData.GameHour % 12,
                Database.SystemData.GameHour >= 12 ? "pm" : "am",
                Database.SystemData.DayName[day % Limits.DAYS_PER_WEEK],
                day, suf,
                Database.SystemData.MonthName[Database.SystemData.GameMonth],
                Database.SystemData.GameYear);
            ch.SendText(text);
            text = String.Format(
                      Database.SystemData.MudAnsiName + " started up {0}.\r\nThe system time is {1}.\r\nTotal uptime is {2}.\r\n",
                      Database.SystemData.GameBootTime,
                      Database.SystemData.CurrentTime,
                      (Database.SystemData.CurrentTime - Database.SystemData.GameBootTime));
            ch.SendText(text);
            //if( Database.SystemData._shutdownTime > 0 )
            //{
            //    buf = String.Format( "&n{0} will be at {1}\r", Database.Reboot ? "Reboot" : "Shutdown",
            //              ( Database.SystemData._shutdownTime ));
            //    ch.SendText( buf );
            //}
            return;
        }

        /// <summary>
        /// Displays game weather.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Weather(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string descr = String.Empty;
            string[] skyLook = new string[]
            {
                "cloudless",
                "&+Wcloudy&n",
                "&+Brainy&n", // It's brainy outside!
                "lit by flashes of &+Cli&n&+cg&+Ch&n&+ctn&+Ci&n&+cn&+Cg&n",
                "slightly &n&+wovercast&n",
                "scattered with a few &+Wflakes&n",
                "filled with &+Wflakes&n",
                "a &+Wblizzard&n of white"
            };

            if (!ch.IsOutside())
            {
                ch.SendText("&nYou can't see the weather indoors.\r\n");
                return;
            }

            int wind = Database.SystemData.WeatherData.WindSpeed;
            if (!ch.IsUnderground())
            {
                string text = String.Format("&nThe sky is {0}",
                                            (Database.SystemData.GameMonth <= 4 || Database.SystemData.GameMonth >= 15)
                                                ? skyLook[(int)Database.SystemData.WeatherData.Sky + 4]
                                                : skyLook[(int)Database.SystemData.WeatherData.Sky]);
                descr += text;
                if (Database.SystemData.WeatherData.Sunlight == SunType.moonrise)
                {
                    switch (Database.SystemData.WeatherData.MoonPhase)
                    {
                        default:
                            break;
                        case Sysdata.MoonPhase.new_moon:
                            break;
                        case Sysdata.MoonPhase.quarter:
                            text = String.Format(", there is a quarter moon,");
                            descr += text;
                            break;
                        case Sysdata.MoonPhase.half:
                            text = String.Format(", there is a half moon,");
                            descr += text;
                            break;
                        case Sysdata.MoonPhase.three_quarter:
                            text = String.Format(", the moon is in the third quarter,");
                            descr += text;
                            break;
                        case Sysdata.MoonPhase.full:
                            text = String.Format(", the moon is full,");
                            descr += text;
                            break;
                    }
                }

                string tempWord = String.Empty;
                if (Database.SystemData.WeatherData.Temperature < 25)
                {
                    tempWord = "bone-chilling";
                }
                else if (Database.SystemData.WeatherData.Temperature < 40)
                {
                    tempWord = "cold";
                }
                else if (Database.SystemData.WeatherData.Temperature < 60)
                {
                    tempWord = "cool";
                }
                else if (Database.SystemData.WeatherData.Temperature < 85)
                {
                    tempWord = "warm";
                }
                else
                {
                    tempWord = "hot";
                }

                text = String.Format("&n and a {0} {1}ward {2} blows.\r\n",
                          tempWord,
                          Exit.DirectionName[Math.Abs(Database.SystemData.WeatherData.WindDirection) % 3],
                          wind <= 20 ? "breeze" :
                          wind <= 45 ? "wind" :
                          wind <= 70 ? "gust" :
                          "torrent");
                descr += text;
            }
            else
            {
                descr = String.Format("There isn't a whole lot of weather underground.\r\n");
            }

            ch.SendText(descr);
            return;
        }

        /// <summary>
        /// Checks the help files for the requested help entry and displays it if available.  Checks for exact
        /// matches before trying to match the first keyword.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void HelpCommand(CharData ch, string[] str)
        {
            if( ch == null ) return;

            bool found = false;
            String query = String.Join(" ", str);

            if (ch == null)
            {
                Log.Error("Help: Called with null ch.", 0);
                return;
            }

            if (str.Length < 1 || str[0] == "commands")
            {
                Commands(ch, new [] { String.Empty } );
                return;
            }

            // Try for exact matches first.
            foreach (Help help in Database.HelpList)
            {
                if (query.Equals(help.Keyword, StringComparison.CurrentCultureIgnoreCase))
                {
                    ch.SendText(help.ToString());
                    return;
                }
            }

            // Try for partial matches next.
            foreach (Help help in Database.HelpList)
            {
                if (help.MinimumLevel > ch.GetTrust())
                {
                    continue;
                }

                string[] keywords = help.Keyword.Split(' ');
                foreach( string key in keywords )
                {
                    if (key.StartsWith(str[0], StringComparison.CurrentCultureIgnoreCase))
                    {
                        if (found)
                        {
                            ch.SendText("----------------------------------------------------------------------------\r\n");
                        }

                        ch.SendText(help.ToString());
                        found = true;
                        break;
                    }
                }
            }

            if (!found)
            {
                string message = String.Format("Could not find help on '{0}'.  You can ask us to create a help entry for that topic by typing 'requesthelp {0}'.\r\n", str[0]);

                ch.SendText(message + "\r\n");
            }
            return;
        }

        /// <summary>
        /// Displays the "who list" based on provided paramters.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Who(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch._fighting || (ch._position == Position.fighting))
            {
                ch.SendText("&nEnd the fight first!\r\n");
                return;
            }

            // Set racewar side to check
            Race.RacewarSide rws; // for RaceWarSide wholist
            if (ch.IsImmortal())
            {
                rws = Race.RacewarSide.neutral;
            }
            else
            {
                rws = ch.GetRacewarSide();
            }

            // Initialize races and classes to false.
            bool[] rgfClass = new bool[CharClass.ClassList.Length];
            bool[] rgfRace = new bool[Limits.MAX_PC_RACE];
            int iClass;
            int iRace;
            for (iClass = 0; iClass < CharClass.ClassList.Length; ++iClass)
                rgfClass[iClass] = false;
            for (iRace = 0; iRace < Limits.MAX_PC_RACE; ++iRace)
                rgfRace[iRace] = false;

            // Handle command arguments.
            int iLevelLower = 0;
            int iLevelUpper = Limits.MAX_LEVEL;
            int numbers = 0;
            bool immortalOnly = false;
            bool sorted = false; /* for sorted list */
            bool fClassRestrict = false;
            bool fRaceRestrict = false;
            string name = String.Empty;

            for (int i = 0; i < str.Length; i++ )
            {
                // Level numbers.
                if (MUDString.IsNumber(str[i]))
                {
                    switch (++numbers)
                    {
                        case 1:
                            Int32.TryParse(str[i], out iLevelLower);
                            break;
                        case 2:
                            Int32.TryParse(str[i], out iLevelUpper);
                            break;
                        default:
                            ch.SendText("&nOnly two level numbers allowed.\r\n");
                            return;
                    }
                }
                else
                {
                    // Look for classes to turn on.
                    if (!MUDString.IsPrefixOf(str[i], "immortals"))
                    {
                        immortalOnly = true;
                    }
                    else
                        if (!MUDString.IsPrefixOf(str[i], "sort"))
                        {
                            sorted = true;
                        }
                        else if (ch.IsImmortal() && !MUDString.IsPrefixOf(str[i], "good"))
                        {
                            rws = Race.RacewarSide.good;
                        }
                        else if (ch.IsImmortal() && !MUDString.IsPrefixOf(str[i], "evil"))
                        {
                            rws = Race.RacewarSide.evil;
                        }
                        else
                        {
                            int iClass2;
                            for (iClass2 = 0; iClass2 < CharClass.ClassList.Length; ++iClass2)
                            {
                                if (!MUDString.IsPrefixOf(str[i], CharClass.ClassList[iClass2].Name))
                                {
                                    rgfClass[iClass2] = true;
                                    fClassRestrict = true;
                                    break;
                                }
                            }

                            for (iRace = 0; iRace < Limits.MAX_PC_RACE; ++iRace)
                            {
                                if (!MUDString.IsPrefixOf(str[i], Race.RaceList[iRace].Name))
                                {
                                    rgfRace[iRace] = true;
                                    fRaceRestrict = true;
                                    break;
                                }
                            }

                            if (iClass2 == CharClass.ClassList.Length && iRace == Limits.MAX_PC_RACE)
                                name = str[i];
                        }
                }
            }

            // Now show characters that match our parameters.          
            int nMatch = 0;
            List<String> immortals = new List<String>();
            List<String> mortals = new List<String>();
            /* Limits.L_DIR; Used to be Max_level.. Why change this? */
            string text = String.Empty;
            int temp;
            int numPlayers = 0;
            for (temp = 0; temp <= Limits.MAX_LEVEL; ++temp)
            { /* for sorted list */
                foreach (SocketConnection socket in Database.SocketList)
                {
                    string cclass;

                    CharData wch = (socket.Original != null) ? socket.Original : socket.Character;

                    /*
                    * Check for match against restrictions.
                    * Don't use trust as that exposes trusted mortals.
                    */
                    if (socket._connectionState != SocketConnection.ConnectionState.playing || !CharData.CanSee(ch, wch))
                        continue;

                    if (name.Length == 0)
                    {
                        /* Outside level/class restrictions. */
                        if ((wch._level < iLevelLower) || (wch._level > iLevelUpper)
                                || (fClassRestrict && !rgfClass[(int)wch._charClass.ClassNumber])
                                || (fRaceRestrict && !rgfRace[wch.GetRace()]))
                            continue;
                        if (sorted != false && (wch._level != temp))
                            continue;
                        /* Imm only . skip non-immortals. */
                        if (immortalOnly && !wch.IsImmortal())
                            continue;
                    }
                    else if (!MUDString.NameContainedIn(wch._name, name) || (wch._level != temp && sorted != false))
                        continue;

                    /* Opposite racewar sides, and both chars are mortals. */
                    if (wch.GetRacewarSide() != rws && rws != Race.RacewarSide.neutral && !wch.IsImmortal())
                        continue;

                    nMatch++;

                    /*
                    * Figure out what to print for class.
                    */
                    if (wch._level >= Limits.LEVEL_HERO)
                    {
                        switch (wch._level)
                        {
                            default:
                                cclass = "&+yUnknown    &n";
                                break;
                            case Limits.LEVEL_OVERLORD:
                                cclass = "&+r Overlord  &n";
                                break;
                            case Limits.LEVEL_GREATER_GOD:
                                cclass = "&+mGreater God&n";
                                break;
                            case Limits.LEVEL_LESSER_GOD:
                                cclass = "&+MLesser God &n";
                                break;
                            case Limits.LEVEL_DEMIGOD:
                                cclass = "&+y  Demigod  &n";
                                break;
                            case Limits.LEVEL_AVATAR:
                                cclass = "&+R  Avatar   &n";
                                break;
                            case Limits.LEVEL_HERO:
                                cclass = "&+c   Hero    &n";
                                break;
                        }
                    }
                    else
                    {
                        cclass = wch._charClass.WholistName;
                    }

                    /*
                    * Format it up.
                    */
                    if (!wch.IsImmortal())
                    {
                        string buf5 = String.Format("{0}{1}{2}{3}{4} {5} ({6})",
                                                    wch.HasActBit(PC.PLAYER_BOTTING) ? "[BOT] " : String.Empty,
                                                    wch.HasActBit(PC.PLAYER_AFK) ? "[AFK] " : String.Empty,
                                                    wch.IsAffected(Affect.AFFECT_INVISIBLE) ? "*" : String.Empty,
                                                    wch._name,
                                                    ((PC)wch).Title,
                                                    !wch.IsGuild() ? String.Empty : ((PC)wch).Clan.WhoName,
                                                    Race.RaceList[wch.GetRace()].ColorName);
                        text = String.Format("&+L[&n{0} {1}&+L]&n {2}\r\n",
                                  MUDString.PadInt(wch._level, 2),
                                  MUDString.PadStr(cclass, 13),
                                  buf5);
                    }
                    else
                    {
                        string buf1 = String.Format("{0}{1}{2}{3}{4}",
                                                     wch.HasActBit(PC.PLAYER_WIZINVIS) ? "(WIZINVIS) " : String.Empty,
                                                     wch.HasActBit(PC.PLAYER_AFK) ? "[AFK] " : String.Empty,
                                                     wch.HasActBit(PC.PLAYER_BOTTING) ? "[BOT] " : String.Empty,
                                                     wch._name,
                                                     ((PC)wch).Title);
                        string buf2 = String.Format(" {0}", !wch.IsGuild() ? String.Empty : ((PC)wch).Clan.WhoName);
                        text = String.Format("&+L[&n{0}&+L]&n {1}{2}\r\n",
                                  MUDString.PadStr(cclass, 15),
                                  buf1,
                                  buf2);
                    }

                    if (!wch.IsImmortal())
                    {
                        mortals.Add(text);
                    }
                    else
                    {
                        immortals.Add(text);
                    }
                }
                if (sorted == false)
                    break;  /* only do loop once for !sorted */
            }
            // Xangis - made immortals show up above mortals because immortals
            // are more important.
            ch.SendText("\r\n");

            if (immortals.Count > 0)
                ch.SendText("&+b-----------------------------------[ &+BIMMORTALS&+b ]-----------------------------&n\r\n");

            foreach( String who in immortals )
            {
                ch.SendText(who);
            }

            if (mortals.Count > 0)
                ch.SendText("&n&+b------------------------------------[ &+BMORTALS&n&+b ]------------------------------&n\r\n");

            foreach (String who in mortals)
            {
                ch.SendText(who);
            }

            ch.SendText("&n&+b-----------------------------------------------------------------------------&n\r\n");

            foreach (SocketConnection socket in Database.SocketList)
            {
                if (socket._connectionState == SocketConnection.ConnectionState.playing)
                    numPlayers++;
            }

            text = String.Format("&nYou see {0} of {1} player{2} in the game.\r\n",
                      nMatch, numPlayers, numPlayers == 1 ? String.Empty : "s");
            ch.SendText(text);
            return;
        }

        /// <summary>
        /// Shows items currently carried.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Inventory(CharData ch, string[] str)
        {
            if( ch == null ) return;

            ch.SendText("&nYou are carrying:\r\n");
            Look.ShowListToCharacter(ch._carrying, ch, true, true);
            return;
        }

        /// <summary>
        /// Shows items currently worn.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Equipment(CharData ch, string[] str)
        {
            if (ch == null) return;
            Object obj = null;
            String equipmentOpen = String.Empty;
            String equipmentClose = String.Empty;
            String separator = String.Empty;
            if (!ch.IsNPC() && ch._socket._terminalType == SocketConnection.TerminalType.TERMINAL_ENHANCED)
            {
                equipmentOpen = "<equipment>";
                equipmentClose = "</equipment>";
                separator = ":";
            }
            else
            {
                equipmentOpen = "&nYou are using:\r\n";
                separator = "\r\n";
            }
            ch.SendText(equipmentOpen);
            bool found = false;
            foreach (ObjTemplate.WearLocation iWear in ObjTemplate.TopDownEquipment)
            {
                obj = Object.GetEquipmentOnCharacter(ch, iWear);
                if (!obj)
                    continue;

                // Added wielding
                if (obj.ItemType == ObjTemplate.ObjectType.weapon
                        && (iWear == ObjTemplate.WearLocation.hand_one
                             || iWear == ObjTemplate.WearLocation.hand_four
                             || iWear == ObjTemplate.WearLocation.hand_three
                             || iWear == ObjTemplate.WearLocation.hand_two)
                        && obj.HasWearFlag(ObjTemplate.WEARABLE_WIELD))
                {
                    if (obj.HasFlag(ObjTemplate.ITEM_TWOHANDED)
                            && !ch.HasInnate(Race.RACE_EXTRA_STRONG_WIELD))
                    {
                        if (!ch.IsNPC() && ch._socket._terminalType == SocketConnection.TerminalType.TERMINAL_ENHANCED)
                        {
                            ch.SendText(((int)iWear).ToString() + ",");
                        }
                        else
                        {
                            ch.SendText("&+y(wielding twohanded)  &n");
                        }
                    }
                    else
                    {
                        if (!ch.IsNPC() && ch._socket._terminalType == SocketConnection.TerminalType.TERMINAL_ENHANCED)
                        {
                            ch.SendText(((int)iWear).ToString() + ",");
                        }
                        else
                        {
                            ch.SendText("&+y(wielding)            &n");
                        }
                    }
                }
                else
                {
                    if (obj.ItemType == ObjTemplate.ObjectType.shield
                            && (iWear == ObjTemplate.WearLocation.hand_one
                                 || iWear == ObjTemplate.WearLocation.hand_four
                                 || iWear == ObjTemplate.WearLocation.hand_three
                                 || iWear == ObjTemplate.WearLocation.hand_two)
                            && obj.HasWearFlag(ObjTemplate.WEARABLE_SHIELD))
                    {
                        if (!ch.IsNPC() && ch._socket._terminalType == SocketConnection.TerminalType.TERMINAL_ENHANCED)
                        {
                            ch.SendText(((int)iWear).ToString() + ",");
                        }
                        else
                        {
                            ch.SendText("&+y(worn as shield)      &n");
                        }
                    }
                    else
                    {
                        if (!ch.IsNPC() && ch._socket._terminalType == SocketConnection.TerminalType.TERMINAL_ENHANCED)
                        {
                            ch.SendText(((int)iWear).ToString() + ",");
                        }
                        else
                        {
                            ch.SendText(StringConversion.EquipmentLocationDisplay[(int)iWear]);
                        }
                    }
                }
                if (CharData.CanSeeObj(ch, obj))
                {
                    ch.SendText(Look.FormatObjectToCharacter(obj, ch, true));
                    ch.SendText(separator);
                }
                else
                {
                    ch.SendText("&nsomething.\r\n");
                }
                found = true;
            }

            if (!found)
                ch.SendText("&nNothing.\r\n");

            ch.SendText(equipmentClose);

            return;
        }

        /// <summary>
        /// Compares two objects to see which one is better.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Compare(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object obj2 = null;

            if (ch.IsNPC())
                return;

            if (str.Length < 1 || String.IsNullOrEmpty(str[0]))
            {
                ch.SendText("&nCompare what to what?\r\n");
                return;
            }

            Object obj1 = ch.GetObjCarrying(str[0]);
            if (!obj1)
            {
                ch.SendText("&nYou do not have that item.\r\n");
                return;
            }

            if (str.Length < 2 || String.IsNullOrEmpty(str[1]))
            {
                foreach (Object obj3 in ch._carrying)
                {
                    if (obj3.WearLocation != ObjTemplate.WearLocation.none
                            && CharData.CanSeeObj(ch, obj3)
                            && obj1.ItemType == obj3.ItemType
                            && (obj1.WearFlags[0] & obj3.WearFlags[0] & ~ObjTemplate.WEARABLE_CARRY.Vector) != 0)
                    {
                        obj2 = obj3;
                        break;
                    }
                }

                if (!obj2)
                {
                    ch.SendText("&nYou aren't wearing anything comparable.\r\n");
                    return;
                }
            }
            else
            {
                obj2 = ch.GetObjCarrying(str[1]);
                if (!obj2)
                {
                    /*  Strip off number argument, subtrDescriptor._actFlags one, paste it together */
                    int number = MUDString.NumberArgument(str[1], ref str[1]);
                    if (number > 1)
                        number--;
                    string newArg2 = String.Format("{0}.{1}", number, str[1]);

                    obj2 = ch.GetObjWear(newArg2);
                    if (!obj2)
                    {
                        ch.SendText("&nYou do not have that item.\r\n");
                        return;
                    }

                    if ((obj1.WearFlags[0] & obj2.WearFlags[0] & ~ObjTemplate.WEARABLE_CARRY.Vector) == 0)
                    {
                        ch.SendText("&nThey are not comparable items.\r\n");
                        return;
                    }

                }
            }

            string msg = null;
            int value1 = 0;
            int value2 = 0;

            if (obj1 == obj2)
            {
                msg = "You compare $p&n to itself.  It looks about the same.";
            }
            else if (obj1.ItemType != obj2.ItemType)
            {
                msg = "$p&n and $P&n are not the same type of item.";
            }
            else
            {
                switch (obj1.ItemType)
                {
                    default:
                        msg = "You can't compare $p&n and $P&n.";
                        break;
                    
                    case ObjTemplate.ObjectType.trash:
                        msg = "They're both junk.";
                        break;

                    case ObjTemplate.ObjectType.armor:
                    case ObjTemplate.ObjectType.clothing:
                    case ObjTemplate.ObjectType.container:
                    case ObjTemplate.ObjectType.drink_container:
                    case ObjTemplate.ObjectType.food:
                        value1 = obj1.Values[0];
                        value2 = obj2.Values[0];
                        break;

                    case ObjTemplate.ObjectType.spellbook:
                    case ObjTemplate.ObjectType.light:
                        value1 = obj1.Values[2];
                        value2 = obj1.Values[2];
                        break;

                    case ObjTemplate.ObjectType.shield:
                        value1 = obj1.Values[3];
                        value2 = obj2.Values[3];
                        break;

                    case ObjTemplate.ObjectType.treasure:
                        value1 = obj1.Cost;
                        value2 = obj2.Cost;
                        break;

                    case ObjTemplate.ObjectType.weapon:
                        value1 = obj1.Values[1] * obj1.Values[2];
                        value2 = obj2.Values[1] * obj2.Values[2];
                        break;
                }
            }

            if (String.IsNullOrEmpty(msg))
            {
                if (obj2.WearLocation != ObjTemplate.WearLocation.none)
                {
                    if (value1 == value2)
                        msg = "$p&n and $P&n (equipped) look about the same.";
                    else if (value1 > value2)
                        msg = "$p&n looks better than $P&n (equipped).";
                    else
                        msg = "$p&n looks worse than $P&n (equipped).";
                }
                else
                {
                    if (value1 == value2)
                        msg = "$p&n and $P&n look about the same.";
                    else if (value1 > value2)
                        msg = "$p&n looks better than $P&n.";
                    else
                        msg = "$p&n looks worse than $P&n.";
                }
            }

            SocketConnection.Act(msg, ch, obj1, obj2, SocketConnection.MessageTarget.character);
            return;
        }

        public static void Credits(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CommandType.Interpret(ch, "help credits");
            return;
        }

        public static void WherePlayer(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;
            SocketConnection socket;
            string buf;
            bool found;

            if (ch.IsBlind())
                return;

            if (str.Length == 0)
            {
                ch.SendText("&nPlayers near you:\r\n");
                found = false;
                foreach (SocketConnection it in Database.SocketList)
                {
                    socket = it;

                    if (socket._connectionState == SocketConnection.ConnectionState.playing && (victim = socket.Character)
                            && !victim.IsNPC() && victim._inRoom
                            && victim._inRoom.Area == ch._inRoom.Area && CharData.CanSee(ch, victim))
                    {
                        found = true;
                        buf = String.Format("%{0} {1}\r\n",
                                  MUDString.PadStr(victim._name, 28), victim._inRoom.Title);
                        ch.SendText(buf);
                    }
                }
                if (!found)
                    ch.SendText("None\r\n");
            }
            else if (!MUDString.IsPrefixOf(str[0], "all"))
            {
                ch.SendText("&nPlayer locations:\r\n");
                found = false;
                foreach (SocketConnection it in Database.SocketList)
                {
                    socket = it;

                    if (socket._connectionState == SocketConnection.ConnectionState.playing && (victim = socket.Character) && !victim.IsNPC()
                            && victim._inRoom && CharData.CanSee(ch, victim))
                    {
                        found = true;
                        buf = String.Format("{0} [{1}]{2}&n\r\n",
                                  MUDString.PadStr(victim._name, 28),
                                  MUDString.PadInt(victim._inRoom.IndexNumber, 7),
                                  victim._inRoom.Title);
                        ch.SendText(buf);
                    }
                }
                if (!found)
                    ch.SendText("None\r\n");
            }
            else
            {
                found = false;
                foreach (CharData it in Database.CharList)
                {
                    victim = it;
                    if (victim._inRoom.Area == ch._inRoom.Area
                            && CharData.CanSee(ch, victim)
                            && MUDString.NameContainedIn(str[0], victim._name))
                    {
                        found = true;
                        buf = String.Format("{0} {1}\r\n",
                                  MUDString.PadStr(victim.ShowNameTo(ch, true), 28), victim._inRoom.Title);
                        ch.SendText(buf);
                        break;
                    }
                }
                if (!found)
                    SocketConnection.Act("&nYou didn't find any $T.", ch, null, str[0], SocketConnection.MessageTarget.character);
            }

            return;
        }

        /// <summary>
        /// Consider killing a target.  Lets the actor know whether it would be a good idea or not.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Consider(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string msg;

            if (str.Length == 0)
            {
                ch.SendText("&nConsider killing whom?\r\n");
                return;
            }

            CharData victim = ch.GetCharRoom(str[0]);
            if (!victim)
            {
                ch.SendText("&nThey're not here.\r\n");
                return;
            }

            if (victim == ch)
            {
                ch.SendText("Killing yourself?  Try 'suicide confirm'.\r\n");
                return;
            }

            int diff = victim._level - ch._level;

            if (victim.IsAffected( Affect.AFFECT_PROWESS))
                diff += (5 + victim._level / 5);

            if (victim.IsAffected( Affect.AFFECT_INCOMPETENCE))
                diff -= (5 + victim._level / 5);

            if (ch.HasActBit(PC.PLAYER_COLOR_CON))
            {
                if (diff <= -10)
                    msg = "&n&+bToo easy to bother with.&n";
                else if (diff <= -5)
                    msg = "&n&+bYou could do it blindfolded!&n";
                else if (diff <= -2)
                    msg = "&n&+BEasy.&n";
                else if (diff <= -1)
                    msg = "&n&+gFairly easy.&n";
                else if (diff <= 0)
                    msg = "&n&+GAn even fight!&n";
                else if (diff <= 1)
                    msg = "&n&+gYou would need some luck.&n";
                else if (diff <= 2)
                    msg = "&n&+yYou would need a lot of luck!&n";
                else if (diff <= 3)
                    msg = "&n&+YYou would need a lot of luck and great equipment!&n";
                else if (diff <= 5)
                    msg = "&n&+YYou would probably lose that fight.&n";
                else if (diff <= 10)
                    msg = "&n&+RAre you mad!?&n";
                else if (diff <= 15)
                    msg = "&n&+RYou ARE mad!&n";
                else if (diff <= 20)
                    msg = "&n&+rWhy don't you just lie down and pretend you're dead instead?&n";
                else if (diff <= 25)
                    msg = "&n&+rWhat do you want your epitaph to say?!?&n";
                else
                    msg = "&n&+LYou wouldn't last one round of combat!&n";
            }
            else
            {
                if (diff <= -10)
                    msg = "&nToo easy to bother with.&n";
                else if (diff <= -5)
                    msg = "&nYou could do it blindfolded!&n";
                else if (diff <= -2)
                    msg = "&nEasy.&n";
                else if (diff <= -1)
                    msg = "&nFairly easy.&n";
                else if (diff <= 0)
                    msg = "&nAn even fight!&n";
                else if (diff <= 1)
                    msg = "&nYou would need some luck.&n";
                else if (diff <= 2)
                    msg = "&nYou would need a lot of luck!&n";
                else if (diff <= 3)
                    msg = "&nYou would need a lot of luck and great equipment!&n";
                else if (diff <= 5)
                    msg = "&nYou would probably lose that fight.&n";
                else if (diff <= 10)
                    msg = "&nAre you mad!?&n";
                else if (diff <= 15)
                    msg = "&nYou ARE mad!&n";
                else if (diff <= 20)
                    msg = "&nWhy don't you just lie down and pretend you're dead instead?&n";
                else if (diff <= 25)
                    msg = "&nWhat do you want your epitaph to say?!?&n";
                else
                    msg = "&nYou wouldn't last one round of combat!&n";
            }

            SocketConnection.Act(msg, ch, null, victim, SocketConnection.MessageTarget.character);
            SocketConnection.Act("$n&n sizes $N&n up with a quick glance.", ch, null, victim, SocketConnection.MessageTarget.room);
            SocketConnection.Act("$n&n sizes you up with a quick glance.", ch, null, victim, SocketConnection.MessageTarget.victim);
            return;
        }

        public static void Glance(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (str.Length == 0)
            {
                ch.SendText("&nGlance at whom?\r\n");
                return;
            }

            CharData victim = ch.GetCharRoom(str[0]);
            if (!victim)
            {
                ch.SendText("&nThey're not here.\r\n");
                return;
            }

            string msg = String.Format("&nYou glance at $N&n.\r\n$N&n is {0}.", SocketConnection.ConditionString(victim));

            SocketConnection.Act(msg, ch, null, victim, SocketConnection.MessageTarget.character);
            Look.ShowAffectLines(ch, victim);

            return;
        }

        /// <summary>
        /// Set a player's title.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="title"></param>
        public static void SetTitle(CharData ch, string title)
        {
            if( ch == null ) return;

            if (ch.IsNPC())
            {
                ch.SendText("Cant set title on NPCs.\r\n");
                return;
            }

            string buf = " ";

            buf += title + "&n";

            ((PC)ch).Title = buf;
            return;
        }

        /// <summary>
        /// Sets a character's title, cropped to a maximum length to avoid word wrap.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Title(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int point;

            if (!ch || ch.IsNPC())
                return;

            if (str.Length  < 2)
            {
                ch.SendText("&nChange whose title to what?\r\n");
                return;
            }

            CharData victim = ch.GetCharWorld(str[0]);
            if (!victim)
            {
                ch.SendText("&nThat person isn't here.\r\n");
                return;
            }

            if (ch.IsSameGuild(victim) && !ch.IsImmortal())
            {
                /* Officers and deputies can title themselves. */
                if (ch == victim && ((PC)ch).ClanRank < Guild.Rank.officer)
                {
                    ch.SendText("&nThey might not appreciate that.\r\n");
                    return;
                }

                /* Leaders can title others. */
                if (ch != victim && ((PC)ch).ClanRank < Guild.Rank.leader)
                {
                    ch.SendText("You can't do that to another at your rank.\r\n");
                    return;
                }
            }
            else if (!ch.IsImmortal() || (ch._level <= victim._level && ch != victim)
                     || ch.IsNPC() || victim.IsNPC())
            {
                SocketConnection.Act("$N&n might not appreciate that.", ch, null, victim, SocketConnection.MessageTarget.character);
                return;
            }

            string text = String.Join(" ", str, 1, (str.Length - 1));

            int length = 0;
            for (point = 0; point < text.Length; ++point)
            {
                if (text[point] == '&')
                {   /* Don't count color codes. */
                    point++;
                    /* Skip the &n's. */
                    if (!(text[point] == 'N' || text[point] == 'n'))
                    {
                        /* Skip the &+'s and &-'s. */
                        if (text[point] == '+' || text[point] == '-')
                        {
                            point++;
                        }
                        else
                        {
                            // Cap title at max length
                            if (++length >= Limits.MAX_TITLE_LENGTH)
                            {
                                text = text.Substring(0, point);
                                break;
                            }
                        }
                    }
                }
                else
                {
                    // Cap title at max length.
                    if (++length >= Limits.MAX_TITLE_LENGTH)
                    {
                        text = text.Substring(0, Limits.MAX_TITLE_LENGTH);
                        break;
                    }
                }
            }

            SetTitle(victim, text);
            ch.SendText("&nOk.\r\n");
        }

        public static void Description(CharData ch, string[] str)
        {
            if (ch == null)
            {
                Log.Error("Description(): null ch.", 0);
                return;
            }

            if (ch.IsNPC())
            {
                return;
            }

            ch.SendText("Description editing is disabled for now.\r\n");
            return;

            ((PC)ch).Editing = SocketConnection.EditState.description;
            MUDString.StringAppend(ch, ref ch._description);
            return;
        }

        /// <summary>
        /// Reports current condition verbally.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Report(CharData ch, string[] str)
        {
            string arg = String.Empty;

            if (ch == null)
            {
                Log.Error("Commandreport: null ch.", 0);
                return;
            }

            if (!ch.CanSpeak())
            {
                ch.SendText("Your lips move but no sound comes out.\r\n");
                return;
            }

            string buf = String.Empty;
            if (str.Length == 0)
            {
                buf += "&nYou report: " + ch._hitpoints + "/" + ch.GetMaxHit() + " hp " + ch._currentMana + "/" +
                       ch._maxMana + " mana " + ch._currentMoves + "/" + ch._maxMoves + " mv.\r\n";
                ch.SendText(buf);

                buf += "$n&n reports: " + ch._hitpoints + "/" + ch.GetMaxHit() + " hp " + ch._currentMana + "/" +
                       ch._maxMana + " mana " + ch._currentMoves + "/" + ch._maxMoves + " mv.\r\n";
                SocketConnection.Act(buf, ch, null, null, SocketConnection.MessageTarget.room);
                return;
            }
            //report is essentially a tell, why not use that code?
            
            buf += arg + " reporting: " + ch._hitpoints + "/" + ch.GetMaxHit() + " hp " + ch._currentMana + "/" +
                   ch._maxMana + " mana " + ch._currentMoves + "/" + ch._maxMoves + " mv.\r\n";
            CommandType.Interpret(ch, "tell " + buf);
            return;
        }

        public static void Practice(CharData ch, string[] str)
        {
            if( ch == null ) return;

            ch.SendText("&n" + Database.SystemData.MudAnsiName + " does not use practice or train.  Go use your skills instead!\r\n");
            return;
        }

        public static void Wimpy(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int wimpy;

            if (str.Length == 0)
            {
                wimpy = ch._wimpy;
            }
            else
            {
                Int32.TryParse(str[0], out wimpy);
            }

            if (wimpy < 0)
            {
                ch.SendText("&nYour courage exceeds your wisdom.\r\n");
                return;
            }

            if (wimpy > ch.GetMaxHit())
            {
                ch.SendText("&nSuch cowardice ill becomes you.\r\n");
                return;
            }

            ch._wimpy = wimpy;
            string text = String.Format("&nWimpy set to {0} hit points.\r\n", wimpy);
            ch.SendText(text);
            return;
        }

        public static void Password(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch.IsNPC())
                return;

            ch._socket.WriteToBuffer("Password: ");
            ch._socket._connectionState = SocketConnection.ConnectionState.change_password_get_old;
            return;
        }

        /// <summary>
        /// Shows a the available social commands to a player.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="argument"></param>
        public static void Socials(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string buf1 = String.Empty;

            int col = 0;

            foreach (Social social in Database.SocialList.SocialData)
            {
                if (social.Name.Length == 0)
                    continue;

                string buf = String.Format("{0} ", MUDString.PadStr(social.Name, 13));
                buf1 += buf;
                if (++col % 5 == 0)
                    buf1 += "\r\n";
            }

            if (col % 5 != 0)
                buf1 += "\r\n";

            ch.SendText(buf1);
            return;
        }

        /// <summary>
        /// Shows the available commands.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Commands(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string buf = String.Empty;
            int col = 0;

            foreach (CommandType cmd in CommandType.CommandTable)
            {
                if (cmd.MinLevel < Limits.LEVEL_HERO && cmd.MinLevel <= ch.GetTrust() && cmd.Show)
                {
                    buf += String.Format("{0}  ", MUDString.PadStr(cmd.Name, 16));
                    // Format into 4 columns.
                    if (++col % 4 == 0)
                    {
                        buf += "\r\n";
                    }
                }
            }

            if (col % 5 != 0)
                buf += "\r\n";

            ch.SendText(buf);
            return;
        }

        public static void Channels(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (str.Length == 0 || String.IsNullOrEmpty(str[0]))
            {
                if (!ch.IsNPC() && ch.HasActBit(PC.PLAYER_SILENCE))
                {
                    ch.SendText("&nYou are silenced, cur.\r\n");
                    return;
                }

                ch.SendText("Channels:");

                ch.SendText(ch.IsListening(TalkChannel.shout)
                              ? " +SHOUT"
                              : " -shout");

                ch.SendText(ch.IsListening(TalkChannel.yell)
                              ? " +YELL"
                              : " -yell");

                if (ch.IsGuild())
                {
                    ch.SendText(ch.IsListening(TalkChannel.guild)
                                  ? " +CLANTALK"
                                  : " -clantalk");
                }

                if (ch.IsHero())
                {
                    ch.SendText(ch.IsListening(TalkChannel.immortal)
                                  ? " +IMMTALK"
                                  : " -immtalk");
                }

                ch.SendText(".\r\n");
            }
            else
            {
                TalkChannel bit;
                bool fClear;

                if (str[0][0] == '+')
                    fClear = true;
                else if (str[0][0] == '-')
                    fClear = false;
                else
                {
                    ch.SendText("&nChannels -channel or +channel?\r\n");
                    return;
                }

                string tmparg = String.Format("{0}", str[0]);
                if (!MUDString.StringsNotEqual(tmparg + 1, "immtalk"))
                    bit = TalkChannel.immortal;
                else if (!MUDString.StringsNotEqual(tmparg + 1, "clantalk"))
                    bit = TalkChannel.guild;
                else if (!MUDString.StringsNotEqual(tmparg + 1, "shout"))
                    bit = TalkChannel.shout;
                else if (!MUDString.StringsNotEqual(tmparg + 1, "yell"))
                    bit = TalkChannel.yell;
                else
                {
                    ch.SendText("&nSet or clear which channel?\r\n");
                    return;
                }

                if (fClear)
                    ch.SetListening(bit, true);
                else
                    ch.SetListening(bit, false);

                ch.SendText("&nOk.\r\n");
            }

            return;
        }

        /// <summary>
        /// Sets and gets player configuration options.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="argument"></param>
        public static void Toggle(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch.IsNPC())
                return;

            if (str.Length == 0)
            {
                ch.SendText("&+L+------------+------------------------------------------------------------+&n\r\n");
                ch.SendText("&+L|&n&+m  Option&+L    |&n&+r Description&n                                                &+L|&n\r\n");
                ch.SendText("&+L+------------+------------------------------------------------------------+&n\r\n");
                ch.SendText(ch.HasActBit(PC.PLAYER_AUTOWRAP)
                               ? "&+L[&+WX&+L]&n Autowrap &+L|&n &+cThe MUD automatically wraps long lines of text.            &+L|&n\r\n"
                               : "&+L[ ]&n Autowrap &+L|&n &+cThe MUD does not automatically wrap long text.             &+L|&n\r\n"
                               );
                ch.SendText(ch.HasActBit(PC.PLAYER_BLANK)
                               ? "&+L[&+WX&+L]&n Blank    &+L|&n &+cYou have a blank line before your prompt.                  &+L|&n\r\n"
                               : "&+L[ ]&n Blank    &+L|&n &+cYou have no blank line before your prompt.                 &+L|&n\r\n"
                                );
                ch.SendText(ch.HasActBit(PC.PLAYER_BRIEF)
                               ? "&+L[&+WX&+L]&n Brief    &+L|&n &+cYou see brief descriptions.                                &+L|&n\r\n"
                               : "&+L[ ]&n Brief    &+L|&n &+cYou see long descriptions.                                 &+L|&n\r\n"
                                );
                ch.SendText(ch.HasActBit(PC.PLAYER_CAST_TICK)
                               ? "&+L[&+WX&+L]&n Casttick &+L|&n &+cYou see your casting ticks.                                &+L|&n\r\n"
                               : "&+L[ ]&n Casttick &+L|&n &+cFor spam's sake, no casting ticks!                         &+L|&n\r\n"
                                );
                ch.SendText(ch.HasActBit(PC.PLAYER_COMBINE)
                               ? "&+L[&+WX&+L]&n Combine  &+L|&n &+cYou see object lists in combined format.                   &+L|&n\r\n"
                               : "&+L[ ]&n Combine  &+L|&n &+cYou see object lists in single format.                     &+L|&n\r\n"
                                );
                ch.SendText(ch.HasActBit(PC.PLAYER_COLOR)
                               ? "&+L[&+WX&+L]&n Color    &+L|&n &+cYou see ANSI colors.                                       &+L|&n\r\n"
                               : "&+L[ ]&n Color    &+L|&n &+cYou don't see ANSI colors.                                 &+L|&n\r\n"
                                );
                ch.SendText(ch.HasActBit(PC.PLAYER_COLOR_CON)
                               ? "&+L[&+WX&+L]&n Colorcon &+L|&n &+cYou see ANSI colors in consider messages.                  &+L|&n\r\n"
                               : "&+L[ ]&n Colorcon &+L|&n &+cYou don't see ANSI colors in consider messages.            &+L|&n\r\n"
                                );
                ch.SendText(ch.HasActBit(PC.PLAYER_MSP)
                               ? "&+L[&+WX&+L]&n MSP      &+L|&n &+cMUD Sound Protocol (MSP) support is on.                    &+L|&n\r\n"
                               : "&+L[ ]&n MSP      &+L|&n &+cMUD Sound Protocol (MSP) support is off.                   &+L|&n\r\n"
                                );
                ch.SendText(ch.HasActBit(PC.PLAYER_PAGER)
                               ? "&+L[&+WX&+L]&n Pager    &+L|&n &+cText is shown in separate pages.                           &+L|&n\r\n"
                               : "&+L[ ]&n Pager    &+L|&n &+cText is shown all-at-once with no paging.                  &+L|&n\r\n"
                                );
                ch.SendText(ch.HasActBit(PC.PLAYER_PROMPT)
                               ? "&+L[&+WX&+L]&n Prompt   &+L|&n &+cYou have a prompt.                                         &+L|&n\r\n"
                               : "&+L[ ]&n Prompt   &+L|&n &+cYou don't have a prompt.                                   &+L|&n\r\n"
                                );
                ch.SendText(ch.HasActBit(PC.PLAYER_SHOUT)
                               ? "&+L[&+WX&+L]&n Shout    &+L|&n &+cYou can hear shouts.                                       &+L|&n\r\n"
                               : "&+L[ ]&n Shout    &+L|&n &+cYou cover your ears when someone is yelling.               &+L|&n\r\n"
                                );
                ch.SendText(ch.HasActBit(PC.PLAYER_TELNET_GA)
                               ? "&+L[&+WX&+L]&n TelnetGA &+L|&n &+cYou receive a telnet go-ahead sequence.                    &+L|&n\r\n"
                               : "&+L[ ]&n TelnetGA &+L|&n &+cYou don't receive a telnet GA sequence.                    &+L|&n\r\n"
                                );
                ch.SendText(ch.HasActBit(PC.PLAYER_TELL)
                               ? "&+L[&+WX&+L]&n Tell     &+L|&n &+cYou can hear tells.                                        &+L|&n\r\n"
                               : "&+L[ ]&n Tell     &+L|&n &+cYou are ignoring tells.                                    &+L|&n\r\n"
                                );
                ch.SendText(ch.HasActBit(PC.PLAYER_VICIOUS)
                               ? "&+L[&+WX&+L]&n Vicious  &+L|&n &+cYou are vicious and will kill mortally wounded foes.       &+L|&n\r\n"
                               : "&+L[ ]&n Vicious  &+L|&n &+cYou aren't vicious and will spare a mortally wounded foe.  &+L|&n\r\n");
                ch.SendText(ch.HasActBit(PC.PLAYER_MAP)
                               ? "&+L[&+WX&+L]&n Map      &+L|&n &+cYou see the maps.                                          &+L|&n\r\n"
                               : "&+L[ ]&n Map      &+L|&n &+cYou do not see maps.                                       &+L|&n\r\n");

                if (ch.HasActBit(PC.PLAYER_SILENCE))
                {
                    ch.SendText( "&+L[&+WX&+L]&n Silence  &+L|&n &+cYou are silenced.                                       &+L|&n\r\n");
                }

                ch.SendText(!ch.HasActBit(PC.PLAYER_NO_EMOTE)
                              ? "&n"
                              : "&+L[ ]&n emote    | &+cYou can't emote.                                                 &+L|&n\r\n");

                ch.SendText("&+L+------------+------------------------------------------------------------+&n\r\n");
                string termStr = "&+L|&n &+cYour terminal type is " + ch._socket._terminalType + " and MCCP is " +
                    ch._socket.MccpEnabled + ".";
                while (termStr.Length < 82)
                    termStr += " ";
                termStr += "&+L|&n\r\n";
                ch.SendText(termStr);
                ch.SendText("&+L+-------------------------------------------------------------------------+&n\r\n");
            }
            else
            {
                string word;
                Bitvector bit;
                int fSet;

                if (str[0][0] == '-')
                {
                    fSet = 0;
                    word = str[0].Substring(1);
                }
                else if (str[0][0] == '+')
                {
                    fSet = 1;
                    word = str[0].Substring(1);
                }
                else
                {
                    fSet = 2;
                    word = str[0];
                }

                if (("blank".StartsWith(word, StringComparison.CurrentCultureIgnoreCase)))
                    bit = PC.PLAYER_BLANK;
                else if (("autowrap".StartsWith(word, StringComparison.CurrentCultureIgnoreCase)))
                    bit = PC.PLAYER_AUTOWRAP;
                else if (("brief".StartsWith(word, StringComparison.CurrentCultureIgnoreCase)))
                    bit = PC.PLAYER_BRIEF;
                else if (("casttick".StartsWith(word, StringComparison.CurrentCultureIgnoreCase)))
                    bit = PC.PLAYER_CAST_TICK;
                else if (("combine".StartsWith(word, StringComparison.CurrentCultureIgnoreCase)))
                    bit = PC.PLAYER_COMBINE;
                else if (("color".StartsWith(word, StringComparison.CurrentCultureIgnoreCase)))
                {
                    if (ch._socket._terminalType == SocketConnection.TerminalType.TERMINAL_ENHANCED)
                    {
                        ch.SendText("You cannot turn color off when using the Basternae client.\r\n");
                        return;
                    }
                    bit = PC.PLAYER_COLOR;
                }
                else if (("colorcon".StartsWith(word, StringComparison.CurrentCultureIgnoreCase)))
                    bit = PC.PLAYER_COLOR_CON;
                else if (("msp".StartsWith(word, StringComparison.CurrentCultureIgnoreCase)))
                    bit = PC.PLAYER_MSP;
                else if (("pager".StartsWith(word, StringComparison.CurrentCultureIgnoreCase)))
                    bit = PC.PLAYER_PAGER;
                else if (("shout".StartsWith(word, StringComparison.CurrentCultureIgnoreCase)))
                    bit = PC.PLAYER_SHOUT;
                else if (("prompt".StartsWith(word, StringComparison.CurrentCultureIgnoreCase)))
                    bit = PC.PLAYER_PROMPT;
                else if (("telnetga".StartsWith(word, StringComparison.CurrentCultureIgnoreCase)))
                    bit = PC.PLAYER_TELNET_GA;
                else if (("tell".StartsWith(word, StringComparison.CurrentCultureIgnoreCase)))
                    bit = PC.PLAYER_TELL;
                else if (("vicious".StartsWith(word, StringComparison.CurrentCultureIgnoreCase)))
                    bit = PC.PLAYER_VICIOUS;
                else if (("map".StartsWith(word, StringComparison.CurrentCultureIgnoreCase)))
                    bit = PC.PLAYER_MAP;
                else if (("vicious".StartsWith(word, StringComparison.CurrentCultureIgnoreCase)))
                    bit = PC.PLAYER_VICIOUS;
                else if (("compact".StartsWith(word, StringComparison.CurrentCultureIgnoreCase)))
                    bit = PC.PLAYER_BLANK;
                else if (word.Contains("wimpy"))
                {
                    CommandType.Interpret(ch, "wimpy " + word.Substring((word.IndexOf("wimpy") + 5)));
                    return;
                }
                else if ("mccp".StartsWith(word, StringComparison.CurrentCultureIgnoreCase))
                {
                    ch._socket.MccpEnabled = !ch._socket.MccpEnabled;
                    if (ch._socket.MccpEnabled)
                    {
                        ch.SendText("MCCP is now enabled.");
                    }
                    else
                    {
                        ch.SendText("MCCP is now disabled.");
                    }
                    return;
                }
                else
                {
                    ch.SendText("&nConfig which option?\r\n");
                    return;
                }

                if (ch.IsClass(CharClass.Names.paladin) && bit == PC.PLAYER_VICIOUS)
                {
                    ch.SendText("Paladins may not toggle vicious.\r\n");
                    /* Just to make sure they don't have it toggled on. */
                    ch.RemoveActBit(bit);
                    return;
                }

                if (fSet == 1)
                {
                    if (bit != PC.PLAYER_NONE)
                    {
                        ch.SetActBit(bit);
                    }
                    ch.SendText( (String.Format("&n{0} is now ON.\r\n", word.ToUpper())));
                }
                else if (fSet == 0)
                {
                    if (bit != PC.PLAYER_NONE)
                    {
                        ch.RemoveActBit(bit);
                    }
                    ch.SendText((String.Format("&n{0} is now OFF.\r\n", word.ToUpper())));
                }
                else if (fSet == 2)
                {
                    if (bit != PC.PLAYER_NONE)
                    {
                        ch.ToggleActBit(bit);
                    }
                    if (ch.HasActBit(bit))
                        ch.SendText((String.Format("&n{0} is now ON.\r\n", word.ToUpper())));
                    else
                        ch.SendText((String.Format("&n{0} is now OFF.\r\n", word.ToUpper())));
                }
            }

            return;
        }

        /// <summary>
        /// Displays the news entries.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void News(CharData ch, string[] str)
        {
            if( ch == null ) return;

            ch.SendText(Database.SystemData.ShowNewsEntries());
        }

        /// <summary>
        /// Wizlist: Show a list of the game's immortals.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Wizlist(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CommandType.Interpret(ch, "help wizlist");
            return;
        }

        // reformatted - Xangis
        // Immortals can also see a player's skill list now.
        public static void Skills(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string buf;
            int level;

            if (ch.IsNPC())
            {
                ch.SendText("&nYou do not need any stinking skills!\r\n");
                return;
            }

            CharData wch = ch;

            if (ch.IsImmortal() && str.Length != 0)
            {
                wch = ch.GetCharWorld(str[0]);
                if (!wch)
                {
                    ch.SendText("No such person.\r\n");
                    return;
                }
                if (wch.IsNPC())
                {
                    ch.SendText("NPCs don't have skills!\r\n");
                    return;
                }
            }

            string buf1 = "&n&+rALL Abilities available for your class.&n\r\n";
            buf1 += "&n&+RLv      Abilities&n\r\n";

            for (level = 1; level <= Limits.LEVEL_HERO; level++)
            {
                bool pSpell = true;

                foreach (KeyValuePair<String, Skill> kvp in Skill.SkillList)
                {
                    if (kvp.Value.ClassAvailability[(int)wch._charClass.ClassNumber] != level)
                        continue;

                    if (pSpell)
                    {
                        buf = String.Format("&+Y{0}&+y:&n", MUDString.PadInt(level, 2));
                        buf1 += buf;
                        pSpell = false;
                    }
                    else
                        buf1 += "   ";

                    buf1 += "     ";

                    // Show skills as words rather than numbers for non-immortals
                    if (((PC)wch).SkillAptitude.ContainsKey(kvp.Key))
                    {
                        if (!ch.IsImmortal())
                        {
                            buf = String.Format("&n&+c{0}  &+Y{1}&n",
                                MUDString.PadStr(kvp.Key, 20),
                                       StringConversion.SkillString(((PC)wch).SkillAptitude[kvp.Key]));
                        }
                        else
                        {
                            buf = String.Format("&n&+c{0}  &+Y{1}&n",
                                MUDString.PadStr(kvp.Key, 20), ((PC)wch).SkillAptitude[kvp.Key]);
                        }
                        buf1 += buf;
                    }
                    else
                    {
                        buf = String.Format("&n&+c{0}  &+YAvailable at level {1}.&n",
                            MUDString.PadStr(kvp.Key, 20), level);
                    }

                    buf1 += "\r\n";

                }
            }

            if ((wch.IsClass(CharClass.Names.monk) || wch.IsClass(CharClass.Names.mystic)))
            {
                buf1 += "\r\n&+WMonk Skills:&n\r\n";
                foreach (KeyValuePair<String, MonkSkill> kvp in Database.MonkSkillList)
                {                
                    if (((PC)wch).SkillAptitude[kvp.Key] != 0)
                    {
                        buf = String.Format("        &n&+c{0}  &+Y{1}&n\r\n",
                            MUDString.PadStr(kvp.Key, 20),
                            StringConversion.SkillString(((PC)wch).SkillAptitude[kvp.Key]));
                        buf1 += buf;
                    } //end if learned
                } // end for
                buf1 += "\r\n";
            } //end if monk

            ch.SendText(buf1);
            return;
        }

        /// <summary>
        /// Command to list the spells available to you.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Spells(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int circle;

            if (ch.IsNPC())
            {
                ch.SendText("&nYou do not need any stinking spells!\r\n");
                return;
            }

            StringBuilder buf = new StringBuilder();
            buf.Append( "&n&+rALL spells available for your class.&n\r\n");
            buf.Append( "&+RLv      Spell&n\r\n");

            // Don't show 12th circle spells...
            for (circle = 1; circle < Limits.MAX_CIRCLE; circle++)
            {
                bool pSpell = true;

                foreach (KeyValuePair<String, Spell> kvp in Spell.SpellList)
                {
                    if (kvp.Value.SpellCircle[(int)ch._charClass.ClassNumber] != circle)
                        continue;

                    if (pSpell)
                    {
                        buf.Append(String.Format("&+Y{0:00}&+y:&n", circle));
                        pSpell = false;
                    }
                    else
                        buf.Append("   ");

                    buf.Append("     ");

                    if (((PC)ch).SpellAptitude.ContainsKey(kvp.Key))
                    {
                        buf.Append(String.Format("&n&+c{0}  &+Y{1}  ({2})&n", MUDString.PadStr(kvp.Key, 24),
                                   ((PC)ch).SpellAptitude[kvp.Key], StringConversion.SpellSchoolString(kvp.Value.School)));
                    }
                    else
                    {
                        buf.Append(String.Format("&n&+c{0}  &+Ynot learned  ({1})&n", MUDString.PadStr(kvp.Key, 24),
                            StringConversion.SpellSchoolString(kvp.Value.School)));
                    }

                    buf.Append("\r\n");

                }

            }
            ch.SendText(buf.ToString());
            return;
        }

        public static void Faction(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int count;
            string buf = "Other race reactions to you:\r\n";
            for (count = 0; count < Race.RaceList.Length; count++)
            {
                if (!ch.IsImmortal())
                {
                    buf += String.Format("&+c{0}&n: &+Y{1}&n  ",
                        MUDString.PadStr(Race.RaceList[count].Name, 15),
                        MUDString.PadStr(StringConversion.FactionString(ch.GetFaction(count)), 14));
                }
                else
                {
                    buf += String.Format("&+c{0}&n: &+Y{1}&n  ",
                        MUDString.PadStr(Race.RaceList[count].Name, 15),
                        MUDString.PadStr(ch.GetFaction(count).ToString(), 14));
                }
                if (count % 2 == 0)
                {
                    buf += "\r\n";
                }
            }
            buf += "\r\n";
            ch.SendText(buf);
        }

        public static void Blank(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string buf;

            if (ch.HasActBit(PC.PLAYER_BLANK))
                buf = String.Format("-blank");
            else
                buf = String.Format("+blank");

            CommandType.Interpret(ch, "toggle " + buf);

            return;

        }

        public static void Brief(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string buf;

            if (ch.HasActBit(PC.PLAYER_BRIEF))
                buf = String.Format("-brief");
            else
                buf = String.Format("+brief");

            CommandType.Interpret(ch, "toggle " + buf);

            return;

        }

        public static void Combine(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string buf;

            if (ch.HasActBit(PC.PLAYER_COMBINE))
                buf = String.Format("-combine");
            else
                buf = String.Format("+combine");

            CommandType.Interpret(ch, "toggle " + buf);

            return;

        }

        public static void PageLength(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int lines;

            if (ch.IsNPC())
                return;

            if (str.Length == 0)
                lines = 20;
            else
                Int32.TryParse(str[0], out lines);

            if (lines < 19)
            {
                ch.SendText("&nLess than 19 lines of paged text is not allowed.\r\n");
                return;
            }

            if (lines > 60)
            {
                ch.SendText("&nI don't know of a screen that is larger than 60 lines!\r\n");
                lines = 60;
            }

            ((PC)ch).PageLength = lines;
            string buf = String.Format("&nPage pause set to {0} lines.\r\n", lines);
            ch.SendText(buf);
            return;
        }

       /// <summary>
       /// Defines how a player's prompt is displayed.
       /// </summary>
       /// <param name="ch"></param>
       /// <param name="str"></param>
        public static void Prompt(CharData ch, string[] str)
        {
            string buf = String.Empty;

            /* Unswitched NPC's get kicked out */
            if (ch._socket == null)
                return;

            /* Will always have a pc ch after this */
            ch = (ch._socket.Original != null ? ch._socket.Original : ch._socket.Character);

            if (str.Length == 0)
            {
                if (ch.HasActBit(PC.PLAYER_PROMPT))
                    buf = "-prompt";
                else
                    buf = "+prompt";
                CommandType.Interpret(ch, "toggle " + buf);
                return;
            }

            if (str[0].Equals("raw", StringComparison.CurrentCultureIgnoreCase))
                buf += "&n&+g<%h&n&+g/%H&n&+ghp %mm %v&n&+g/%V&n&+gmv>\r\n&n&+g<&n%D&n %B&+g>&n ";
            else if (str[0].Equals("dark", StringComparison.CurrentCultureIgnoreCase))
                buf += "&+L<&n&+m%h&+L/&n&+m%H&+Lhp &n&+m%v&+L/&n&+m%V&+Lmv>\r\n&+L<&n%T&n %E&+L>&n ";
            else if (str[0].Equals("meter", StringComparison.CurrentCultureIgnoreCase))
                if (ch.IsClass(CharClass.Names.psionicist) || ch.IsClass(CharClass.Names.bard))
                    buf += "&n&+g<%h&n&+g/%H&n&+ghp %mm/%MM %v&n&+g/%V&n&+gmv>\r\n&n&+g<&n%d&n %b&+g>&n ";
                else
                    buf += "&n&+g<%h&n&+g/%H&n&+ghp %v&n&+g/%V&n&+gmv>\r\n&n&+g<&n%d&n %b&+g>&n ";
            else if (str[0].Equals("chains", StringComparison.CurrentCultureIgnoreCase))
                buf += "&+L<&n&+m%h&+L/&n&+m%H&+Lhp &n&+m%v&+L/&n&+m%V&+Lmv>\r\n&+L<&n%t&n %e&+L>&n ";
            else if (str[0].Equals("status", StringComparison.CurrentCultureIgnoreCase))
                buf += "&n&+g<%l&+g:%h&n&+g/%H&n&+ghp %mm %v&n&+g/%V&n&+gmv>\r\n&n&+g<&n%D&n %B&+g>&n ";
            else if (str[0].Equals("all", StringComparison.CurrentCultureIgnoreCase))
                if (ch.IsClass(CharClass.Names.psionicist) || ch.IsClass(CharClass.Names.bard))
                    buf += "&n&+g<%h&n&+g/%H&n&+ghp %m/%Mm %v&n&+g/%V&n&+gmv>\r\n&n&+g<&n%D&n %B&+g>&n ";
                else
                    buf += "&n&+g<%h&n&+g/%H&n&+ghp %v&n&+g/%V&n&+gmv>\r\n&n&+g<&n%D&n %B&+g>&n ";
            else if (str[0].Equals("fancy", StringComparison.CurrentCultureIgnoreCase))
                if (ch.IsClass(CharClass.Names.psionicist) || ch.IsClass(CharClass.Names.bard))
                    buf += "&n&+g<%h&n&+g/%H&n&+ghp %m/%Mm &+g%v&n&+g/%V&n&+gmv %a>\r\n&n%n&+g< &n%l&n &n%d&n %b&+g>&n ";
                else
                    buf += "&n&+g<%h&n&+g/%H&n&+ghp &+g%v&n&+g/%V&n&+gmv %a>\r\n&n%n&+g< &n%l&n &n%d&n %b&+g>&n";
            else
            {
                string text = String.Join(" ", str);
                if (text.Length > 70)
                    text = text.Substring(0, 70);
                buf = text;
            }

            ((PC)ch).Prompt = buf;
            ch.SendText("&nOk.\r\n");
            return;
        }

        public static void Auto(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CommandType.Interpret(ch, "toggle");
            return;
        }

        /// <summary>
        /// Command to set yourself as being away from keyboard.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void AFK(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch.IsNPC())
                return;

            if (ch.HasActBit(PC.PLAYER_AFK))
            {
                ch.RemoveActBit(PC.PLAYER_AFK);
                ch.SendText("&nYou are back at your keyboard.\r\n");
                SocketConnection.Act("$n&n has returned to $s keyboard.", ch, null, ch, SocketConnection.MessageTarget.room);
            }
            else
            {
                ch.SetActBit(PC.PLAYER_AFK);
                ch.SendText("&nYou are away from keyboard.\r\n");
                SocketConnection.Act("$n&n has left $s keyboard.", ch, null, ch, SocketConnection.MessageTarget.room);
            }

            return;
        }

        /// <summary>
        /// Used to flag a player as running or not running a bot.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="argument"></param>
        public static void Bot(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch.IsNPC())
                return;

            if (ch.HasActBit(PC.PLAYER_BOTTING))
            {
                ch.RemoveActBit(PC.PLAYER_BOTTING);
                ch.SendText("&nYou are no longer running a bot.\r\n");
                SocketConnection.Act("$n&n's soul has returned to $s body.", ch, null, ch, SocketConnection.MessageTarget.room);
            }
            else
            {
                ch.SetActBit(PC.PLAYER_BOTTING);
                ch.SendText("&nYou are now running a bot.\r\n");
                SocketConnection.Act("$n&n's soul has left $s body.", ch, null, ch, SocketConnection.MessageTarget.room);
            }

            return;
        }

        /// <summary>
        /// Tropy command.  Shows kill data and whether certain mobs are "boring" and worth less experience.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Trophy(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int count;
            CharData rch;

            if (str.Length == 0 || !ch.IsImmortal())
            {
                rch = ch;
            }
            else
            {
                rch = ch.GetCharWorld(str[0]);
                if (!rch)
                {
                    ch.SendText("No such person.\r\n");
                    return;
                }
            }

            if (rch.IsNPC())
            {
                ch.SendText("Mobs don't have Trophy.\r\n");
                return;
            }

            if (rch._level < 5)
            {
                ch.SendText("You don't need to worry about trophy yet.\r\n");
                return;
            }

            ch.SendText("&+BTrophy data:\r\n");
            for (count = 0; count < Limits.MAX_LEVEL; ++count)
            {
                if (((PC)rch).TrophyData[count].MobIndexNumber == 0)
                    continue;
                if (((PC)rch).TrophyData[count].NumberKilled == 0)
                    continue;
                /* Added else for mobs which are removed from game. (Earlier, Trophy would
                crash the mud on no-longer existant mobs.) */
                // TODO: Fix format of float value.
                string buf;
                if (Database.GetMobTemplate(((PC)rch).TrophyData[count].MobIndexNumber) != null)
                    buf = String.Format("   &n&+b(&+y{0:0000.00}&+b)&n {1}&n\r\n",
                              ((float)((PC)rch).TrophyData[count].NumberKilled / (float)100),
                              (Database.GetMobTemplate(((PC)rch).TrophyData[count].MobIndexNumber)).ShortDescription);
                else if (((PC)rch).TrophyData[count].MobIndexNumber != 0)
                    buf = String.Format("   &n&+b(&+y{0:0000.00}&+b)&n ({1}) \r\n",
                              ((float)((PC)rch).TrophyData[count].NumberKilled / (float)100),
                              ((PC)rch).TrophyData[count].MobIndexNumber);
                else
                    buf = String.Format("   &n&+b(&+y{0:0000.00}&+b)&n (null) \r\n",
                              ((float)((PC)rch).TrophyData[count].NumberKilled / (float)100));
                ch.SendText(buf);
            }
            ch.SendText("\r\n");
            return;
        }

        /// <summary>
        /// Innate command.  Shows and activates innate abilitiies.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Innate(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string buf;
            Affect af = new Affect();


            // Use innates here
            if (str.Length > 0 && !String.IsNullOrEmpty(str[0]))
            {
                if (!MUDString.IsPrefixOf(str[0], "strength"))
                {
                    if (ch.HasInnate(Race.RACE_STRENGTH))
                    {
                        if (ch.IsAffected(Affect.AFFECT_STRENGTH_INCREASED))
                        {
                            ch.SendText("You are already affected by strength.");
                            return;
                        }
                        if (ch.HasInnateTimer(InnateTimerData.Type.strength))
                        {
                            ch.SendText("You need to rest a bit first.\r\n");
                            return;
                        }

                        af.Type = Affect.AffectType.spell;
                        af.Value = "strength";
                        af.Duration = MUDMath.Dice(8, 5);
                        af.AddModifier(Affect.Apply.strength, MUDMath.Dice(2, 4) + 15);
                        af.SetBitvector(Affect.AFFECT_STRENGTH_INCREASED);
                        ch.AddAffect(af);
                        ch.SendText("You feel stronger.\r\n");
                        ch.AddInnateTimer(InnateTimerData.Type.strength, 24);

                        ch.WaitState(14);

                    }
                    else
                    {
                        ch.SendText("You don't know how to do that.\r\n");
                        return;
                    }
                }
                else if (!MUDString.IsPrefixOf(str[0], "levitate"))
                {
                    if (ch.HasInnate(Race.RACE_LEVITATE))
                    {
                        if (ch.IsAffected( Affect.AFFECT_LEVITATE))
                        {
                            ch.SendText("You are already levitating.");
                            return;
                        }
                        if (ch.HasInnateTimer(InnateTimerData.Type.levitate))
                        {
                            ch.SendText("You need to rest a bit first.\r\n");
                            return;
                        }

                        af.Type = Affect.AffectType.spell;
                        af.Value = "levitation";
                        af.Duration = MUDMath.Dice(8, 5);
                        af.SetBitvector(Affect.AFFECT_LEVITATE);
                        ch.AddAffect(af);
                        ch.SendText("Your feet rise off the ground.\r\n");
                        ch.AddInnateTimer(InnateTimerData.Type.levitate, 24);

                        ch.WaitState(6);
                    }
                    else
                    {
                        ch.SendText("You don't know how to do that.\r\n");
                        return;
                    }
                }
                else if (!MUDString.IsPrefixOf(str[0], "faerie"))
                {
                    if (ch.HasInnate(Race.RACE_FAERIE_FIRE))
                    {
                        CharData victim = ch.GetCharRoom(str[0]);

                        if (victim == null)
                            ch.SendText("You do not see them here.");
                        else
                        {
                            Spell spl = Spell.SpellList["faerie fire"];
                            if (spl != null)
                            {
                                spl.Invoke(ch, ch._level, victim);
                            }
                        }
                    }
                    else
                    {
                        ch.SendText("You don't know how to do that.\r\n");
                        return;
                    }
                }
                else if (!MUDString.IsPrefixOf(str[0], "invisibility"))
                {
                    if (ch.HasInnate(Race.RACE_INVIS))
                    {
                        if (ch.IsAffected( Affect.AFFECT_INVISIBLE))
                        {
                            ch.SendText("You are already invisible!\r\n");
                            return;
                        }
                        if (ch.HasInnateTimer(InnateTimerData.Type.invisibility))
                        {
                            ch.SendText("You need to rest a bit first.\r\n");
                            return;
                        }

                        af.Type = Affect.AffectType.spell;
                        af.Value = "invisibility";
                        af.Duration = MUDMath.Dice(2, 8) + 4;
                        af.SetBitvector(Affect.AFFECT_INVISIBLE);

                        SocketConnection.Act("$n&n fades out of existence.", ch, null, null, SocketConnection.MessageTarget.room);
                        ch.SendText("You vanish.\r\n");

                        ch.AddAffect(af);
                        ch.AddInnateTimer(InnateTimerData.Type.invisibility, 24);

                        ch.WaitState(24);
                    }
                    else
                    {
                        ch.SendText("You don't know how to do that.\r\n");
                        return;
                    }
                }
                else if (!MUDString.IsPrefixOf(str[0], "enlarge"))
                {
                    if (ch.HasInnate(Race.RACE_ENLARGE))
                    {
                        if (ch.IsAffected(Affect.AFFECT_ENLARGED))
                        {
                            ch.SendText("You are already enlarged.\r\n");
                            return;
                        }
                        if (ch.HasInnateTimer(InnateTimerData.Type.enlarge))
                        {
                            ch.SendText("You need to rest a bit first.\r\n");
                            return;
                        }

                        af.Type = Affect.AffectType.spell;
                        af.Value = "enlarge";
                        af.Duration = MUDMath.Dice(8, 5);
                        af.AddModifier(Affect.Apply.size, 1);
                        af.SetBitvector(Affect.AFFECT_NONE);
                        ch.AddAffect(af);

                        ch.SendText("&nYou grow to almost twice your normal size!\r\n");
                        SocketConnection.Act("$n&n grows to almost twice $s normal size!&n", ch, null, null, SocketConnection.MessageTarget.room);
                        ch.AddInnateTimer(InnateTimerData.Type.enlarge, 24);

                        ch.WaitState(10);
                    }
                    else
                    {
                        ch.SendText("You don't know how to do that.\r\n");
                        return;
                    }
                }
                else if (!MUDString.IsPrefixOf(str[0], "shift"))
                {
                    if (str.Length > 1 && !MUDString.IsPrefixOf(str[1], "astral"))
                    {
                        if (ch.HasInnate(Race.RACE_SHIFT_ASTRAL))
                        {
                            if (ch.HasInnateTimer(InnateTimerData.Type.shift_astral))
                            {
                                ch.SendText("You need to rest a bit first.\r\n");
                                return;
                            }
                            Spell spell = StringLookup.SpellLookup("plane shift");
                            if (!spell)
                            {
                                ch.SendText("Something seems to be blocking your ability to shift.");
                                Log.Error("Innate Shift: 'plane shift' spell not found. Check the spells file.");
                                return;
                            }
                            spell.Invoke(ch, ch._level, new Target(str[1]));
                            ch.AddInnateTimer(InnateTimerData.Type.shift_astral, 8);

                            ch.WaitState(10);
                        }
                        else
                        {
                            ch.SendText("You don't know how to do that.\r\n");
                            return;
                        }
                    }
                    else if (str.Length > 1 && !MUDString.IsPrefixOf(str[1], "prime"))
                    {
                        if (ch.HasInnate(Race.RACE_SHIFT_PRIME))
                        {
                            if (ch.HasInnateTimer(InnateTimerData.Type.shift_prime))
                            {
                                ch.SendText("You need to rest a bit first.\r\n");
                                return;
                            }
                            Spell spell = StringLookup.SpellLookup("plane shift");
                            if (!spell)
                            {
                                ch.SendText("Something seems to be blocking your ability to shift.");
                                Log.Error("Innate Shift: 'plane shift' spell not found. Check the spells file.");
                                return;
                            }
                            spell.Invoke(ch, ch._level, new Target(str[1]));
                            ch.AddInnateTimer(InnateTimerData.Type.shift_prime, 8);

                            ch.WaitState(10);
                        }
                        else
                        {
                            ch.SendText("You don't know how to do that.\r\n");
                            return;
                        }
                    }
                }
                else
                {
                    ch.SendText("That's not implemented yet. :(\r\n");
                }
                return;
            }

            buf = String.Format("&+BInnate abilities available to your race and class:&n\r\n");

            if (ch.HasInnate(Race.RACE_BODYSLAM))
                buf += "&n  bodyslam\r\n";
            if (ch.HasInnate(Race.RACE_CHARGE))
                buf += "&n  charge\r\n";
            if (ch.HasInnate(Race.RACE_FLY))
                buf += "&n  fly\r\n";
            if (ch.HasInnate(Race.RACE_PASSDOOR))
                buf += "&n  pass door\r\n";
            if (ch.HasInnate(Race.RACE_SWIM))
                buf += "&n  swim\r\n";
            if (ch.HasInnate(Race.RACE_WATERBREATH))
                buf += "&n  water breathing\r\n";
            if (ch.HasInnate(Race.RACE_INFRAVISION))
                buf += "&n  infravision\r\n";
            if (ch.HasInnate(Race.RACE_ULTRAVISION))
                buf += "&n  ultravision\r\n";
            if (ch.HasInnate(Race.RACE_DETECT_ALIGN)
                    || ch.IsClass(CharClass.Names.antipaladin)
                    || ch.IsClass(CharClass.Names.paladin))
                buf += "&n  detect align\r\n";
            if (ch.HasInnate(Race.RACE_DETECT_INVIS))
                buf += "&n  detect invis\r\n";
            if (ch.HasInnate(Race.RACE_DETECT_HIDDEN))
                buf += "&n  detect hidden\r\n";
            if (ch.HasInnate(Race.RACE_MUTE))
                buf += "&n  mute\r\n";
            if (ch.HasInnate(Race.RACE_DOORBASH))
                buf += "&n  doorbash\r\n";
            if (ch.HasInnate(Race.RACE_SHRUG))
                buf += "&n  shrug\r\n";
            if (ch.HasInnate(Race.RACE_ODSNEAK))
                buf += "&n  outdoor sneak\r\n";
            if (ch.HasInnate(Race.RACE_UDSNEAK))
                buf += "&n  underdark sneak\r\n";
            if (ch.HasInnate(Race.RACE_STRENGTH))
                buf += "&n  strength\r\n";
            if (ch.HasInnate(Race.RACE_FAERIE_FIRE))
                buf += "&n  faerie fire\r\n";
            //    if( ch.HasInnate( Race.RACE_STEAL ))
            //      buf += "&n  steal\r\n" );
            if (ch.HasInnate(Race.RACE_ENLARGE))
                buf += "&n  enlarge\r\n";
            if (ch.HasInnate(Race.RACE_INVIS))
                buf += "&n  invisibility\r\n";
            //    if( ch.HasInnate( Race.RACE_SUMMON_HOARDE ))
            //      buf += "&n  summon hoarde\r\n" );
            if (ch.HasInnate(Race.RACE_SHIFT_PRIME))
                buf += "&n  shift prime\r\n";
            if (ch.HasInnate(Race.RACE_SHIFT_ASTRAL))
                buf += "&n  shift astral\r\n";
            if (ch.HasInnate(Race.RACE_LEVITATE))
                buf += "&n  levitate\r\n";
            if (ch.HasInnate(Race.RACE_BITE))
                buf += "&n  bite\r\n";

            ch.SendText(buf);

            return;
        }

        public static void Search(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Room toRoom;
            Exit pexitRev;
            Exit pexit = null;
            Object obj;
            bool isArg;
            int door;

            if (ch._inRoom == null)
            {
                ch.SendText("There's no searching to be done here.\r\n");
                return;
            }

            /* Calculate the probability that ch finds something. */
            int chance = ch.GetCurrInt() * 35 / 100;
            chance += ch.GetCurrWis() * 35 / 100;
            chance += ch.GetCurrLuck() * 10 / 100;

            // Dwarves, being natural architects, can search better - Xangis
            if (ch.GetRace() == Race.RACE_DWARF)
                chance += 25;

            if (chance > 95)
                chance = 95;
            if (chance < 10)
                chance = 10;

            /* Searching with arguments. */
            if (str.Length != 0)
            {
                isArg = true;
                obj = ch.GetObjHere(str[0]);
                if (obj == null)
                {
                    ch.SendText("You don't see that object here.\r\n");
                    return;
                }
                switch (obj.ItemType)
                {
                    case ObjTemplate.ObjectType.quiver:
                    case ObjTemplate.ObjectType.container:
                    case ObjTemplate.ObjectType.npc_corpse:
                    case ObjTemplate.ObjectType.pc_corpse:
                        if (Macros.IsSet(obj.Values[1], ObjTemplate.CONTAINER_CLOSED.Vector))
                        {
                            SocketConnection.Act("$p&n is closed.", ch, obj, null, SocketConnection.MessageTarget.character);
                            return;
                        }
                        break;
                    default:
                        ch.SendText("That's not a container!\r\n");
                        return;
                }
            }
            else
            {
                isArg = false;
                obj = null;
            }

            /* Lag ch from searching. */
            if (ch._level < Limits.LEVEL_AVATAR)
                ch.WaitState(MUDMath.FuzzyNumber(18));

            List<Object> list;
            if (obj != null)
            {
                list = obj.Contains;
            }
            else
            {
                list = ch._inRoom.Contents;
            }
            foreach (Object obj2 in list)
            {
                if (obj2.HasFlag(ObjTemplate.ITEM_SECRET) && chance > MUDMath.NumberPercent()
                        && obj2.FlyLevel == ch._flyLevel)
                {
                    obj2.RemoveFlag(ObjTemplate.ITEM_SECRET);
                    SocketConnection.Act("You find $p&n.", ch, obj2, null, SocketConnection.MessageTarget.character);
                    SocketConnection.Act("$n&n points out $p&n!", ch, obj, null, SocketConnection.MessageTarget.room);
                    return;
                }
            }

            /* Look for a hidden exit. */
            for (door = 0; door <= Limits.MAX_DIRECTION; door++)
            {
                /* If all exits have been searched and none are secret. */
                if (door == Limits.MAX_DIRECTION)
                {
                    break;
                }
                /* If there's a secret exit that leads to a room. */
                pexit = ch._inRoom.ExitData[door];
                if (pexit && pexit.HasFlag(Exit.ExitFlag.secret) && pexit.TargetRoom)
                    break;
            }

            if (isArg)
            {
                door = Limits.MAX_DIRECTION;
            }
            if (door < Limits.MAX_DIRECTION)
            {
                if (pexit == null)
                {
                    Log.Error("Commandsearch: null exit found", 0);
                    return;
                }
                if (pexit.TargetRoom == null)
                {
                    Log.Error("Commandsearch: exit to null room found", 0);
                    return;
                }
                if (MUDMath.NumberPercent() < chance)
                {
                    if (ch._flyLevel > 0)
                    {
                        ch.SendText("You're too high to be sure of what you saw.\r\n");
                        return;
                    }
                    ch.SendText("You found a hidden exit!\r\n");
                    SocketConnection.Act("$n&n points out a secret exit!", ch, null, null, SocketConnection.MessageTarget.room);

                    /* Search out one side. */
                    pexit.RemoveFlag(Exit.ExitFlag.secret);
                    /* And the other side, if it exists. */
                    toRoom = Room.GetRoom(pexit.IndexNumber);
                    if (toRoom && (pexitRev = toRoom.ExitData[Exit.ReverseDirection[door]]) && (pexitRev.TargetRoom == ch._inRoom))
                    {
                        pexitRev.RemoveFlag(Exit.ExitFlag.secret);
                    }
                    return;
                }
            }


            if (!isArg)
            {
                // Chance of finding people hiding in the room
                foreach (CharData vch in ch._inRoom.People)
                {
                    if (!vch.IsAffected(Affect.AFFECT_HIDE) || vch._flyLevel != ch._flyLevel)
                        continue;
                    if (MUDMath.NumberPercent() < chance)
                    {
                        vch.RemoveAffect(Affect.AFFECT_HIDE);
                        /* People without DI can't search out invis hiding pplz. */
                        if (CharData.CanSee(ch, vch))
                        {
                            SocketConnection.Act("$n&n points out $N&n lurking here!", ch, null, vch, SocketConnection.MessageTarget.room);
                            SocketConnection.Act("You point out $N&n lurking here!", ch, null, vch, SocketConnection.MessageTarget.character);
                            SocketConnection.Act("$n&n reveals your hiding spot!", ch, null, vch, SocketConnection.MessageTarget.victim);
                            return;
                        }
                        vch.SetAffBit(Affect.AFFECT_HIDE);
                    }
                }
            }

            ch.SendText("You find nothing new.\r\n");
            return;
        }
 
        /// <summary>
        /// By Xangis.  Currently only lists known languages 
        /// Can change current language too.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Speak(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string arg1 = String.Empty;

            if (ch.IsNPC())
                return;

            if (String.IsNullOrEmpty(arg1))
            {
                int count;
                string text;
                for (count = 0; count < Race.MAX_LANG; ++count)
                {
                    if (count == (int)Race.Language.unknown)
                        continue;
                    if (((PC)ch).LanguageAptitude[count] > 20)
                    {
                        if (((PC)ch).LanguageAptitude[count] < 40)
                            text = String.Format("You have a basic understanding of {0}.\r\n",
                                      Race.LanguageTable[count]);
                        else if (((PC)ch).LanguageAptitude[count] < 60)
                            text = String.Format("You comprehend {0}.\r\n",
                                      Race.LanguageTable[count]);
                        else if (((PC)ch).LanguageAptitude[count] < 90)
                            text = String.Format("You are quite fluent in {0}.\r\n",
                                      Race.LanguageTable[count]);
                        else
                            text = String.Format("You are a master of {0}.\r\n",
                                      Race.LanguageTable[count]);

                        ch.SendText(text);
                    }
                }
                if (((PC)ch).Speaking == Race.Language.unknown)
                    ((PC)ch).Speaking = Race.RaceList[ch.GetOrigRace()].PrimaryLanguage;
                text = String.Format("Currently speaking ");
                text += Race.LanguageTable[(int)((PC)ch).Speaking];
                text += ".\r\n";
                ch.SendText(text);
            }
            else
            {
                Race.Language lang = IntLanguage(ch, arg1);

                if (ch.CanSpeakLanguage(lang))
                {
                    string buf7 = String.Format("You begin speaking {0}.\r\n", Race.LanguageTable[(int)lang]);
                    ((PC)ch).Speaking = lang;
                    ch.SendText(buf7);
                }
                else
                {
                    ch.SendText("You don't know that language!\r\n");
                }
            }
        }

        /// <summary>
        /// Innate mount summoning command for antipaladins and paladins.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void SummonMount(CharData ch, string[] str)
        {
            CharData gch;
            bool isAnti;
            MobTemplate pMobIndex;
            Affect af = new Affect();

            if (ch.IsClass(CharClass.Names.antipaladin))
                isAnti = true;
            else if (ch.IsClass(CharClass.Names.paladin))
                isAnti = false;
            else
            {
                ch.SendText("You scream and yell for a mount.  Strangely nothing comes.\r\n");
                return;
            }
            if (ch.IsAffected( Affect.AFFECT_SUMMON_MOUNT_TIMER))
            {
                ch.SendText("&nIt is too soon to accomplish that!\r\n");
                return;
            }


            // Look to see if they already have a mount.
            foreach (CharData it in Database.CharList)
            {
                gch = it;
                if (gch._master == ch
                        && gch.IsNPC()
                        && (gch._mobIndexData != null)
                        && ((gch._mobIndexData.IndexNumber == 264 && isAnti)
                             || (gch._mobIndexData.IndexNumber == 265 && !isAnti)))
                {
                    ch.SendText("You already have a mount!\r\n");
                    return;
                }
            }

            // If not let them summon one. :)
            if (isAnti)
                pMobIndex = Database.GetMobTemplate(264);
            else
                pMobIndex = Database.GetMobTemplate(265);

            if (pMobIndex == null)
            {
                Log.Error("Commandsummon_mount: phukt pMobIndex!", 0);
                return;
            }

            CharData mount = Database.CreateMobile(pMobIndex);

            /* Must simulate the poor horse running across the world.
            * They arrive with between 303 and 126 moves out of 294-310.
            */
            mount._currentMoves -= MUDMath.Dice(2, 40) + MUDMath.Dice(1, 80) + MUDMath.Dice(4, 2);
            CharData.AddFollower(mount, ch);
            mount.SetAffBit(Affect.AFFECT_CHARM);
            mount.SetActBit(MobTemplate.ACT_NOEXP);
            mount.AddToRoom(ch._inRoom);

            ch.WaitState(MUDMath.FuzzyNumber(Skill.SkillList["summon mount"].Delay));

            SocketConnection.Act("$n&n trots up to you.", mount, null, ch, SocketConnection.MessageTarget.victim);
            SocketConnection.Act("$n&n trots up to $N&n.", mount, null, ch, SocketConnection.MessageTarget.everyone_but_victim);

            if (ch.IsImmortal())
                return;
            af.Value = "summon mount";
            af.Type = Affect.AffectType.skill;
            af.Duration = 48;
            af.SetBitvector(Affect.AFFECT_SUMMON_MOUNT_TIMER);
            ch.AddAffect(af);

            return;
        }

        public static Race.Language IntLanguage(CharData ch, string lang)
        {
            if( ch == null ) return 0;

            if (ch.IsImmortal() && MUDString.IsNumber(lang))
            {
                int ilang;
                Int32.TryParse(lang, out ilang);
                if (ilang >= 0 && ilang < Race.MAX_LANG)
                    return (Race.Language)ilang;
                string buf = String.Format("{0} is not within valid language range(0 to {1})!\r\n", ilang, (Race.MAX_LANG - 1));
                ch.SendText(buf);
                return Race.Language.unknown;
            }

            if (!MUDString.IsPrefixOf(lang, "unknown"))
                return Race.Language.unknown;
            if (!MUDString.IsPrefixOf(lang, "common"))
                return Race.Language.common;
            if (!MUDString.IsPrefixOf(lang, "elven"))
                return Race.Language.elven;
            if (!MUDString.IsPrefixOf(lang, "dwarven"))
                return Race.Language.dwarven;
            if (!MUDString.IsPrefixOf(lang, "centaur"))
                return Race.Language.centaur;
            if (!MUDString.IsPrefixOf(lang, "ogre"))
                return Race.Language.ogre;
            if (!MUDString.IsPrefixOf(lang, "orc"))
                return Race.Language.orcish;
            if (!MUDString.IsPrefixOf(lang, "troll"))
                return Race.Language.troll;
            if (!MUDString.IsPrefixOf(lang, "aquatic elf"))
                return Race.Language.aquaticelf;
            if (!MUDString.IsPrefixOf(lang, "neogi"))
                return Race.Language.neogi;
            if (!MUDString.IsPrefixOf(lang, "thri-kreen"))
                return Race.Language.thri;
            if (!MUDString.IsPrefixOf(lang, "dragon"))
                return Race.Language.dragon;
            if (!MUDString.IsPrefixOf(lang, "magic"))
                return Race.Language.magical;
            if (!MUDString.IsPrefixOf(lang, "goblin"))
                return Race.Language.goblin;
            if (!MUDString.IsPrefixOf(lang, "god"))
                return Race.Language.god;
            if (!MUDString.IsPrefixOf(lang, "halfling"))
                return Race.Language.halfling;
            if (!MUDString.IsPrefixOf(lang, "githyanki"))
                return Race.Language.githyanki;
            if (!MUDString.IsPrefixOf(lang, "drow"))
                return Race.Language.drow;
            if (!MUDString.IsPrefixOf(lang, "kobold"))
                return Race.Language.kobold;
            if (!MUDString.IsPrefixOf(lang, "gnome"))
                return Race.Language.gnome;
            if (!MUDString.IsPrefixOf(lang, "animal"))
                return Race.Language.animal;
            if (!MUDString.IsPrefixOf(lang, "duergar"))
                return Race.Language.duergar;
            if (!MUDString.IsPrefixOf(lang, "githzerai"))
                return Race.Language.githzerai;
            if (!MUDString.IsPrefixOf(lang, "gnoll"))
                return Race.Language.gnoll;
            if (!MUDString.IsPrefixOf(lang, "rakshasa"))
                return Race.Language.rakshasa;
            if (!MUDString.IsPrefixOf(lang, "minotaur"))
                return Race.Language.minotaur;
            if (!MUDString.IsPrefixOf(lang, "illithid"))
                return Race.Language.illithid;
            if (!MUDString.IsPrefixOf(lang, "barbarian"))
                return Race.Language.barbarian;

            return Race.Language.unknown;
        }

        public static void JusticeCommand(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch._inRoom == null || ch._inRoom.Area == null)
                return;

            if (ch._inRoom.Area.JusticeType == 0)
            {
                ch.SendText("&+BYou are not in an area controlled by justice.&n\r\n");
                return;
            }
            ch.SendText("&+BYou are in an area controlled by justice.&n\r\n");
            string buf = String.Format("&+B{0}&n\r\n", Crime.GetInvaderString(ch._inRoom.Area.JusticeType));
            ch.SendText(buf);
            ch.SendText("\r\n&+BPossible crimes are:\r\n&n");

            ch.SendText("&+bAttempted Murder&n\r\n");
            ch.SendText("&+bTheft&n\r\n");

            return;
        }

        /// <summary>
        /// Paladin "lay hands" healing command.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void LayHands(CharData ch, string[] str)
        {
            if( ch == null ) return;
            Affect af = new Affect();

            if (ch._level <= Limits.LEVEL_AVATAR && !ch.IsClass(CharClass.Names.paladin))
            {
                ch.SendText("&nYou aren't holy enough to do that!\r\n");
                return;
            }

            if (ch.IsAffected(Affect.AFFECT_LAYHANDS_TIMER))
            {
                ch.SendText("&nIt is too soon to accomplish that!\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("&nLayhands on whom?\r\n");
                return;
            }

            CharData victim = ch.GetCharRoom(str[0]);
            if (!victim)
            {
                ch.SendText("&nThey're not here.\r\n");
                return;
            }

            if (victim != ch && ch._fighting)
            {
                ch.SendText("&nYou can only layhands on yourself while fighting.\r\n");
                return;
            }

            if (victim._hitpoints < victim.GetMaxHit())
                victim._hitpoints = Math.Min(victim._hitpoints + 300, victim.GetMaxHit());
            victim.UpdatePosition();

            if (ch != victim)
            {
                SocketConnection.Act("You lay your hands upon $N.", ch, null, victim, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n lays $s hands upon you.", ch, null, victim, SocketConnection.MessageTarget.victim);
                SocketConnection.Act("$n&n lays $s hands upon $N&n.", ch, null, victim, SocketConnection.MessageTarget.everyone_but_victim);
            }
            else
            {
                ch.SendText("&nYou layhands upon yourself.\r\n");
                SocketConnection.Act("$n&n lays hands upon $mself&n.", ch, null, null, SocketConnection.MessageTarget.room);
            }
            victim.SendText("&+WYou feel a warm glow!&n\r\n");
            if (ch._level >= Limits.LEVEL_AVATAR)
                return;
            af.Value = "layhands timer";
            af.Type = Affect.AffectType.skill;
            af.Duration = 24;
            af.SetBitvector(Affect.AFFECT_LAYHANDS_TIMER);
            ch.AddAffect(af);
        }

        /// <summary>
        /// Search the local area for food.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Forage(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int indexNumber;
            Object obj = null;
            int[] flist = new int[10] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 25 };

            if (!ch._inRoom)
            {
                ch.SendText("There's no foraging to be done here.\r\n");
                return;
            }

            if (ch._flyLevel != 0)
            {
                ch.SendText("Right, you're going to find something way up here.\r\n");
                return;
            }
            int chance = 10 + (ch.GetCurrLuck() / 20);
            if (ch.IsClass(CharClass.Names.ranger) || ch.IsClass(CharClass.Names.hunter) || ch.IsImmortal())
                chance = 75;
            if (chance < MUDMath.NumberPercent())
            {
                ch.SendText("You don't find anything at all.\r\n");
                ch._wait += 10;
                return;
            }
            ch._wait += 15;
            TerrainType sector = ch._inRoom.TerrainType;
            // TODO: FIXME: Don't use hard-coded item numbers!
            switch (sector)
            {
                default:
                    ch.SendText("Nothing edible could be growing here.\r\n");
                    return;
                case TerrainType.field:
                    flist[0] = 80;
                    flist[1] = 84;
                    flist[2] = 86;
                    flist[6] = 91;
                    flist[7] = 80;
                    break;
                case TerrainType.hills:
                    flist[0] = 82748;
                    flist[1] = 86;
                    flist[2] = 92;
                    flist[6] = 94;
                    break;
                case TerrainType.underground_wild:
                    flist[0] = 3352;
                    flist[5] = 3352;
                    flist[6] = 7711;
                    flist[1] = 85;
                    flist[2] = 88;
                    flist[7] = 82;
                    flist[8] = 83;
                    break;
                case TerrainType.swamp:
                    flist[0] = 3352;
                    flist[1] = 88;
                    flist[5] = 94;
                    flist[6] = 83;
                    flist[7] = 89;
                    break;
                case TerrainType.forest:
                    flist[0] = 2057;
                    flist[1] = 81651;
                    flist[2] = 90;
                    flist[3] = 93;
                    flist[4] = 92;
                    flist[5] = 90;
                    flist[6] = 87;
                    flist[7] = 84;
                    break;
            } //end switch
            if (ch.IsClass(CharClass.Names.ranger) || ch.IsClass(CharClass.Names.hunter))
                indexNumber = flist[MUDMath.NumberRange(0, 9)];
            else
                indexNumber = flist[MUDMath.NumberRange(0, 4)];
            if (indexNumber == 0)
            {
                ch.SendText("You find nothing edible.\r\n");
                return;
            }
            string buf = String.Format("Forage: {0} found index number {1} in room {2}.", ch._name, indexNumber, ch._inRoom.IndexNumber);
            ImmortalChat.SendImmortalChat(null, ImmortalChat.IMMTALK_SPAM, 0, buf);
            /*
            if (fvnum == StaticObjects.OBJECT_NUMBER_SPRING) {
            //don't allow endless springs
            for ( obj = ch.in_room.contents; obj; obj = obj.next_content ) {
            if (obj.pIndexData.vnum == fvnum) {
            Descriptor._actFlags("You notice the $p&n.", ch, obj, null, Descriptor.MessageTarget.character);
            return;
            }
            }
            }
            */
            ObjTemplate pObjIndex = Database.GetObjTemplate(indexNumber);
            // Foraging found an object that doesn't exist -- log an error and fail gracefully.
            if (pObjIndex == null)
            {
                Log.Error("Forage: invalid object index number " + indexNumber + " in terrain type " + sector + ".");
                ch.SendText("The area appears to have been picked clean.\r\n");
                return;
            }
            obj = Database.CreateObject(pObjIndex, 1);
            obj.AddToRoom(ch._inRoom);
            obj.FlyLevel = 0;
            if (indexNumber == StaticObjects.OBJECT_NUMBER_SPRING) // give spring a timer;
            {
                obj.Timer = 10 + MUDMath.NumberRange(1, 20);
            }
            SocketConnection.Act("You find $p&n.", ch, obj, null, SocketConnection.MessageTarget.character);
            SocketConnection.Act("$n&n forages around and finds $p&n.", ch, obj, null, SocketConnection.MessageTarget.room);
            return;
        }

        /// <summary>
        /// Command to set your level of aggressiveness.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Aggressive(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string arg1 = String.Empty;

            if (ch.IsNPC())
                return;
            if (ch.IsClass(CharClass.Names.paladin))
            {
                ch.SendText("Your beliefs prevent you from acting in such a manner.\r\n");
                return;
            }

            if (arg1.Length > 0)
            {
                if (MUDString.NameContainedIn("off", arg1) || MUDString.NameContainedIn("none", arg1))
                {
                    ((PC)ch).AggressiveLevel = -1;
                }
                else
                {
                    int aggr;
                    Int32.TryParse(arg1, out aggr);
                    if (aggr < -1 || aggr > ch.GetMaxHit())
                    {
                        ch.SendText("Value out of range.\r\n");
                        return;
                    }
                    ((PC)ch).AggressiveLevel = aggr;
                }
            }
            string buf;
            if (((PC)ch).AggressiveLevel == -1)
            {
                buf = "You are not aggressive.\r\n";
            }
            else
            {
                buf = "You are aggressive to creatures if hit points above " + ((PC)ch).AggressiveLevel + ".\r\n";
            }
            ch.SendText(buf);
            return;
        }

        /// <summary>
        /// Allows the player to generate random numbers, which are displayed to the room.  Typically used for
        /// rolling for loot.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Dice(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int number, sides;
            string buf;

            if (str.Length < 1 || String.IsNullOrEmpty(str[0]))
            {
                ch.SendText("You roll no zero-sided dice.  Strangely enough you get a 1.\r\n");
                return;
            }

            if (str.Length < 2 || String.IsNullOrEmpty(str[1]))
            {
                ch.SendText("You roll a zero-sided die.  You get the square root of -1.\r\n");
                return;
            }

            if (!MUDString.IsNumber(str[0]) || !MUDString.IsNumber(str[1]))
            {
                ch.SendText("Usage:  dice <number of dice> <number of sides>\r\n");
                return;
            }

            Int32.TryParse(str[0], out number);
            Int32.TryParse(str[1], out sides);

            if (number <= 0 || number > 1000 || sides <= 0 || sides > 1000)
            {
                ch.SendText("C'mon! Gimme some numbers I can work with here.\r\n");
                return;
            }
            if (number == 1)
            {
                buf = String.Format("&+WWith stylish flair, $n&n&+W rolls a {0}-sided die, resulting in the number {1}&n", sides, MUDMath.Dice(number, sides));
            }
            else
            {
                buf = String.Format("&n&+WWith a wink, $n&n&+W rolls {0} dice with {1} sides, resulting in the number {2}.&n", number, sides, MUDMath.Dice(number, sides));
            }
            SocketConnection.Act(buf, ch, null, null, SocketConnection.MessageTarget.all);
        }

        /// <summary>
        /// Command to add a spell to your spellbook.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Scribe(CharData ch, string[] str)
        {
            if( ch == null ) return;

            bool found = false;

            if (ch.IsNPC())
                return;

            if (!ch._inRoom)
            {
                ch.SendText("You're not in a proper place for scribing.\r\n");
                return;
            }

            CharData teacher = null;
            foreach (CharData iteacher in ch._inRoom.People)
            {
                if (!iteacher.IsNPC())
                    continue;
                if (iteacher.HasActBit(MobTemplate.ACT_TEACHER))
                {
                    teacher = iteacher;
                    break;
                }
            }

            if (teacher == null)
            {
                ch.SendText("Nobody here can teach you anything.\r\n");
                return;
            }

            foreach (Object quill in ch._carrying)
            {
                if (quill.ItemType == ObjTemplate.ObjectType.pen)
                {
                    found = true;
                    break;
                }
            }

            if (!found)
            {
                ch.SendText("You have nothing to write with!\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Scribe what?\r\n");
                return;
            }

            Spell spell = StringLookup.SpellLookup(String.Join(" ", str));

            if (spell == null)
            {
                ch.SendText("No such spell.\r\n");
                return;
            }

            if ((spell.SpellCircle[(int)teacher._charClass.ClassNumber] * 4) >
                    (teacher._level + 3))
            {
                ch.SendText("The teacher does not know that spell.\r\n");
                return;
            }

            if (!spell.CanBeScribed)
            {
                ch.SendText("That spell is not common knowledge - You must quest for it.\r\n");
                return;
            }

            if ((spell.SpellCircle[(int)ch._charClass.ClassNumber] * 4) > (ch._level + 3))
            {
                ch.SendText("That spell is beyond you.\r\n");
                return;
            }

            if (!((PC)ch).SpellAptitude.ContainsKey(spell.Name) || ((PC)ch).SpellAptitude[spell.Name] < 1)
            {
                // Scribe is used so rarely give them 5 chances to learn it...
                ch.PracticeSkill("Scribe");
                ch.PracticeSkill("Scribe");
                ch.PracticeSkill("Scribe");
                ch.PracticeSkill("Scribe");
                ch.PracticeSkill("Scribe");
                string buf = String.Format("You scribe {0}.\r\n", spell.Name);
                ch.SendText(buf);
                ((PC)ch).SpellAptitude[spell.Name] = Limits.BASE_SPELL_ADEPT;
                int chance = 0;
                if (ch.HasSkill("scribe"))
                {
                    chance = ((PC)ch).SkillAptitude["Scribe"];
                }
                if (MUDMath.NumberPercent() < chance)
                    ((PC)ch).SpellAptitude[spell.Name] += 5;
                if (MUDMath.NumberPercent() < chance)
                    ((PC)ch).SpellAptitude[spell.Name] += 4;
                if (MUDMath.NumberPercent() < chance)
                    ((PC)ch).SpellAptitude[spell.Name] += 3;
                if (MUDMath.NumberPercent() < chance)
                    ((PC)ch).SpellAptitude[spell.Name] += 2;
                if (MUDMath.NumberPercent() < chance)
                    ((PC)ch).SpellAptitude[spell.Name] += 1;
                ch.WaitState(Skill.SkillList["Scribe"].Delay);
            }
            else
            {
                ch.SendText("You already know that spell.\r\n");
            }

            return;
        }

        /// <summary>
        /// Play -- using a bard song with an instrument.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Play(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Sing(ch, str);
        }

        /// <summary>
        /// Sing -- using a bard song without an instrument.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Sing(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (!ch.IsClass(CharClass.Names.bard) && !ch.IsImmortal())
            {
                ch.SendText("You don't know how to sing.\r\n");
                return;
            }

            if (ch.IsAffected(Affect.AFFECT_MINOR_PARA) ||
                    ch.IsAffected(Affect.AFFECT_HOLD))
            {
                ch.SendText("You can't Sing when you're paralyzed!\r\n");
                return;
            }

            if (ch.HasActBit(Affect.AFFECT_MUTE))
            {
                ch.SendText("You have no voice!\r\n");
                return;
            }

            if (str.Length == 0)
            {
                if (ch.IsAffected(Affect.AFFECT_SINGING))
                {
                    ch.RemoveAffect(Affect.AFFECT_SINGING);
                    ch.SendText("You stop singing.\r\n");
                }
                else
                {
                    ch.SendText("Sing what?\r\n");
                }
                return;
            }

            Magic.Cast(ch, String.Join(" ", str));
        }

        /// <summary>
        /// Command to cast a spell.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Cast(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if ((ch.IsClass(CharClass.Names.psionicist) || ch.IsClass(CharClass.Names.enslaver)) && !ch.IsImmortal())
            {
                ch.SendText("Psionicists use the WILL command to invoke their powers.\r\n");
                return;
            }

            if (ch.IsClass(CharClass.Names.bard) && !ch.IsImmortal())
            {
                ch.SendText("Bards use the SING or PLAY commands to invoke their powers.\r\n");
                return;
            }

            if (ch._riding && ch._inRoom == ch._riding._inRoom)
            {
                ch.SendText("You cannot cast while mounted!\r\n");
                return;
            }

            if (ch.IsAffected( Affect.AFFECT_MINOR_PARA) ||
                    ch.IsAffected( Affect.AFFECT_HOLD))
            {
                ch.SendText("You can't cast when you're paralyzed!\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Cast what spell where?\r\n");
                return;
            }

            Magic.Cast(ch, String.Join(" ", str));
        }

        /// <summary>
        /// Psionics should be instantaneous and exempt from the casting stuff, and suffer
        /// lag after their power goes off.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Will(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (!ch.IsClass(CharClass.Names.psionicist) && !ch.IsClass(CharClass.Names.enslaver) && !ch.IsImmortal())
            {
                ch.SendText("Your mind is much too puny for you to focus your will.\r\n");
                return;
            }

            if (ch.IsClass(CharClass.Names.bard) && !ch.IsImmortal())
            {
                ch.SendText("Bards use the SING or PLAY commands to invoke their powers.\r\n");
                return;
            }
                        
            if (ch._riding && ch._riding._inRoom == ch._inRoom)
            {
                ch.SendText("It's too hard to concentrate! Dismount.\r\n");
                return;
            }
      
            // Psis should be able to will stuff when paralyzed, thus no check for para.

            if (str.Length == 0)
            {
                ch.SendText("Will which what where?\r\n");
                return;
            }

            Magic.Cast(ch, String.Join(" ", str));
        }

        /// <summary>
        /// Memorizing spells for holy types, i.e. Clerics.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Pray(CharData ch, string[] str)
        {
            if( ch == null ) return;

            // Mobiles cannot mem spells
            if (ch.IsNPC())
                return;

            // Check to see if they are allowed to mem anything
            switch (ch._charClass.ClassNumber)
            {
                default:
                    break;
                case CharClass.Names.hunter:
                case CharClass.Names.shaman:
                case CharClass.Names.elementAir:
                case CharClass.Names.elementFire:
                case CharClass.Names.elementWater:
                case CharClass.Names.elementEarth:
                case CharClass.Names.illusionist:
                case CharClass.Names.sorcerer:
                case CharClass.Names.ranger:
                case CharClass.Names.bard:
                case CharClass.Names.chronomancer:
                case CharClass.Names.enchanter:
                case CharClass.Names.necromancer:
                    ch.SendText("You memorize your spells, not pray for them.\r\n");
                    return;
            }

            if (ch._charClass.MemType == CharClass.MemorizationType.None)
            {
                ch.SendText("Praying for spells really isn't your kind of thing.\r\n");
                return;
            }

            string text = String.Join(" ", str);
            Magic.Memorize(ch, text, true);
        }

        /// <summary>
        /// Command to list all areas in the game.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        static public void Areas(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string buf1 = String.Empty;
            Area area;

            string buf = String.Empty;
            foreach (Area it in Database.AreaList)
            {
                area = it;
                
                if (ch.IsImmortal())
                {
                    buf = String.Format("{0} {1} #{3}-{4} {2}\r\n",
                                            MUDString.PadStr(StringConversion.RangeString(area), 5),
                                            MUDString.PadStr(area.Author, 15),
                                            area.Name,
                                            MUDString.PadInt(area.LowIndexNumber,5),
                                            MUDString.PadInt(area.HighIndexNumber, 5));
                }
                else
                {
                    buf = String.Format("{0} {1} {2} \r\n",
                                            MUDString.PadStr(StringConversion.RangeString(area), 5),
                                            MUDString.PadStr(area.Author, 15),
                                            area.Name);
                }
                buf1 += buf;
            }

            ch.SendText(buf1);
            return;
        }

        /// <summary>
        /// Gets object counts and displays the amount of memory used by them.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Memory(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string buf = String.Empty;

            CharData realChar = ch.GetChar();

            if (!realChar.Authorized("memory"))
                return;

            //unsafe
            //{
            //    buf += String.Format("Affects     {0} - {1} bytes each ({2} total)\r\n",
            //        Affect.Count, sizeof(Affect), Affect.Count * sizeof(Affect));
            //    buf += String.Format("Areas       {0} - {1} bytes each ({2} total)\r\n",
            //        Area.Count, sizeof(Area), Area.Count * sizeof(Area));
            //    buf += String.Format("ExtDesc     {0} - {1} bytes each ({2} total)\r\n",
            //        ExtendedDescription.Count, sizeof(ExtendedDescription), ExtendedDescription.Count *
            //        sizeof(ExtendedDescription));
            //    buf += String.Format("Exits       {0} - {1} bytes each ({2} total)\r\n",
            //        Exit.Count, sizeof(Exit), Exit.Count * sizeof(Exit));
            //    buf += String.Format("Helps       {0} - {1} bytes each ({2} total)\r\n",
            //        Help.Count, sizeof(Help), Help.Count * sizeof(Help));
            //    buf += String.Format("Socials     {0}\r\n",
            //        Social.Count, sizeof(Social), Social.Count * sizeof(Social));
            //    buf += String.Format("MobTemplate {0} - {1} bytes each ({2} total)\r\n",
            //        MobTemplate.Count, sizeof(MobTemplate), MobTemplate.Count * sizeof(MobTemplate));
            //    buf += String.Format("CharData    {0} - {1} bytes each ({2} total)\r\n",
            //        CharData.Count, sizeof(CharData), CharData.Count * sizeof(CharData));
            //    buf += String.Format("PC          {0} - {1} bytes each ({2} total)\r\n",
            //        PC.Count, sizeof(PC), PC.Count * sizeof(PC));
            //    buf += String.Format("ObjTemplate {0} - {1} bytes each ({2} total)\r\n",
            //        ObjTemplate.Count, sizeof(ObjTemplate), ObjTemplate.Count * sizeof(ObjTemplate));
            //    buf += String.Format("Objects     {0} - {1} bytes each ({2} total)\r\n",
            //        Object.Count, sizeof(Object), Object.Count * sizeof(Object));
            //    buf += String.Format("Resets      {0} - {1} bytes each ({2} total)\r\n",
            //        Reset.Count, sizeof(Reset), Reset.Count * sizeof(Reset));
            //    buf += String.Format("Room        {0} - {1} bytes each ({2} total)\r\n",
            //        Room.Count, sizeof(Room), Room.Count * sizeof(Room));
            //    buf += String.Format("Shops       {0} - {1} bytes each ({2} total)\r\n",
            //        Shop.Count, sizeof(Shop), Shop.Count * sizeof(Shop));
            //    buf += String.Format("MoveScript  {0} - {1} bytes each ({2} total)\r\n",
            //        MovementScript.Count, sizeof(MovementScript), MovementScript.Count * sizeof(MovementScript));
            //    buf += String.Format("Quests      {0} - {1} bytes each ({2} total)\r\n",
            //              QuestTemplate.Count, sizeof(QuestTemplate), QuestTemplate.Count * sizeof(QuestTemplate));
            //    buf += String.Format("- Msgs      {0} - {1} bytes each ({2} total)\r\n",
            //              TalkData.Count, sizeof(TalkData), TalkData.Count * sizeof(TalkData));
            //    buf += String.Format("- Qdata     {0} - {1} bytes each ({2} total)\r\n",
            //              QuestData.Count, sizeof(QuestData), QuestData.Count * sizeof(QuestData));
            //    buf += String.Format("- Qitem     {0} - {1} bytes each ({2} total)\r\n",
            //              QuestItem.Count, sizeof(QuestItem), QuestItem.Count * sizeof(QuestItem));
            //    buf += String.Format("Events      {0} - {1} bytes each ({2} total)\r\n",
            //        Event.Count, sizeof(Event), Event.Count * sizeof(Event));
            //    buf += String.Format("Traps       {0} - {1} bytes each ({2} total)\r\n",
            //        Trap.Count, sizeof(Trap), Trap.Count * sizeof(Trap));
            //    buf += String.Format("Memdata     {0} - {1} bytes each ({2} total)\r\n",
            //        MemorizeData.Count, sizeof(MemorizeData), MemorizeData.Count * sizeof(MemorizeData));
            //    buf += String.Format("Siteban     {0} - {1} bytes each ({2} total)\r\n",
            //        BanData.Count, sizeof(BanData), BanData.Count * sizeof(BanData));
            //    buf += String.Format("Socket      {0} - {1} bytes each ({2} total)\r\n",
            //        SocketConnection.Count, sizeof(SocketConnection), SocketConnection.Count * sizeof(SocketConnection));
            //    buf += String.Format("Vehicle     {0} - {1} bytes each ({2} total)\r\n",
            //        Vehicle.Count, sizeof(Vehicle), Vehicle.Count * sizeof(Vehicle));
            //    buf += String.Format("Crime       {0} - {1} bytes each ({2} total)\r\n",
            //        Crime.Count, sizeof(Crime), Crime.Count * sizeof(Crime));
            //}
            buf += String.Format("Affects     {0}\r\n", Affect.Count);
            buf += String.Format("Areas       {0}\r\n", Area.Count);
            buf += String.Format("ExtDesc     {0}\r\n", ExtendedDescription.Count);
            buf += String.Format("Exits       {0}\r\n", Exit.Count);
            buf += String.Format("Helps       {0}\r\n", Help.Count);
            buf += String.Format("Socials     {0}\r\n", Social.Count);
            buf += String.Format("MobTemplate {0}\r\n", MobTemplate.Count);
            buf += String.Format("CharData    {0}\r\n", CharData.Count);
            buf += String.Format("PC          {0}\r\n", PC.Count);
            buf += String.Format("ObjTemplate {0}\r\n", ObjTemplate.Count);
            buf += String.Format("Objects     {0}\r\n", Object.Count);
            buf += String.Format("Resets      {0}\r\n", Reset.Count);
            buf += String.Format("Room        {0}\r\n", Room.Count);
            buf += String.Format("Shops       {0}\r\n", Shop.Count);
            buf += String.Format("Quests      {0}\r\n", QuestTemplate.Count);
            buf += String.Format("- Msgs      {0}\r\n", TalkData.Count);
            buf += String.Format("- Qdata     {0}\r\n", QuestData.Count);
            buf += String.Format("- Qitem     {0}\r\n", QuestItem.Count);
            buf += String.Format("Events      {0}\r\n", Event.Count);
            buf += String.Format("Traps       {0}\r\n", Trap.Count);
            buf += String.Format("Memdata     {0}\r\n", MemorizeData.Count);
            buf += String.Format("Siteban     {0}\r\n", BanData.Count);
            buf += String.Format("Socket      {0}\r\n", SocketConnection.Count);
            buf += String.Format("Vehicle     {0}\r\n", Vehicle.Count);
            buf += String.Format("Crime       {0}\r\n", Crime.Count);
            ch.SendText(buf);

            return;
        }

        /// <summary>
        /// Meditate command.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Meditate(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch.IsNPC())
                return;

            if (!ch.HasSkill("meditate"))
            {
                ch.SendText("You don't know how to meditate.\r\n");
                return;
            }

            if (ch.HasActBit(PC.PLAYER_MEDITATING))
            {
                ch.RemoveActBit(PC.PLAYER_MEDITATING);
                ch.SendText("You stop meditating.\r\n");
            }

            if (ch._position != Position.resting)
            {
                ch.SendText("You must be resting in order to meditate.\r\n");
                return;
            }

            if (ch._fighting != null)
            {
                ch.SendText("Meditation during battle leads to permenant inner peace.\r\n");
                return;
            }

            ch.SetActBit(PC.PLAYER_MEDITATING);
            ch.WaitState(Skill.SkillList["meditate"].Delay);
            ch.PracticeSkill("meditate");
            ch.SendText("You start meditating...\r\n");
            return;

        }

        /// <summary>
        /// Command to forget a spell.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Forget(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch.IsNPC())
                return;

            if (str.Length == 0)
            {
                ch.SendText("Looks like your forgot what you were going to forget.\r\n");
                return;
            }

            if (((PC)ch).Memorized.Count == 0)
            {
                ch.SendText("You don't have anything to forget.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[0], "all"))
            {
                Magic.ForgetAllSpells(ch);
                ch.SendText("You forget everything.\r\n");
                return;
            }

            Spell spell = StringLookup.SpellLookup(str[0]);
            if (spell == null)
            {
                ch.SendText("Forget what?\r\n");
                return;
            }

            foreach (MemorizeData mem in ((PC)ch).Memorized)
            {
                if (mem.Name == spell.Name)
                {
                    string buf = String.Format("You forget {0}.\r\n", spell.Name);
                    ch.SendText(buf);
                    // Remove the memorization data from the player.
                    if (!((PC)ch).Memorized.Remove(mem))
                    {
                        Log.Error("Unable to remove memorization data from player", 0);
                    }
                    return;
                }
            }

            ch.SendText("You do not have that spell memorized.\r\n");
            return;
        }

        /// <summary>
        /// Command to memorize a spell.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Memorize(CharData ch, string[] str)
        {
            if( ch == null ) return;

            // Mobiles cannot mem spells
            if (ch.IsNPC())
                return;

            // Check to see if they are allowed to mem anything
            switch (ch._charClass.ClassNumber)
            {
                default:
                    break;
                case CharClass.Names.cleric:
                case CharClass.Names.druid:
                case CharClass.Names.paladin:
                case CharClass.Names.antipaladin:
                    ch.SendText("You must pray for your spells!\r\n");
                    return;
            }

            if (ch._charClass.MemType == CharClass.MemorizationType.None)
            {
                ch.SendText("Memorizing spells really isn't your kind of thing.\r\n");
                return;
            }

            string argument = String.Join(" ", str);
            Magic.Memorize(ch, argument, false);
        }

        /// <summary>
        /// Gets currency statistics on logged-in players.
        /// 
        /// We may want to go as far as to split currency into racewar sides and
        /// poll pfiles for totals for not-in-game players.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Economy(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (str.Length > 0 && ("mostexpensive").StartsWith(str[0]))
            {
                int[] items = new int[Enum.GetValues(typeof(ObjTemplate.ObjectType)).Length];
                int[] itemValues = new int[items.Length];
                int[] armors = new int[31];
                int[] armorValues = new int[31];
                foreach (Area area in Database.AreaList)
                {
                    foreach (ObjTemplate obj in area.Objects)
                    {
                        if (obj.Cost > itemValues[(int)obj.ItemType])
                        {
                            itemValues[(int)obj.ItemType] = obj.Cost;
                            items[(int)obj.ItemType] = obj.IndexNumber;
                        }
                        if (obj.ItemType == ObjTemplate.ObjectType.armor)
                        {
                            for (int i = 0; i < 32; i++)
                            {
                                if ((obj.WearFlags[0] & (1 << i)) != 0)
                                {
                                    if (obj.Cost > armorValues[i])
                                    {
                                        armorValues[i] = obj.Cost;
                                        armors[i] = obj.IndexNumber;
                                    }
                                }
                            }
                        }
                    }
                }
                for (int i = 0; i < items.Length; i++)
                {
                    if (items[i] != 0)
                    {
                        ch.SendText("ItemType: " + ((ObjTemplate.ObjectType)i).ToString() + " " + Database.GetObjTemplate(items[i]).ShortDescription + " = " + itemValues[i] + "c.\r\n");
                    }
                    else
                    {
                        ch.SendText("ItemType: " + ((ObjTemplate.ObjectType)i).ToString() + " has no items of value.\r\n");
                    }
                }
                for (int i = 0; i < armors.Length; i++)
                {
                    if (armors[i] != 0)
                    {
                        ch.SendText("ArmorSlot: " + (1 << i) + " " + Database.GetObjTemplate(armors[i]).ShortDescription + "&n = " + armorValues[i] + "c.\r\n");
                    }
                    else
                    {
                        ch.SendText("ArmorSlot: " + (1 << i) + " has no items of value.\r\n");
                    }
                }
                return;
            }

            CharData wch;
            Coins player = new Coins();
            Coins mob = new Coins();
            Coins bank = new Coins();

            foreach (CharData it in Database.CharList)
            {
                wch = it;
                if (wch.IsNPC())
                {
                    mob.Copper += wch.GetCopper();
                    mob.Silver += wch.GetSilver();
                    mob.Gold += wch.GetGold();
                    mob.Platinum += wch.GetPlatinum();
                }
                else
                {
                    player.Copper += wch.GetCopper();
                    player.Silver += wch.GetSilver();
                    player.Gold += wch.GetGold();
                    player.Platinum += wch.GetPlatinum();
                    bank.Copper += ((PC)wch).Bank.Copper;
                    bank.Silver += ((PC)wch).Bank.Silver;
                    bank.Gold += ((PC)wch).Bank.Gold;
                    bank.Platinum += ((PC)wch).Bank.Platinum;
                }
            }

            int mobcash = mob.Copper + (mob.Silver * 10) + (mob.Gold * 100) + (mob.Platinum * 100);
            int playercash = player.Copper + (player.Silver * 10) + (player.Gold * 100) + (player.Platinum * 100);
            int playerbank = bank.Copper + (bank.Silver * 10) + (bank.Gold * 100) + (bank.Platinum * 100);
            int totalcirculation = mobcash + playercash;
            int totaleconomy = totalcirculation + playerbank;

            string buf = "Mobiles currently control " + mobcash + " &+ycopper&n in circulating currency.\r\n";
            buf += "Players currently control " + playercash + " &+ycopper&n in circulating currency.\r\n";
            buf += "Players currently control " + playerbank + " &+ycopper&n in non-circulating currency.\r\n";

            // Protect against divide by 0.
            if (mobcash == 0)
                mobcash = 1;
            double playerpct1 = ((double)playercash * 100.0) / ((double)(totalcirculation));
            double playerpct2 = (((double)playercash + (double)playerbank) * 100.0) /
                                ((double)totaleconomy);
            buf += "Players currently control " + playerpct1 + " percent of circulating currency.\r\n";
            buf += "Players currently control " + playerpct2 + " percent of total currency.\r\n";

            buf += "&+yMaterial Costs:&n\r\n";
            int place = 0;
            foreach (Material mat in Material.Table)
            {
                buf += MUDString.PadStr(mat.ShortDescription, 14) + ":" + MUDString.PadStr(mat.Value.ToString(), 4);
                if ((place % 3) == 2)
                {
                    buf += "\r\n";
                }
                else
                {
                    buf += "  ";
                }
                ++place;
            }
            ch.SendText(buf);
            ch.SendText("Type 'economy mostexpensive' to show most valuable item of each type.\r\n");
        }

        /// <summary>
        /// Bounty-related commands.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="argument"></param>
        public static void BountyCommand(CharData ch, string[] str)
        {
            if( ch == null ) return;

            // Bounty set: set a bounty on a player.
            if (str.Length > 0 && str[0].StartsWith("set", StringComparison.CurrentCultureIgnoreCase))
            {
                ch.SendText("Setting bounties is not enabled yet.");
                return;
            }

            if (str.Length > 0 && str[0].StartsWith("renew", StringComparison.CurrentCultureIgnoreCase))
            {
                ch.SendText("Renewing bounties is not enabled yet.");
            }

            // Bounty with no arguments: show existing bounties.
            if (str.Length == 0)
            {
                string output = String.Empty;
                foreach (Bounty bounty in Bounty._bounties)
                {
                    if (bounty.Type == Bounty.BountyType.player)
                    {
                        output += bounty.Name + ": " + bounty.Amount + " (Expires " + bounty.Expiration + ").\r\n";
                    }
                    else
                    {
                        output += bounty.Name + ": " + bounty.Amount + " each, up to " + bounty.Quantity;
                        if (bounty.AllowDuplicates == false)
                        {
                            output += " different";
                        }
                        output += " members, (Expires " + bounty.Expiration + ").\r\n";
                    }
                }
                ch.SendText(output);
                return;
            }

        }

        /// <summary>
        /// Command for corpse carving.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Carve(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object weap;
            Race.Parts value;

            if (str.Length == 0)
            {
                ch.SendText("What do you want to carve?\r\n");
                return;
            }

            Object corpse = ch.GetObjHere(str[0]);
            if (!corpse)
            {
                ch.SendText("I don't see that around here.\r\n");
                return;
            }

            if (corpse.ItemType != ObjTemplate.ObjectType.pc_corpse)
            {
                ch.SendText("That's not a player corpse!\r\n");
                return;
            }

            if (str.Length < 2)
            {
                ch.SendText("Parts of that corpse that are left:\r\n");
                if (corpse.Values[0] == 0)
                {
                    ch.SendText("None.\r\n");
                }
                else
                {
                    ch.SendText(StringConversion.PartsBitString((Race.Parts)corpse.Values[0]));
                }
                return;
            }

            // 11 is for piercing eapons
            if (!(weap = Object.GetEquipmentOnCharacter(ch, ObjTemplate.WearLocation.hand_one)) || weap.Values[3] != 11)
            {
                ch.SendText("You need some sort of stabbing weapon for carving.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[1], "head"))
                value = Race.Parts.skull;
            else if (!MUDString.StringsNotEqual(str[1], "arms"))
                value = Race.Parts.arms;
            else if (!MUDString.StringsNotEqual(str[1], "legs"))
                value = Race.Parts.legs;
            else if (!MUDString.StringsNotEqual(str[1], "heart"))
                value = Race.Parts.heart;
            else if (!MUDString.StringsNotEqual(str[1], "brains"))
                value = Race.Parts.brains;
            else if (!MUDString.StringsNotEqual(str[1], "guts"))
                value = Race.Parts.guts;
            else if (!MUDString.StringsNotEqual(str[1], "hands"))
                value = Race.Parts.hands;
            else if (!MUDString.StringsNotEqual(str[1], "feet"))
                value = Race.Parts.feet;
            else if (!MUDString.StringsNotEqual(str[1], "fingers"))
                value = Race.Parts.fingers;
            else if (!MUDString.StringsNotEqual(str[1], "ears"))
                value = Race.Parts.ears;
            else if (!MUDString.StringsNotEqual(str[1], "eyes"))
                value = Race.Parts.eyes;
            else if (!MUDString.StringsNotEqual(str[1], "tongue"))
                value = Race.Parts.tongue;
            else if (!MUDString.StringsNotEqual(str[1], "eyestalks"))
                value = Race.Parts.eyestalks;
            else if (!MUDString.StringsNotEqual(str[1], "tentacles"))
                value = Race.Parts.tentacles;
            else if (!MUDString.StringsNotEqual(str[1], "fins"))
                value = Race.Parts.fins;
            else if (!MUDString.StringsNotEqual(str[1], "wings"))
                value = Race.Parts.wings;
            else if (!MUDString.StringsNotEqual(str[1], "tail"))
                value = Race.Parts.tail;
            else if (!MUDString.StringsNotEqual(str[1], "claws"))
                value = Race.Parts.claws;
            else if (!MUDString.StringsNotEqual(str[1], "fangs"))
                value = Race.Parts.fangs;
            else if (!MUDString.StringsNotEqual(str[1], "scales"))
                value = Race.Parts.scales;
            else if (!MUDString.StringsNotEqual(str[1], "horns"))
                value = Race.Parts.horns;
            else if (!MUDString.StringsNotEqual(str[1], "tusks"))
                value = Race.Parts.tusks;
            else
            {
                ch.SendText("No such part.\r\n");
                return;
            }

            if (!Macros.IsSet(corpse.Values[0], (int)value))
            {
                ch.SendText("That part has either already been removed or never existed.\r\n");
                return;
            }

            Macros.RemoveBit(ref corpse.Values[0], (int)value);
            if (ch.CheckSkill("carve"))
            {
                ch.SendText("You managed to pry it loose!\r\n");
            }
            else
            {
                ch.SendText("You mangled that part badly.\r\n");
                return;
            }

            /* corpse of {0} */
            string name = MUDString.LastArgument(corpse.Name);
            // This is where we would normally create the object...
            Object part;
            switch (value)
            {
                default:
                    part = Database.CreateObject(Database.GetObjTemplate(StaticObjects.OBJECT_NUMBER_SEVERED_SKULL), 0);
                    break;
                case Race.Parts.arms:
                    // Arms are wieldable as a club.
                    part = Database.CreateObject(Database.GetObjTemplate(StaticObjects.OBJECT_NUMBER_SLICED_ARM), 0);
                    break;
                case Race.Parts.legs:
                    // Legs are wieldable as a club, more damage than arms.
                    part = Database.CreateObject(Database.GetObjTemplate(StaticObjects.OBJECT_NUMBER_SLICED_LEG), 0);
                    break;
                case Race.Parts.scalp:
                    // Scalp can be attached to belt.
                    part = Database.CreateObject(Database.GetObjTemplate(StaticObjects.OBJECT_NUMBER_SEVERED_SCALP), 0);
                    break;
                case Race.Parts.heart:
                    // Heart can be eaten as food.
                    part = Database.CreateObject(Database.GetObjTemplate(StaticObjects.OBJECT_NUMBER_TORN_HEART), 0);
                    break;
            }
            string buf = String.Format("{0} {1}", StringConversion.PartsBitString(value), name);
            part.Name = buf;
            part.ShortDescription = String.Empty;
            buf = String.Format("the{0} of {1}", StringConversion.PartsBitString(value), name);
            part.ShortDescription = buf;
            buf = String.Format("The{0} of {1}&n {2} lying here.", StringConversion.PartsBitString(value), name, MUDString.IsAre(StringConversion.PartsBitString(value)));
            part.FullDescription = buf;
            part.Cost = 0;
            part.Level = corpse.Level;
            if (value == Race.Parts.skull) // Should be skull.
                part.Timer = -1;
            else
                part.Timer = MUDMath.Dice(5, 20);
            part.AddFlag(ObjTemplate.ITEM_NOSELL);
            corpse.AddToObject(part);
        }

        /// <summary>
        /// Bandage someone's wounds.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Bandage(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch.IsNPC() || !ch.HasSkill("bandage"))
            {
                ch.SendText("You don't know how to bandage!\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Bandage whom?\r\n");
                return;
            }

            CharData victim = ch.GetCharRoom(str[0]);
            if (victim == null)
            {
                ch.SendText("They're not here.\r\n");
                return;
            }

            if (victim._hitpoints > 0)
            {
                ch.SendText("They do not need your help.\r\n");
                return;
            }

            int chance = ((PC)ch).SkillAptitude["bandage"];

            if (ch.IsClass(CharClass.Names.cleric))
                chance += 4;
            else if (ch.IsClass(CharClass.Names.antipaladin))
                chance -= 4;

            /* Don't allow someone doing more than 1 pt. of damage with bandage. */
            int change = (Math.Max(chance - MUDMath.NumberPercent(), -1) / 20) + 1;

            // Bandage is rarely used, make it likely to increase
            ch.PracticeSkill("bandage");
            ch.PracticeSkill("bandage");
            ch.PracticeSkill("bandage");

            ch.WaitState(Skill.SkillList["bandage"].Delay);

            if (change < 0)
            {
                ch.SendText("You just made the problem worse!\r\n");
                SocketConnection.Act("$n&n tries bandage you but your condition only worsens.", ch, null, victim, SocketConnection.MessageTarget.victim);
                SocketConnection.Act("$n&n tries bandage $N&n but $S condition only worsens.", ch, null, victim, SocketConnection.MessageTarget.everyone_but_victim);
            }
            else if (change > 0)
            {
                ch.SendText("You manage to fix them up a _bitvector.\r\n");
                SocketConnection.Act("$n&n bandages you.", ch, null, victim, SocketConnection.MessageTarget.victim);
                SocketConnection.Act("$n&n bandages $N&n.", ch, null, victim, SocketConnection.MessageTarget.everyone_but_victim);
            }
            else
            {
                ch.SendText("Your bandaging attempt had no effect.\r\n");
                SocketConnection.Act("$n&n tries to bandage you but the wounds are too great.", ch, null, victim, SocketConnection.MessageTarget.victim);
                SocketConnection.Act("$n&n tries to bandage $N&n but is unable to have any effect.", ch, null, victim, SocketConnection.MessageTarget.everyone_but_victim);
            }

            victim._hitpoints += change;

            victim.UpdatePosition();

            return;
        }

        /// <summary>
        /// Command to fly in a particular direction.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Fly(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Room troom;
            Exit texit;

            if (ch._fighting || ch._position == Position.fighting)
            {
                ch.SendText("&+cNot &+Wwhile &+cyou&+Wr fi&+cghting...&n\r\n");
                return;
            }

            if (ch._riding)
            {
                if (!ch._riding.CanFly())
                {
                    ch.SendText("Your mount can't fly.\r\n");
                    return;
                }
            }

            if (str.Length == 0 && ch.CanFly())
            {
                ch.SendText("Yep, you're flying.  Maybe you want to fly up or fly down.");
                return;
            }

            if (str.Length == 0 && !ch.CanFly())
            {
                ch.SendText("Alas you are landbound.\r\n");
                return;
            }

            if (!MUDString.IsPrefixOf(str[0], "up"))
            {
                if (!ch.CanFly())
                {
                    ch.SendText("You cannot fly.\r\n");
                    return;
                }
                if (!ch._inRoom.IsFlyable())
                {
                    ch.SendText("You cannot fly here.\r\n");
                    return;
                }
                if (ch._inRoom.TerrainType == TerrainType.plane_of_air)
                {
                    ch.SendText("That's not really an option here.\r\n");
                    return;
                }
                if (ch._flyLevel < CharData.FlyLevel.high)
                {
                    SocketConnection.Act("$n&n flies up higher.", ch, null, null, SocketConnection.MessageTarget.room);
                    ch._flyLevel++;
                    SocketConnection.Act("$n&n flies in from below.", ch, null, null, SocketConnection.MessageTarget.room);
                    ch.SendText("You fly up.\r\n");
                    CommandType.Interpret(ch, "look auto");
                    foreach (CharData fch in ch._inRoom.People)
                    {
                        if (fch == ch)
                            continue;
                        if (fch._master == ch && fch.CanFly()
                                && fch._flyLevel == (ch._flyLevel - 1)
                                && fch._position == Position.standing
                                && fch.CanMove())
                        {
                            if (fch._flyLevel < CharData.FlyLevel.high)
                            {
                                SocketConnection.Act("$n&n flies up.", fch, null, null, SocketConnection.MessageTarget.room);
                                fch._flyLevel++;
                                fch.SendText("You fly up.\r\n");
                                SocketConnection.Act("$n&n flies in from below.", fch, null, null, SocketConnection.MessageTarget.room);
                            }
                        }
                    }
                }
                else
                {
                    // TODO: Rewrite this to handle the AREA_WORLDMAP flag.

                    //if in a zone then fly out
                    if (ch._inRoom.IndexNumber < StaticRooms.GetRoomNumber("SURFACE_MAP1_START_INDEX_NUMBER"))
                    {
                        int lower = ch._inRoom.Area.LowRoomIndexNumber;
                        int higher = ch._inRoom.Area.HighRoomIndexNumber;
                        // there has to be a better way than checking every room in zone
                        int iroom;
                        for (iroom = lower; iroom <= higher; iroom++)
                        {
                            troom = Room.GetRoom(iroom);
                            if (!troom)
                                continue;
                            //now check all exits
                            int i;
                            for (i = 0; i < Limits.MAX_DIRECTION; i++)
                            {
                                texit = troom.ExitData[i];
                                if (!texit || !(texit.TargetRoom))
                                    continue;
                                if (texit.TargetRoom.IndexNumber >= StaticRooms.GetRoomNumber("SURFACE_MAP1_START_INDEX_NUMBER"))
                                {
                                    //wheee! found a way out
                                    //should check for exit zone being flyable
                                    ch.SendText("You fly up.\r\n");
                                    SocketConnection.Act("$n&n flies up higher.", ch, null, null, SocketConnection.MessageTarget.room);
                                    ch.RemoveFromRoom();
                                    ch.AddToRoom(Room.GetRoom(texit.IndexNumber));

                                    ch._flyLevel = CharData.FlyLevel.low;
                                    CommandType.Interpret(ch, "look auto");
                                    return;
                                }
                            }
                        }
                        ch.SendText("You can't fly out of this zone.\r\n"); //glitch
                    }
                    ch.SendText("If you were any higher you'd be Bob Marley.\r\n");
                }
            }
            else if (!MUDString.IsPrefixOf(str[0], "down"))
            {
                if (ch._flyLevel > 0)
                {
                    SocketConnection.Act("$n&n flies down lower.", ch, null, null, SocketConnection.MessageTarget.room);
                    ch._flyLevel--;
                    SocketConnection.Act("$n&n flies in from above.", ch, null, null, SocketConnection.MessageTarget.room);
                    if (ch._flyLevel == 0)
                        ch.SendText("You fly down to the ground.\r\n");
                    else
                        ch.SendText("You fly down.\r\n");
                    CommandType.Interpret(ch, "look auto");
                    foreach (CharData fch in ch._inRoom.People)
                    {
                        if (fch == ch)
                            continue;
                        if (fch._master == ch && fch.CanFly() && fch._position == Position.standing && fch.CanMove())
                        {
                            SocketConnection.Act("$n&n flies down.", fch, null, null, SocketConnection.MessageTarget.room);
                            fch._flyLevel--;
                            fch.SendText("You fly down.\r\n");
                            SocketConnection.Act("$n&n flies in from above.", fch, null, null, SocketConnection.MessageTarget.room);
                        }
                    }
                }
                else
                {
                    ch.SendText("You're already on the ground.\r\n");
                }
            }
            else if (!MUDString.IsPrefixOf(str[0], "land"))
            {
                if (ch._flyLevel > 0)
                {
                    SocketConnection.Act("$n&n flies down lower.", ch, null, null, SocketConnection.MessageTarget.room);
                    for (; ch._flyLevel > 0; ch._flyLevel--)
                    {
                        SocketConnection.Act("$n&n flies down lower.", ch, null, null, SocketConnection.MessageTarget.room);
                    }
                    ch._flyLevel = 0;
                    SocketConnection.Act("$n&n flies in from above.", ch, null, null, SocketConnection.MessageTarget.room);
                    ch.SendText("You fly down to the ground.\r\n");
                    CommandType.Interpret(ch, "look auto");
                    foreach (CharData fch in ch._inRoom.People)
                    {
                        if (fch == ch)
                            continue;
                        if (fch._master == ch && fch.CanFly()
                                && fch._flyLevel == (ch._flyLevel + 1)
                                && fch._position == Position.standing
                                && fch.CanMove())
                        {
                            for (; fch._flyLevel > 0; fch._flyLevel--)
                            {
                                SocketConnection.Act("$n&n flies down lower.", fch, null, null, SocketConnection.MessageTarget.room);
                            }
                            fch._flyLevel = 0;
                            fch.SendText("You fly down to the ground.\r\n");
                            SocketConnection.Act("$n&n flies in from above.", fch, null, null, SocketConnection.MessageTarget.room);
                        }
                    }
                }
                else
                {
                    ch.SendText("You're already on the ground.\r\n");
                }
            }
            else
            {
                ch.SendText("Fly where?\r\n");
            }

            return;
        }

        /// <summary>
        /// Take your own life.  Includes guards against accidental suicide.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Suicide(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch._fighting)
            {
                ch.SendText("Suicide!?  Just let your opponent finish you off...\r\n");
                return;
            }
            if (ch._level > 20 && !ch.IsImmortal())
            {
                ch.SendText("Suicide is for low level characters only!\r\n");
                return;
            }

            if (ch.IsAffected(Affect.AFFECT_CHARM))
            {
                ch.SendText("Only those with free will can suicide.\r\n");
                if (ch._master)
                {
                    ch._master.SendText("Shame on you for taking advantage like that!\r\n");
                }
                return;
            }
            if (str.Length < 1 || MUDString.StringsNotEqual(str[0], "confirm"))
            {
                ch.SendText("If you really want to kill yourself, try 'suicide confirm'\r\n");
                return;
            }

            // Specifically allowing suicide while bleeding to death.
            if (ch._position < Position.stunned)
            {
                ch.SendText("You give up the will to live.\r\n");
            }
            else
            {
                SocketConnection.Act("With a look of despair in $s eyes, $n&n takes $s own life.", ch, null, null, SocketConnection.MessageTarget.room);
                ch.SendText("You take your own life.\r\n");
            }

            Combat.KillingBlow(ch, ch);

            // Exp loss is that of a normal death
            ch.GainExperience((0 - (((25 + ch._level) * ExperienceTable.Table[ch._level].LevelExperience) / 200)));
            if (ch._level < 2 && ch._experiencePoints < 1)
                ch._experiencePoints = 1;

            return;
        }

        /// <summary>
        /// Command to climb something.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Climb(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int chance;

            if (!ch.HasSkill("climb"))
            {
                ch.SendText("You lack the skills to climb anything.\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Climb what?\r\n");
                return;
            }

            Object obj = ch.GetObjHere(str[0]);
            if (!obj)
            {
                ch.SendText("Uhh... what exactly did you want to climb!?\r\n");
                return;
            }

            if (obj.ItemType != ObjTemplate.ObjectType.wall)
            {
                ch.SendText("That wasn't exactly designed for climbing.\r\n");
                return;
            }

            if (ch.IsNPC())
            {
                chance = ch._level * 3 / 2 + 20;
            }
            else
            {
                chance = ((PC)ch).SkillAptitude["climb"];
            }

            // Agility helps.
            chance += ch.GetCurrAgi() / 10;

            switch (obj.ObjIndexData.IndexNumber)
            {
                case StaticObjects.OBJECT_NUMBER_WALL_STONE:
                    chance += 5;
                    break;
                case StaticObjects.OBJECT_NUMBER_WALL_IRON:
                    chance -= 15;
                    break;
                default:
                    ch.SendText("That wasn't exactly designed for climbing.\r\n");
                    return;
            }

            // Maximum chance of 98%
            if (chance > 98)
                chance = 98;

            if (MUDMath.NumberPercent() >= chance)
            {
                ch.SendText("You try to climb it, but you fall on your ass!\r\n");
                ch._position = Position.sitting;
                ch.WaitState(5);
                return;
            }

            ch.SendText("With great skill, you scale the wall!\r\n");

            // Value 0 of a wall object is the direction that has been walled...
            // This means that they should move in that direction.  We leave it up to
            // move_char to make sure that there is actually an exit in that direction.
            // we use the climbing bit to allow them to pass the walls in move_char.
            ch.SetAffBit(Affect.AFFECT_CLIMBING);
            ch.Move(obj.Values[0]);
            ch.RemoveAffect(Affect.AFFECT_CLIMBING);

            return;
        }

        public static void Coordination(CharData ch, string[] str)
        {
            if( ch == null ) return;

            ch.SendText("Not implemented yet.\r\n");
        }

        public static void Charm(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string arg = String.Empty;
            int amount;

            if (!ch.HasSkill("charm of the otter"))
            {
                ch.SendText("Try all you will, but you're still your plain self.\r\n");
                return;
            }
   
            if (!MUDString.StringsNotEqual(arg, "off"))
            {
                if (ch.HasAffect( Affect.AffectType.skill, "charm of the otter"))
                {
                    //strip the affect
                    ch.AffectStrip( Affect.AffectType.skill, "charm of the otter");
                }
                else
                {
                    ch.SendText("You are not using charm of the otter.\r\n");
                }
                return;
            }
            if (((PC)ch).SkillAptitude["charm of the otter"] >= 95)
                amount = 15;
            else if (((PC)ch).SkillAptitude["charm of the otter"] >= 60)
                amount = 10;
            else
                amount = 5;
            Affect af = new Affect(Affect.AffectType.skill, "charm of the otter", 5 * ch._level, Affect.Apply.charisma, amount, Affect.AFFECT_NONE);
            ch.AddAffect(af);
            ch.SendText("You feel more charasmatic!\r\n");
        }

        public static void Endurance(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string arg = String.Empty;
            int amount;

            if (ch.IsNPC() || ((PC)ch).SkillAptitude["endurance"] == 0)
            {
                ch.SendText("Try all you will, but you're still your plain self.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(arg, "off"))
            {
                if (ch.HasAffect( Affect.AffectType.skill, "endurance"))
                {
                    //strip the affect
                    ch.AffectStrip( Affect.AffectType.skill, "endurance");
                }
                else
                {
                    ch.SendText("You are not using endurance.\r\n");
                }
                return;
            }
            if (((PC)ch).SkillAptitude["endurance"] >= 95)
                amount = 15;
            else if (((PC)ch).SkillAptitude["endurance"] >= 60)
                amount = 10;
            else
                amount = 5;
            Affect af = new Affect(Affect.AffectType.skill, "endurance", 5 * ch._level, Affect.Apply.move, amount, Affect.AFFECT_MOVEMENT_INCREASED);
            ch.AddAffect(af);
            ch.SendText("You feel the endurance of the mountains in your muscles!\r\n");
        }

        public static void Fortitude(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string arg = String.Empty;
            int amount;

            if (ch.IsNPC() || ((PC)ch).SkillAptitude["fortitude"] == 0)
            {
                ch.SendText("Try all you will, but you're still your plain self.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(arg, "off"))
            {
                if (ch.HasAffect( Affect.AffectType.skill, "fortitude"))
                {
                    //strip the affect
                    ch.AffectStrip( Affect.AffectType.skill, "fortitude");
                }
                else
                {
                    ch.SendText("You are not using fortitude.\r\n");
                }
                return;
            }
            if (((PC)ch).SkillAptitude["fortitude"] >= 95)
                amount = 15;
            else if (((PC)ch).SkillAptitude["fortitude"] >= 60)
                amount = 10;
            else
                amount = 5;
            Affect af = new Affect(Affect.AffectType.skill, "fortitude", 5 * ch._level, Affect.Apply.constitution, amount, Affect.AFFECT_NONE);
            ch.AddAffect(af);
            ch.SendText("You feel more fortified.\r\n");
        }

        public static void Insight(CharData ch, string[] str)
        {
            if( ch == null ) return;
            string arg = String.Empty;
            int amount;

            if (ch.IsNPC() || ((PC)ch).SkillAptitude["insight"] == 0)
            {
                ch.SendText("Try all you will, but you're still your plain self.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(arg, "off"))
            {
                if (ch.HasAffect( Affect.AffectType.skill, "insight"))
                {
                    //strip the affect
                    ch.AffectStrip( Affect.AffectType.skill, "insight");
                }
                else
                {
                    ch.SendText("You are not using insight.\r\n");
                }
                return;
            }
            if (((PC)ch).SkillAptitude["insight"] >= 95)
                amount = 15;
            else if (((PC)ch).SkillAptitude["insight"] >= 60)
                amount = 10;
            else
                amount = 5;
            Affect af = new Affect(Affect.AffectType.skill, "insight", 5 * ch._level, Affect.Apply.intelligence, amount, Affect.AFFECT_NONE);
            ch.AddAffect(af);
            ch.SendText("You feel more insightful.\r\n");
        }

        public static void Might(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string arg = String.Empty;
            int amount;

            if (ch.IsNPC() || ((PC)ch).SkillAptitude["might"] == 0)
            {
                ch.SendText("Try all you will, but you're still your plain self.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(arg, "off"))
            {
                if (ch.HasAffect( Affect.AffectType.skill, "might"))
                {
                    //strip the affect
                    ch.AffectStrip( Affect.AffectType.skill, "might");
                }
                else
                {
                    ch.SendText("You are not using might.\r\n");
                }
                return;
            }
            if (((PC)ch).SkillAptitude["might"] >= 95)
                amount = 15;
            else if (((PC)ch).SkillAptitude["might"] >= 60)
                amount = 10;
            else
                amount = 5;
            Affect af = new Affect(Affect.AffectType.skill, "might", 5 * ch._level, Affect.Apply.strength, amount, Affect.AFFECT_STRENGTH_INCREASED);
            ch.AddAffect(af);
            ch.SendText("You feel more mighty.\r\n");
        }

        public static void Savvy(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string arg = String.Empty;
            int amount;

            if (ch.IsNPC() || ((PC)ch).SkillAptitude["savvy"] == 0)
            {
                ch.SendText("Try all you will, but you're still your plain self.\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(arg, "off"))
            {
                if (ch.HasAffect( Affect.AffectType.skill, "savvy"))
                {
                    //strip the affect
                    ch.AffectStrip( Affect.AffectType.skill, "savvy");
                }
                else
                {
                    ch.SendText("You are not using savvy.\r\n");
                }
                return;
            }
            if (((PC)ch).SkillAptitude["savvy"] >= 95)
                amount = 15;
            else if (((PC)ch).SkillAptitude["savvy"] >= 60)
                amount = 10;
            else
                amount = 5;
            Affect af = new Affect(Affect.AffectType.skill, "savvy", 5 * ch._level, Affect.Apply.strength, amount, Affect.AFFECT_STRENGTH_INCREASED);
            ch.AddAffect(af);
            ch.SendText("You feel more savvy.\r\n");
        }

        /// <summary>
        /// The camp function now simply creates a camp event.
        /// The Command.Quit function handles quitters and campers, based
        /// on the camping bit.  The only goofy side effect of this is
        /// that an immortal who is camping can quit and get the
        /// "you roll up in your bedroll" message.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Camp(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch.IsNPC())
                return;

            if (ch._position == Position.fighting || ch._fighting)
            {
                ch.SendText("You're not gifted enough to make camp and fight at the same time.\r\n");
                ch.RemoveActBit(PC.PLAYER_CAMPING);
                return;
            }

            if (ch._flyLevel != 0)
            {
                ch.SendText("Perhaps it would be more comfortable on the ground.\r\n");
                return;
            }

            if (ch.HasActBit(PC.PLAYER_CAMPING))
            {
                ch.SendText("Your preparations are not quite complete.\r\n");
                return;
            }

            if (ch._position < Position.stunned)
            {
                ch.SendText("Just lie still and finish &+RBle&+reding&n!\r\n");
                return;
            }

            SocketConnection.Act("$n&n starts to set up camp.", ch, null, null, SocketConnection.MessageTarget.room);
            ch.SendText("You start to set up camp.\r\n");
            ch.SetActBit(PC.PLAYER_CAMPING);
            // Pass the character, the room they started camping in, and the
            // number of cycles to camp for
            // Pulse camp is 5 seconds, so make them wait for 1.5 minutes
            Event.CreateEvent(Event.EventType.camp, Event.TICK_CAMP, ch, ch._inRoom, 18);

            return;
        }

        /// <summary>
        /// Command to save your character.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Save(CharData ch, string[] str)
        {
            if( ch == null ) return;


            if (ch.IsNPC())
                return;

            ch.SendText("Saving.\r\n");
            CharData.SavePlayer(ch);
            return;
        }

        /// <summary>
        /// Command to follow someone.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Follow(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (str.Length == 0)
            {
                ch.SendText("Follow whom?\r\n");
                return;
            }

            CharData victim = ch.GetCharRoom(str[0]);
            if (!victim)
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }

            if (ch.IsAffected(Affect.AFFECT_CHARM) && ch._master)
            {
                SocketConnection.Act("But you'd rather follow $N&n!", ch, null, ch._master, SocketConnection.MessageTarget.character);
                return;
            }

            if (victim._master == ch)
            {
                ch.SendText("No following in loops!\r\n");
                return;
            }

            if (victim == ch)
            {
                if (!ch._master)
                {
                    ch.SendText("You already follow yourself.\r\n");
                    return;
                }
                Combat.StopFighting(ch, true);
                return;
            }

            if (ch._master)
            {
                Combat.StopFighting(ch, true);
            }

            // This sets following state and then sends a "you now follow" message to the follower.
            CharData.AddFollower(ch, victim);
            return;
        }

        /// <summary>
        /// Give an order to a pet/follower.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Order(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;
            bool all;

            if (str.Length == 0 || str.Length == 0)
            {
                ch.SendText("Order whom to do what?\r\n");
                return;
            }

            if (ch.IsAffected(Affect.AFFECT_CHARM))
            {
                ch.SendText("You feel like taking, not giving, orders, slave!\r\n");
                return;
            }

            if (!MUDString.StringsNotEqual(str[0], "ship"))
            {
                if( str.Length < 2 )
                {
                    ch.SendText("Order the ship to do what?\r\n");
                    return;
                }
                OrderShip(ch, new[] { str[1] } );
                return;
            }

            if (!MUDString.StringsNotEqual(str[0], "all") || !MUDString.IsPrefixOf(str[0], "followers"))
            {
                all = true;
                victim = null;
            }
            else
            {
                all = false;
                victim = ch.GetCharRoom(str[0]);
                if (!victim)
                {
                    ch.SendText("They aren't here.\r\n");
                    return;
                }

                if (victim == ch)
                {
                    ch.SendText("Aye aye, right away!\r\n");
                    return;
                }

                if (!victim.IsAffected(Affect.AFFECT_CHARM) || victim._master != ch)
                {
                    ch.SendText("Do it yourself!\r\n");
                    return;
                }
            }

            bool found = false;
            foreach (CharData och in ch._inRoom.People)
            {
                if (och.IsAffected(Affect.AFFECT_CHARM)
                        && och._master == ch
                        && (all || och == victim))
                {
                    found = true;
                    string text = String.Join(" ", str, 1, (str.Length - 1));
                    SocketConnection.Act("$n&n orders you to '$t'.", ch, text, och, SocketConnection.MessageTarget.victim);
                    if (och._wait > 0)
                        SocketConnection.Act("$N&n seems to be busy at the moment.", ch, null, och, SocketConnection.MessageTarget.character);
                    else
                        CommandType.Interpret(och, text);
                }
            }

            if (found)
                ch.SendText("Done.\r\n");
            else
                ch.SendText("You have no followers here.\r\n");
            return;
        }

        /// <summary>
        /// This modified version for the 4-type coin system by Xangis
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Split(CharData ch, string[] str)
        {
            if( ch == null ) return;

            int members = 0;
            int coinage;
            bool success = false;
            Coins coin = new Coins();

            if (!ch._groupLeader)
            {
                ch.SendText("Split with yourself?  How generous!\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Split how much?\r\n");
                return;
            }

            if (!coin.FillFromString(str, ch))
            {
                ch.SendText("Try 'split <number/all> <coin type>' or 'split all.coins' \r\n");
                return;
            }
            if (coin.Copper == 0 && coin.Silver == 0 && coin.Gold == 0 && coin.Platinum == 0)
            {
                ch.SendText("Try sharing some actual coins!\r\n");
                return;
            }
            foreach (CharData gch in ch._inRoom.People)
            {
                if (gch.IsSameGroup(ch))
                    members++;
            }

            if (members < 2)
            {
                ch.SendText("Just keep it all.\r\n");
                Log.Error("Commandsplit: managed to find a group of 1 person\r\n", 0);
                return;
            }
            for (coinage = 0; coinage < 4; coinage++)
            {
                switch (coinage)
                {
                    case 0: //copper
                        if (coin.Copper <= 0)
                            continue; //quietly ignore errors
                        int share;
                        int extra;
                        string buf;
                        if (coin.Copper <= ch.GetCopper())
                        {
                            share = coin.Copper / members;
                            extra = coin.Copper % members;
                            if (share == 0)
                                continue;
                            ch.SpendCopper(coin.Copper);
                            buf = String.Format(
                                      "You split {0} &+ycopper&n.  Your share is {1} coins.\r\n", coin.Copper, share + extra);
                            ch.SendText(buf);
                            buf = String.Format("$n splits some &+ycopper&n.  Your share is {0} coins.",
                                      share);
                            foreach (CharData gch in ch._inRoom.People)
                            {
                                if (gch != ch && gch.IsSameGroup(ch))
                                {
                                    SocketConnection.Act(buf, ch, null, gch, SocketConnection.MessageTarget.victim);
                                    gch.ReceiveCopper(share);
                                }
                                else if (gch == ch)
                                    gch.ReceiveCopper(share + extra);
                            }
                            success = true;
                            continue;
                        }
                        ch.SendText("You don't have that much &+ycopper&n coin!\r\n");
                        break;
                    case 1: //silver
                        if (coin.Silver <= 0)
                            continue; //quietly ignore errors
                        if (coin.Silver <= ch.GetSilver())
                        {
                            share = coin.Silver / members;
                            extra = coin.Silver % members;
                            if (share == 0)
                                continue;
                            ch.SpendSilver(coin.Silver);
                            buf = String.Format(
                                      "You split {0} &+wsilver&n.  Your share is {1} coins.\r\n", coin.Silver, share + extra);
                            ch.SendText(buf);
                            buf = String.Format("$n splits some &+wsilver&n.  Your share is {0} coins.",
                                      share);
                            foreach (CharData gch in ch._inRoom.People)
                            {
                                if (gch != ch && gch.IsSameGroup(ch))
                                {
                                    SocketConnection.Act(buf, ch, null, gch, SocketConnection.MessageTarget.victim);
                                    gch.ReceiveSilver(share);
                                }
                                else if (gch == ch)
                                {
                                    gch.ReceiveSilver(share + extra);
                                }
                            }
                            success = true;
                            continue;
                        }
                        else
                            ch.SendText("You don't have that much &+wsilver&n coin!\r\n");
                        break;
                    case 2: //gold
                        if (coin.Gold <= 0)
                            continue; //quietly ignore errors
                        if (coin.Gold <= ch.GetGold())
                        {
                            share = coin.Gold / members;
                            extra = coin.Gold % members;
                            if (share == 0)
                                continue;
                            ch.SpendGold(coin.Gold);
                            buf = String.Format(
                                      "You split {0} &+Ygold&n.  Your share is {1} coins.\r\n", coin.Gold, share + extra);
                            ch.SendText(buf);
                            buf = String.Format("$n splits some &+Ygold&n.  Your share is {0} coins.",
                                      share);
                            foreach (CharData gch in ch._inRoom.People)
                            {
                                if (gch != ch && gch.IsSameGroup(ch))
                                {
                                    SocketConnection.Act(buf, ch, null, gch, SocketConnection.MessageTarget.victim);
                                    gch.ReceiveGold(share);
                                }
                                else if (gch == ch)
                                {
                                    gch.ReceiveGold(share + extra);
                                }
                            }
                            success = true;
                            continue;
                        }
                        else
                            ch.SendText("You don't have that much &+Ygold&n coin!\r\n");
                        break;
                    case 3: //platinum
                        if (coin.Platinum <= 0)
                            continue; //quietly ignore errors
                        if (coin.Platinum <= ch.GetPlatinum())
                        {
                            share = coin.Platinum / members;
                            extra = coin.Platinum % members;
                            if (share == 0)
                                continue;
                            ch.SpendPlatinum(coin.Platinum);
                            buf = String.Format(
                                      "You split {0} &+Wplatinum&n.  Your share is {1} coins.\r\n", coin.Platinum, share + extra);
                            ch.SendText(buf);
                            buf = String.Format("$n splits some &+Wplatinum&n.  Your share is {0} coins.",
                                      share);
                            foreach (CharData gch in ch._inRoom.People)
                            {
                                if (gch != ch && gch.IsSameGroup(ch))
                                {
                                    SocketConnection.Act(buf, ch, null, gch, SocketConnection.MessageTarget.victim);
                                    gch.ReceivePlatinum(share);
                                }
                                else if (gch == ch)
                                    gch.ReceivePlatinum(share + extra);
                            }
                            success = true;
                            continue;
                        }
                        ch.SendText("You don't have that much &+Wplatinum&n coin!\r\n");
                        break;
                } //end switch
            } //end for
            if (!success)
            {
                ch.SendText("You didn't seem to split anything.\r\n");
            }
            return;
        }

        public static void GroupChat(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData gch;

            // No arguments, no leader, no chance.
            if (!ch._groupLeader)
            {
                ch.SendText("Tell who, yourself? You are not in a group!\r\n");
                return;
            }
            if (str.Length < 1)
            {
                ch.SendText("Tell your group what?\r\n");
                return;
            }

            if (!ch.CanSpeak())
            {
                ch.SendText("Your lips move but no sound comes out.\r\n");
                return;
            }

            String text = String.Join(" ", str, 1, (str.Length - 1));
            text = DrunkSpeech.MakeDrunk(text, ch);

            /*
            * Note use of Descriptor.send_to_char, so gtell works on sleepers.
            */
            foreach (CharData it in Database.CharList)
            {
                gch = it;
                string buf;
                if (gch == ch)
                {
                    buf = String.Format("&+GYou tell the group '&n&+G{0}&+G'.&n\r\n", text);
                    ch.SendText(buf);
                    continue;
                }
                if (gch.IsSameGroup(ch)
                        && !gch._inRoom.HasFlag(RoomTemplate.ROOM_SILENT)
                        && !gch.HasInnate(Race.RACE_MUTE)
                        && !gch.IsAffected(Affect.AFFECT_MUTE)
                        && gch.IsAwake())
                {
                    buf = String.Format("&+G{0}&n&+G tells the group '&n&+G{1}&+G'.&n\r\n",
                              ch.ShowNameTo(gch, true), SocketConnection.TranslateText(text, ch, gch));
                    gch.SendText(buf);
                }
            }

            return;
        }

        /// <summary>
        /// Sends a beep tone to the target user's terminal.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Beep(CharData ch, string[] str)
        {
            if( ch == null ) return;

            string buf;

            if (ch.IsNPC())
            {
                return;
            }

            if (str.Length < 1)
            {
                ch.SendText("Beep who?\r\n");
                return;
            }

            CharData victim = ch.GetCharWorld(str[0]);
            if (!victim || (ch.IsRacewar(victim)))
            {
                ch.SendText("They are not here.\r\n");
                return;
            }

            if (victim.IsNPC())
            {
                ch.SendText("They are not beepable.\r\n");
                return;
            }

            if (ch != victim)
            {
                buf = String.Format("You beep {0}.\r\n", victim._name);
                ch.SendText(buf);
                buf = String.Format("\a\a{0} has beeped you.\r\n", ch._name);
                victim.SendText(buf);
            }
            else
            {
                buf = String.Format("\aYou beep yourself. Pervert.\a\r\n");
                ch.SendText(buf);
            }

            return;
        }

        public static void Shoot(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object newobj;
            Exit pexit;
            Room toRoom;
            string msg;
            string arg1 = String.Empty; // Target.
            string arg2 = String.Empty; // Direction.
            string arg3 = String.Empty; // Distance.
            int range = 3;
            int dir;
            int n;
            bool inBattle = false;

            if (ch.IsNPC() && ch.HasActBit(MobTemplate.ACT_PET))
                return;

            /* Target specified => arg2 has direction. */
            for (dir = 0; dir < Limits.MAX_DIRECTION; dir++)
            {
                if (dir == Limits.MAX_DIRECTION)
                {
                    ch.SendText("Invalid direction.\r\n");
                    return;
                }
                /* If a _targetType was specified as arg1. */
                if (!MUDString.IsPrefixOf(arg2, Exit.DirectionName[dir]))
                    break;
            }
            if (dir == Limits.MAX_DIRECTION)
                dir = 0;
            /* If arg2 wasn't a direction, then check if arg1 is. */
            if (MUDString.IsPrefixOf(arg2, Exit.DirectionName[dir]))
                for (dir = 0; dir <= Limits.MAX_DIRECTION; dir++)
                {
                    if (dir == Limits.MAX_DIRECTION)
                    {
                        ch.SendText("Invalid direction.\r\n");
                        return;
                    }
                    /* If arg1 is the direction, no _targetType specified. */
                    if (!MUDString.IsPrefixOf(arg1, Exit.DirectionName[dir]))
                    {
                        if (arg2.Length != 0)         // If there is a distance,
                            arg3 = arg2;     // Copy distance into arg3.
                        arg2 = arg1;     // Copy direction into arg2.
                        arg1 = String.Empty;     // Set _targetType to null;
                        break;
                    }
                }

            if (String.IsNullOrEmpty(arg2) || dir < 0)
            {
                ch.SendText("&+LSyntax:  &+RShoot &+L<&n&+rDirection&+L> [&n&+rRange&+L]&n\r\n");
                return;
            }

            Object obj = Object.GetEquipmentOnCharacter(ch, ObjTemplate.WearLocation.hand_two);
            if (!obj)
            {
                ch.SendText("You aren't using a missile weapon.\r\n");
                return;
            }

            if (obj.ItemType != ObjTemplate.ObjectType.ranged_weapon || obj.Values[1] < 0 || obj.Values[2] < 0)
            {
                ch.SendText("You can't do that without a ranged weapon.\r\n");
                return;
            }

            if (obj.Values[4] == 0)
            {
                ch.SendText("Its payload is empty.\r\n");
                return;
            }

            if (obj.Values[3] == ObjTemplate.RNG_CATAPULT)
            {
                if (!String.IsNullOrEmpty(arg3))
                    Int32.TryParse(arg3, out range);

                if (range <= 0)
                {
                    ch.SendText("Try shooting it away from you.\r\n");
                    return;
                }

                if (range > obj.Values[0])
                {
                    if (obj.Values[0] > 0)
                        range = obj.Values[0];
                    else
                        range = 1;
                }
            }

            switch (obj.Values[3])
            {
                default:
                    msg = "You pull back the &n&+ystring&n on {0}&n and fire {1}&n!\r\n";
                    break;
                case ObjTemplate.RNG_BOW:
                    msg = "You pull back the &n&+ystring&n on {0}&n and fire {1}&n!\r\n";
                    break;
                case ObjTemplate.RNG_CROSSBOW:
                    msg = "You fire {0}&n bolt {1}&n!\r\n";
                    break;
                case ObjTemplate.RNG_CATAPULT:
                    msg = "You crank back {0}&n, and release it {1}ward!\r\n";
                    break;
            }
            string buf = String.Format(msg, obj.ShortDescription, Exit.DirectionName[dir]);
            ch.SendText(buf);

            switch (obj.Values[3])
            {
                default:
                    msg = "{0}&n pulls back the &n&+ystring&n on {1}&n and fire {2}&n!";
                    break;
                case ObjTemplate.RNG_BOW:
                    msg = "{0}&n pulls back the &n&+ystring&n on {1}&n and fires {2}&n!";
                    break;
                case ObjTemplate.RNG_CROSSBOW:
                    msg = "{0}&n fires {1} bolt {2}!";
                    break;
                case ObjTemplate.RNG_CATAPULT:
                    msg = "{0}&n cranks back {1}, and releases it {2}ward!";
                    break;
            }
            buf = String.Format(msg, (ch.IsNPC() ? ch._shortDescription : ch._name),
                      obj.ShortDescription, Exit.DirectionName[dir]);
            SocketConnection.Act(buf, ch, null, null, SocketConnection.MessageTarget.room);

            ObjTemplate pObjIndex = Database.GetObjTemplate(obj.Values[5]);
            if (!pObjIndex)
            {
                Log.Error("Ranged weapon (index number {0}) has invalid ammunition.", 0);
                return;
            }

            if (!ch._inRoom.ExitData[dir]
                    || ch._inRoom.ExitData[dir].HasFlag(Exit.ExitFlag.closed))
            {
                newobj = Database.CreateObject(Database.GetObjTemplate(obj.Values[5]), 0);
                if (!newobj)
                    Log.Error("Commandshoot: Missile not created! (1)", 0);
                obj.Values[4]--;

                switch (obj.Values[3])
                {
                    default:
                        msg = "{0}&n impales itself into the &n&+yground&n.";
                        break;
                    case ObjTemplate.RNG_BOW:
                        msg = "{0}&n impales itself into the &n&+yground&n.";
                        break;
                    case ObjTemplate.RNG_CROSSBOW:
                        msg = "{0}&n falls to the &n&+yground&n.";
                        break;
                    case ObjTemplate.RNG_CATAPULT:
                        msg = "{0}&n crashes to the &n&+yground&n.";
                        break;
                }

                buf = String.Format(msg, newobj.ShortDescription);

                SocketConnection.Act(buf.ToUpper(), ch, null, null, SocketConnection.MessageTarget.room);
                SocketConnection.Act(buf.ToUpper(), ch, null, null, SocketConnection.MessageTarget.character);
                newobj.AddToRoom(ch._inRoom);
                return;
            }
            newobj = Database.CreateObject(pObjIndex, 0);
            if (!newobj)
                Log.Error("Commandshoot: Missile not created! (2)", 0);
            obj.Values[4]--;

            for (n = 1, pexit = ch._inRoom.ExitData[dir]; pexit && n <= (range + 1); n++)
            {
                if (pexit.HasFlag(Exit.ExitFlag.closed)
                        || pexit.HasFlag(Exit.ExitFlag.jammed))
                {
                    switch (obj.Values[3])
                    {
                        default:
                            msg = "{0}&n impales itself into the &n&+yground&n.";
                            break;
                        case ObjTemplate.RNG_BOW:
                            msg = "{0}&n impales itself into the &n&+yground&n.";
                            break;
                        case ObjTemplate.RNG_CROSSBOW:
                            msg = "{0}&n falls to the &n&+yground&n.";
                            break;
                        case ObjTemplate.RNG_CATAPULT:
                            msg = "{0}&n crashes to the &n&+yground&n.";
                            break;
                    }

                    buf = String.Format(msg, newobj.ShortDescription);

                    if (Room.GetRoom(pexit.IndexNumber) && Room.GetRoom(pexit.IndexNumber).People.Count > 0)
                    {
                        SocketConnection.Act(buf, Room.GetRoom(pexit.IndexNumber).People[0], null, null, SocketConnection.MessageTarget.room);
                        SocketConnection.Act(buf, Room.GetRoom(pexit.IndexNumber).People[0], null, null, SocketConnection.MessageTarget.character);
                    }

                    newobj.AddToRoom(Room.GetRoom(pexit.IndexNumber));
                    SocketConnection.Act(buf, ch, null, null, SocketConnection.MessageTarget.room);
                    continue;
                }

                toRoom = Room.GetRoom(pexit.IndexNumber);

                if (toRoom.People.Count > 0)
                {
                    foreach (CharData mob in toRoom.People)
                    {
                        if ((mob._position == Position.standing
                                || mob._position == Position.fighting)
                                && (Combat.CheckDodge(ch, mob) || ch._level > MUDMath.NumberPercent()))
                        {
                            buf = String.Format("{0}&n streaks into {1}&n from {2}&n!",
                                      newobj.ShortDescription,
                                      (mob.IsNPC() ? mob._shortDescription : mob._name),
                                      Exit.ReverseDirectionName[dir]);
                            SocketConnection.Act(buf, mob, null, null, SocketConnection.MessageTarget.room);
                            n = range;

                            buf = String.Format("{0}&n streaks into you from {1}&n!",
                                      newobj.ShortDescription, Exit.ReverseDirectionName[dir]);
                            SocketConnection.Act(buf, mob, null, null, SocketConnection.MessageTarget.character);

                            int dam = MUDMath.NumberRange(obj.Values[1], obj.Values[2]);
                            dam += newobj.Values[1];

                            /*
                            * Weapon Proficiencies.
                            */
                            if (!ch.IsNPC() && ((PC)ch).SkillAptitude["archery"] > 0)
                                dam += dam * ((PC)ch).SkillAptitude["archery"] / 150;

                            if (ch._position == Position.fighting || ch._fighting)
                                inBattle = true;
                            newobj.RemoveFromWorld();
                            ;
                            Combat.InflictDamage(ch, mob, dam, String.Empty, ObjTemplate.WearLocation.none, AttackType.DamageType.none);
                            if (!inBattle)
                                Combat.StopFighting(mob, true);
                            else
                                Combat.StopFighting(mob, false);

                            if (mob.IsNPC())
                            {
                                Combat.StartGrudge(mob, ch, false);
                            }

                            if (mob._position > Position.stunned
                                    && obj.Values[3] == ObjTemplate.RNG_CATAPULT)
                            {
                                SocketConnection.Act("The impDescriptor._actFlags puts $n&n to sleep!", mob, null, null, SocketConnection.MessageTarget.room);
                                SocketConnection.Act("The impact puts you to sleep... ZzZzZ", mob, null, null, SocketConnection.MessageTarget.character);
                                mob._position = Position.sleeping;
                            }

                            //      continue;
                            return;
                        }
                    }
                }

                if (toRoom.People.Count > 0)
                {
                    if (n <= range)
                    {
                        buf = String.Format("{0}&n streaks through the air and continues {1}&n.",
                                  newobj.ShortDescription, Exit.DirectionName[dir]);
                        SocketConnection.Act(buf, toRoom.People[0], null, null, SocketConnection.MessageTarget.room);
                        SocketConnection.Act(buf, toRoom.People[0], null, null, SocketConnection.MessageTarget.character);
                    }
                    else
                    {
                        buf = String.Format("{0}&n zooms in and lands on the &n&+yground&n.",
                                  newobj.ShortDescription);
                        SocketConnection.Act(buf, toRoom.People[0], null, null, SocketConnection.MessageTarget.room);
                        SocketConnection.Act(buf, toRoom.People[0], null, null, SocketConnection.MessageTarget.character);
                        newobj.AddToRoom(toRoom);
                    }
                }

                pexit = toRoom.ExitData[dir];
            }

            return;
        }

        /// <summary>
        ///  Weapons #'s:             Ammo #'s:
        /// 0: Range of weapon      0:
        /// 1: Max ammo that can be held    1:
        /// 2: Unused           2:
        /// 3: Type of ammo loadable    3: Type of ammo.
        /// 4: Amount of ammo loaded atm    4:
        /// 5: index number of ammo loaded atm  5:
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Reload(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Object quiver;
            Object ammo = null;

            if (ch.IsNPC() && ch.HasActBit(MobTemplate.ACT_PET))
            {
                return;
            }

            Object weapon = Object.GetEquipmentOnCharacter(ch, ObjTemplate.WearLocation.hand_two);
            if (!weapon)
            {
                ch.SendText("I don't see that weapon here.\r\n");
                return;
            }

            if (weapon.ItemType != ObjTemplate.ObjectType.ranged_weapon)
            {
                ch.SendText("That is not a missile weapon.\r\n");
                return;
            }

            foreach (Object ammoobj in ch._carrying)
            {
                if (ammoobj.ObjIndexData.IndexNumber == weapon.Values[5])
                {
                    ammo = ammoobj;
                    break;
                }
                if (weapon.Values[4] == 0
                        && ammoobj.ItemType == ObjTemplate.ObjectType.missile_weapon
                        && ammoobj.Values[3] == weapon.Values[3])
                {
                    ammo = ammoobj;
                    break;
                }
            }

            if (!ammo && (quiver = Object.GetEquipmentOnCharacter(ch, ObjTemplate.WearLocation.quiver)))
            {
                foreach (Object ammo2 in quiver.Contains)
                {
                    if (ammo2.ObjIndexData.IndexNumber == weapon.Values[5])
                    {
                        ammo = ammo2;
                        break;
                    }
                    if (weapon.Values[4] == 0
                            && ammo2.ItemType == ObjTemplate.ObjectType.missile_weapon
                            && ammo2.Values[3] == weapon.Values[3])
                    {
                        ammo = ammo2;
                        break;
                    }
                }
            }

            if (!ammo)
            {
                if (weapon.Values[4] <= 0)
                    ch.SendText("You do not have ammo for this weapon.\r\n");
                else
                    ch.SendText("You can't load two types of ammo into one weapon.");
                return;
            }

            if (weapon.Values[4] >= weapon.Values[1])
            {
                string buf = String.Format("{0} is already fully loaded.\r\n", weapon.ShortDescription);
                ch.SendText(buf);
                return;
            }

            weapon.Values[5] = ammo.ObjIndexData.IndexNumber;
            weapon.Values[4]++;

            SocketConnection.Act("You get $p&n.", ch, ammo, weapon, SocketConnection.MessageTarget.character);
            SocketConnection.Act("$n&n gets $p&n.", ch, ammo, weapon, SocketConnection.MessageTarget.room);

            SocketConnection.Act("You load $P&n with $p&n.", ch, ammo, weapon, SocketConnection.MessageTarget.character);
            SocketConnection.Act("$n&n loads $P&n with $p&n.", ch, ammo, weapon, SocketConnection.MessageTarget.room);

            ammo.RemoveFromWorld();
            return;
        }

        public static void Disengage(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (!ch._fighting)
            {
                ch.SendText("You're not fighting anyone!\r\n");
                if (ch._position == Position.fighting)
                    ch._position = Position.standing;
                return;
            }

            if (ch._fighting._fighting && ch._fighting._fighting == ch
                    && ch.HasActBit(PC.PLAYER_VICIOUS))
            {
                ch.SendText("You're a little busy getting beat on at the moment.\r\n");
                return;
            }

            ch.SendText("You disengage from the fight!\r\n");
            ch.WaitState(8);
            Combat.StopFighting(ch, false);

            return;
        }

        /// <summary>
        /// Assist someone in combat by joining them against their primary target.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Assist(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;

            if (!ch.IsBlind())
            {
                ch.SendText("You can't assist the invisible.\r\n"); 
                return;
            }
            if (ch._fighting)
            {
                ch.SendText("You're a bit busy at the moment.\r\n");
                return;
            }

            if (str.Length != 0)
            {
                victim = ch.GetCharRoom(str[0]);
                if (!victim)
                {
                    ch.SendText("They aren't here.\r\n");
                    return;
                }
            }
            else
            {
                ch.SendText("Assist who?\r\n");
                return;
            }

            if (victim == ch)
            {
                ch.SendText("You're too busy assisting yourself to assist yourself.\r\n");
                return;
            }

            if (!victim._fighting)
            {
                ch.SendText("They're not fighting anyone.\r\n");
                return;
            }

            if (victim._fighting == ch)
            {
                ch.SendText("Assist!? They're fighting YOU, fool!\r\n");
                return;
            }

            SocketConnection.Act("You scream a battle cry, and assist $N&n heroically.", ch, null, victim, SocketConnection.MessageTarget.character);
            SocketConnection.Act("$n&n leaps into the fray, valiantly assisting you.", ch, null, victim, SocketConnection.MessageTarget.victim);
            SocketConnection.Act("$n&n charges into battle and assists $N&n heroically.", ch, null, victim, SocketConnection.MessageTarget.room_vict);

            Combat.SingleAttack(ch, victim._fighting, String.Empty, ObjTemplate.WearLocation.hand_one);

            return;
        }

        /// <summary>
        /// Command to throw something.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Throw(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;
            string arg3;
            string arg2;
            Object obj;
            Object inHand;
            Object inHand2;
            Room room2;
            int dir;
            bool twoRooms;

            if (true)
            {
                ch.SendText("Throwing weapons are not implemented yet.\r\n");
                return;
            }
            // find an object to throw

            if (str.Length == 0)
            {
                ch.SendText("Throw what exactly?\r\n");
                return;
            }
            inHand = Object.GetEquipmentOnCharacter(ch, ObjTemplate.WearLocation.hand_one);
            inHand2 = Object.GetEquipmentOnCharacter(ch, ObjTemplate.WearLocation.hand_two);
            if (inHand == null && inHand2 == null)
            {
                ch.SendText("You need to be wielding _something_ to throw it!\r\n");
                return;
            }
            //obj ;
            if (inHand && str[0] == inHand.Name)
            {
                obj = inHand;
            }
            else if (inHand2 && str[0] == inHand2.Name)
            {
                obj = inHand2;
            }
            if (!obj)
            {
                ch.SendText("You don't seem to be wielding that.\r\n");
                return;
            }
            // is it throwable?
            twoRooms = !obj.HasFlag(ObjTemplate.ITEM_THROW_TWOROOMS);
            if (!obj.HasFlag(ObjTemplate.ITEM_THROW_ONEROOM) && twoRooms)
            {
                ch.SendText("That is not throwable.\r\n");
                return;
            }

            // now find a valid _targetType

            if (String.IsNullOrEmpty(arg2))
            {
                ch.SendText("Throw it at who?\r\n");
                return;
            }
 
            if (String.IsNullOrEmpty(arg3))
            {
                if (ch._level >= Limits.LEVEL_AVATAR)
                {
                    string lbuf = String.Format("Looking for {0} in same room.\r\n", arg2);
                    ch.SendText(lbuf);
                }
                victim = ch.GetCharRoom(arg2);
                if (!victim)
                {
                    ch.SendText("They aren't here.\r\n");
                    return;
                }
            }
            else
            {
                dir = Movement.FindExit(ch, arg3);
                if (ch._level >= Limits.LEVEL_AVATAR)
                {
                    string lbuf = String.Format("Looking for {0} to the {1}.\r\n", arg2, arg3);
                    ch.SendText(lbuf);
                }
            }
            if (ch._inRoom.ExitData[dir].HasFlag(Exit.ExitFlag.walled)
                    || ch._inRoom.ExitData[dir].HasFlag(Exit.ExitFlag.blocked)
                    || ch._inRoom.ExitData[dir].HasFlag(Exit.ExitFlag.secret)
                    || ch._inRoom.ExitData[dir].HasFlag(Exit.ExitFlag.closed)
                    || !ch._inRoom.ExitData[dir].TargetRoom
                    || ch._inRoom.Area != ch._inRoom.ExitData[dir].TargetRoom.Area)
            {
                ch.SendText("You see nothing in that direction.\r\n");
                return;
            }
            room2 = Movement.FindRoom(ch, arg3);
            if (!room2)
            {
                ch.SendText("You see nothing in that direction.\r\n");
                return;
            }
            victim = null;
            victim = CharData.GetCharAtRoom(room2, ch, arg2);
            if (!victim)
            {
                ch.SendText("They aren't here.\r\n");
                return;
            }
            return;
        }

        public static void Aware(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Affect af = new Affect();

            if (ch.IsNPC())
                return;

            if (!ch.HasSkill("awareness"))
            {
                ch.SendText("Your general obliviousness prevents your use of this skill.\r\n");
                return;
            }

            if (ch.IsAffected(Affect.AFFECT_SKL_AWARE))
            {
                ch.SendText("You are already about as tense as you can get.\r\n");
                return;
            }

            ch.SendText("You try to become more aware of your surroundings.\r\n");

            ch.PracticeSkill("awareness");

            af.Value = "awareness";
            af.Type = Affect.AffectType.skill;
            af.Duration = (ch._level / 3) + 3;
            af.SetBitvector(Affect.AFFECT_SKL_AWARE);
            ch.AddAffect(af);

            return;
        }

        /// <summary>
        /// Stance: Change combat fighting stance for martial artists.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Stance(CharData ch, string[] str)
        {
            if( ch == null ) return;

            MonkSkill stance = null;
            string buf;

            if ((!ch.IsClass(CharClass.Names.monk) && !ch.IsClass(CharClass.Names.mystic)) || ch.IsNPC())
            {
                ch.SendText("You don't know how to do anything fancier than just stand there.\r\n");
                return;
            }

            if (str.Length == 0)
            {
                buf = String.Format("Available stances:  none");

                if (((PC)ch).MonkAptitude["Bear Stance"] != 0)
                    buf += ", bear";
                if (((PC)ch).MonkAptitude["Cat Stance"] != 0)
                    buf += ", cat";
                if (((PC)ch).MonkAptitude["Cobra Stance"] != 0)
                    buf += ", cobra";
                if (((PC)ch).MonkAptitude["Crane Stance"] != 0)
                    buf += ", crane";
                if (((PC)ch).MonkAptitude["Dragon Stance"] != 0)
                    buf += ", dragon";
                if (((PC)ch).MonkAptitude["Dragonfly Stance"] != 0)
                    buf += ", dragonfly";
                if (((PC)ch).MonkAptitude["Hawk Stance"] != 0)
                    buf += ", hawk";
                if (((PC)ch).MonkAptitude["Leopard Stance"] != 0)
                    buf += ", leopard";
                if (((PC)ch).MonkAptitude["Mantis Stance"] != 0)
                    buf += ", mantis";
                if (((PC)ch).MonkAptitude["Monkey Stance"] != 0)
                    buf += ", monkey";
                if (((PC)ch).MonkAptitude["Snake Stance"] != 0)
                    buf += ", snake";
                if (((PC)ch).MonkAptitude["Tiger Stance"] != 0)
                    buf += ", tiger";

                buf += "\r\n";

                ch.SendText(buf);
                return;
            }

            if ("none".StartsWith(str[0]))
            {
                ((PC)ch).Stance = String.Empty;
                SocketConnection.Act("You break out of your fighting stance and return to a relaxed position.", ch, null, null, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n leaves $s fighting stance.", ch, null, null, SocketConnection.MessageTarget.room);
                return;
            }

            if ("bear".StartsWith(str[0]))
                stance = Database.MonkSkillList["Bear Stance"];
            else if ("cat".StartsWith(str[0]))
                stance = Database.MonkSkillList["Cat Stance"];
            else if ("cobra".StartsWith(str[0]))
                stance = Database.MonkSkillList["Cobra Stance"];
            else if ("crane".StartsWith(str[0]))
                stance = Database.MonkSkillList["Crane Stance"];
            else if ("dragon".StartsWith(str[0]))
                stance = Database.MonkSkillList["Dragon Stance"];
            else if ("dragonfly".StartsWith(str[0]))
                stance = Database.MonkSkillList["Bear Stance"];
            else if ("hawk".StartsWith(str[0]))
                stance = Database.MonkSkillList["Hawk Stance"];
            else if ("leopard".StartsWith(str[0]))
                stance = Database.MonkSkillList["Leopard Stance"];
            else if ("mantis".StartsWith(str[0]))
                stance = Database.MonkSkillList["Mantis Stance"];
            else if ("monkey".StartsWith(str[0]))
                stance = Database.MonkSkillList["Monkey Stance"];
            else if ("snake".StartsWith(str[0]))
                stance = Database.MonkSkillList["Snake Stance"];
            else if ("tiger".StartsWith(str[0]))
                stance = Database.MonkSkillList["Tiger Stance"];

            if (((PC)ch).MonkAptitude[stance.Name] == 0)
            {
                buf = String.Format("You try to shift into a {0} stance and realize you have no idea what you are doing.", StringConversion.StanceString(stance.Name));
                SocketConnection.Act(buf, ch, null, null, SocketConnection.MessageTarget.character);
                SocketConnection.Act("$n&n contorts $s body strangely, nearly tying $mself into a knot.  With a frustrated look, $e returns to a standing position.", ch, null, null, SocketConnection.MessageTarget.room);
                ((PC)ch).Stance = String.Empty;
                return;
            }

            ((PC)ch).Stance = stance.Name;

            buf = String.Format("You shift your body into a {0} stance.", StringConversion.StanceString(stance.Name));
            SocketConnection.Act(buf, ch, null, null, SocketConnection.MessageTarget.character);
            buf = String.Format("$n&n changes $s stance, looking much like a {0}", StringConversion.StanceString(stance.Name));
            SocketConnection.Act(buf, ch, null, null, SocketConnection.MessageTarget.room);

            return;
        }

        /// <summary>
        /// Lets a player turn ANSI color on and off.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void ColorCommand(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (!ch.HasActBit(PC.PLAYER_COLOR))
            {
                ch.SetActBit(PC.PLAYER_COLOR);
                ch.SendText("&+LThe world becomes more &n&+mco&+Ml&+Wor&+Cf&n&+cul&+L.&n\r\n");
            }
            else
            {
                SocketConnection.SendToCharBW("The color drains.\r\n", ch);
                ch.RemoveActBit(PC.PLAYER_COLOR);
            }
            return;
        }

        /// <summary>
        /// Retire (delete) a character.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void Retire(CharData ch, string[] str)
        {
            if( ch == null ) return;

            if (ch.IsNPC())
                return;

            if (ch._position == Position.fighting || ch._fighting)
            {
                ch.SendText("No way! You are fighting.\r\n");
                return;
            }

            if (ch._position < Position.stunned)
            {
                ch.SendText("You're not &+RD&n&+rE&+RA&n&+rD&n yet.\r\n");
                return;
            }

            /* If player does not have level 1 he should not have a file... */
            if (ch._level < 1)
            {
                ch.SendText("You haven't logged in yet and you want to retire? I think not.\r\n");
                return;
            }

            ch._socket.WriteToBuffer("Password: ");
            ch._socket._connectionState = SocketConnection.ConnectionState.retire_character_get_password;

            return;
        }

        /// <summary>
        /// Player track command.
        /// </summary>
        /// <param name="ch"></param>
        /// <param name="str"></param>
        public static void TrackCommand(CharData ch, string[] str)
        {
            if( ch == null ) return;

            CharData victim;

            if (ch.IsAffected(Affect.AFFECT_TRACK))
            {
                ch.SendText("You stop tracking.\r\n");
                Combat.StopHunting(ch);
                ch.RemoveAffect(Affect.AFFECT_TRACK);
                return;
            }

            if (!ch.HasSkill("track"))
            {
                ch.SendText("You couldn't track an &+Lelephant&n in your own bedroom.\r\n");
                return;
            }

            if (str.Length == 0)
            {
                ch.SendText("Whom are you trying to track?\r\n");
                return;
            }

            if (ch._riding)
            {
                ch.SendText("You can't sniff a trail mounted.\r\n");
                return;
            }

            if (ch._flyLevel != 0)
            {
                ch.SendText("You find tracks on the _ground_!\r\n");
                return;
            }

            if (ch._inRoom.IsWater())
            {
                ch.SendText("You can't track through water.\r\n");
                return;
            }

            if (ch._position != Position.standing)
            {
                if (ch._position == Position.fighting)
                    ch.SendText("You're too busy fighting .\r\n");
                else
                    ch.SendText("You must be standing to track!\r\n");
                return;
            }

            /* only imps can hunt to different areas */
            bool fArea = (ch.GetTrust() < Limits.LEVEL_OVERLORD);

            if (fArea)
                victim = ch.GetCharInArea(str[0]);
            else
                victim = ch.GetCharWorld(str[0]);

            if (!victim || (!victim.IsNPC() && (ch.IsRacewar(victim)) && !ch.IsImmortal()))
            {
                ch.SendText("You can't find a trail of anyone like that.\r\n");
                return;
            }

            if (ch._inRoom == victim._inRoom)
            {
                SocketConnection.Act("You're already in $N&n's room!", ch, null, victim, SocketConnection.MessageTarget.character);
                return;
            }

            /*
            * Deduct some movement.
            */
            if (ch._currentMoves > 2)
                ch._currentMoves -= 3;
            else
            {
                ch.SendText("You're too exhausted to hunt anyone!\r\n");
                return;
            }

            SocketConnection.Act("$n carefully sniffs the air.", ch, null, null, SocketConnection.MessageTarget.room);
            ch.WaitState(Skill.SkillList["track"].Delay);
            int direction = (int)Track.FindPath(ch._inRoom.IndexNumber, victim._inRoom.IndexNumber,
                                                 ch, -40000, fArea);

            if (direction == -1)
            {
                SocketConnection.Act("You can't sense $N&n's trail from here.",
                     ch, null, victim, SocketConnection.MessageTarget.character);
                return;
            }

            if (direction < 0 || direction >= Limits.MAX_DIRECTION)
            {
                ch.SendText("Hmm... Something seems to be wrong.\r\n");
                return;
            }

            /*
            * Give a random direction if the player misses the die roll.
            */
            if ((ch.IsNPC() && MUDMath.NumberPercent() > 75)  /* NPC @ 25% */
                    || (!ch.IsNPC() && MUDMath.NumberPercent() >   /* PC @ norm */
                         ((PC)ch).SkillAptitude["track"]))
            {
                do
                {
                    direction = MUDMath.NumberDoor();
                }
                while (!(ch._inRoom.ExitData[direction])
                          || !(ch._inRoom.ExitData[direction].TargetRoom));
            }

            ch.PracticeSkill("track");

            /*
            * Display the results of the search.
            */
            ch.SetAffBit(Affect.AFFECT_TRACK);
            string buf = String.Format("You sense $N&n's trail {0} from here...", Exit.DirectionName[direction]);
            SocketConnection.Act(buf, ch, null, victim, SocketConnection.MessageTarget.character);
            if (ch._position == Position.standing)
                ch.Move(direction);
            Combat.StartHunting(ch, victim);

            return;
        }

        public static void LookOut(CharData ch, string[] str)
        {
            if( ch == null ) return;

            Vehicle vehicle;

            if (ch._inRoom == null)
                return;

            foreach (Vehicle it in Database.VehicleList)
            {
                vehicle = it;
                if (vehicle.ParentObject == null)
                    continue;
                if (ch._inRoom.IndexNumber == vehicle.EntryRoomTemplateNumber)
                {
                    if (vehicle.ParentObject.InRoom)
                    {
                        // Copied from farsee code - Xangis
                        Room room = ch._inRoom;
                        ch.RemoveFromRoom();
                        ch.AddToRoom(vehicle.ParentObject.InRoom);
                        CommandType.Interpret(ch, "look");
                        ch.RemoveFromRoom();
                        ch.AddToRoom(room);
                        return;
                    }
                }
            }

            ch.SendText("You do not see that here.\r\n");
            return;
        }
    }
}
